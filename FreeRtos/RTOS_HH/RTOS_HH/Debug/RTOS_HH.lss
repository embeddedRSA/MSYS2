
RTOS_HH.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000024  00800200  000013d2  00001466  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000013d2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000618  00800224  00800224  0000148a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000148a  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000014bc  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000002e0  00000000  00000000  000014fc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00003884  00000000  00000000  000017dc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001759  00000000  00000000  00005060  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001982  00000000  00000000  000067b9  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000734  00000000  00000000  0000813c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000011d7  00000000  00000000  00008870  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00002137  00000000  00000000  00009a47  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000298  00000000  00000000  0000bb7e  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	71 c0       	rjmp	.+226    	; 0xe4 <__ctors_end>
       2:	00 00       	nop
       4:	8f c0       	rjmp	.+286    	; 0x124 <__bad_interrupt>
       6:	00 00       	nop
       8:	8d c0       	rjmp	.+282    	; 0x124 <__bad_interrupt>
       a:	00 00       	nop
       c:	8b c0       	rjmp	.+278    	; 0x124 <__bad_interrupt>
       e:	00 00       	nop
      10:	89 c0       	rjmp	.+274    	; 0x124 <__bad_interrupt>
      12:	00 00       	nop
      14:	87 c0       	rjmp	.+270    	; 0x124 <__bad_interrupt>
      16:	00 00       	nop
      18:	85 c0       	rjmp	.+266    	; 0x124 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	83 c0       	rjmp	.+262    	; 0x124 <__bad_interrupt>
      1e:	00 00       	nop
      20:	81 c0       	rjmp	.+258    	; 0x124 <__bad_interrupt>
      22:	00 00       	nop
      24:	7f c0       	rjmp	.+254    	; 0x124 <__bad_interrupt>
      26:	00 00       	nop
      28:	7d c0       	rjmp	.+250    	; 0x124 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	7b c0       	rjmp	.+246    	; 0x124 <__bad_interrupt>
      2e:	00 00       	nop
      30:	79 c0       	rjmp	.+242    	; 0x124 <__bad_interrupt>
      32:	00 00       	nop
      34:	77 c0       	rjmp	.+238    	; 0x124 <__bad_interrupt>
      36:	00 00       	nop
      38:	75 c0       	rjmp	.+234    	; 0x124 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	73 c0       	rjmp	.+230    	; 0x124 <__bad_interrupt>
      3e:	00 00       	nop
      40:	71 c0       	rjmp	.+226    	; 0x124 <__bad_interrupt>
      42:	00 00       	nop
      44:	6f c0       	rjmp	.+222    	; 0x124 <__bad_interrupt>
      46:	00 00       	nop
      48:	6d c0       	rjmp	.+218    	; 0x124 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	6b c0       	rjmp	.+214    	; 0x124 <__bad_interrupt>
      4e:	00 00       	nop
      50:	69 c0       	rjmp	.+210    	; 0x124 <__bad_interrupt>
      52:	00 00       	nop
      54:	67 c0       	rjmp	.+206    	; 0x124 <__bad_interrupt>
      56:	00 00       	nop
      58:	65 c0       	rjmp	.+202    	; 0x124 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	63 c0       	rjmp	.+198    	; 0x124 <__bad_interrupt>
      5e:	00 00       	nop
      60:	61 c0       	rjmp	.+194    	; 0x124 <__bad_interrupt>
      62:	00 00       	nop
      64:	5f c0       	rjmp	.+190    	; 0x124 <__bad_interrupt>
      66:	00 00       	nop
      68:	5d c0       	rjmp	.+186    	; 0x124 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	5b c0       	rjmp	.+182    	; 0x124 <__bad_interrupt>
      6e:	00 00       	nop
      70:	59 c0       	rjmp	.+178    	; 0x124 <__bad_interrupt>
      72:	00 00       	nop
      74:	57 c0       	rjmp	.+174    	; 0x124 <__bad_interrupt>
      76:	00 00       	nop
      78:	55 c0       	rjmp	.+170    	; 0x124 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	53 c0       	rjmp	.+166    	; 0x124 <__bad_interrupt>
      7e:	00 00       	nop
      80:	51 c0       	rjmp	.+162    	; 0x124 <__bad_interrupt>
      82:	00 00       	nop
      84:	4f c0       	rjmp	.+158    	; 0x124 <__bad_interrupt>
      86:	00 00       	nop
      88:	4d c0       	rjmp	.+154    	; 0x124 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	4b c0       	rjmp	.+150    	; 0x124 <__bad_interrupt>
      8e:	00 00       	nop
      90:	49 c0       	rjmp	.+146    	; 0x124 <__bad_interrupt>
      92:	00 00       	nop
      94:	47 c0       	rjmp	.+142    	; 0x124 <__bad_interrupt>
      96:	00 00       	nop
      98:	45 c0       	rjmp	.+138    	; 0x124 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	43 c0       	rjmp	.+134    	; 0x124 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	41 c0       	rjmp	.+130    	; 0x124 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	3f c0       	rjmp	.+126    	; 0x124 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	3d c0       	rjmp	.+122    	; 0x124 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	3b c0       	rjmp	.+118    	; 0x124 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	39 c0       	rjmp	.+114    	; 0x124 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	37 c0       	rjmp	.+110    	; 0x124 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	35 c0       	rjmp	.+106    	; 0x124 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	26 c3       	rjmp	.+1612   	; 0x70a <__vector_47>
      be:	00 00       	nop
      c0:	31 c0       	rjmp	.+98     	; 0x124 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	2f c0       	rjmp	.+94     	; 0x124 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	2d c0       	rjmp	.+90     	; 0x124 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	2b c0       	rjmp	.+86     	; 0x124 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	29 c0       	rjmp	.+82     	; 0x124 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	27 c0       	rjmp	.+78     	; 0x124 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	25 c0       	rjmp	.+74     	; 0x124 <__bad_interrupt>
      da:	00 00       	nop
      dc:	23 c0       	rjmp	.+70     	; 0x124 <__bad_interrupt>
      de:	00 00       	nop
      e0:	21 c0       	rjmp	.+66     	; 0x124 <__bad_interrupt>
	...

000000e4 <__ctors_end>:
      e4:	11 24       	eor	r1, r1
      e6:	1f be       	out	0x3f, r1	; 63
      e8:	cf ef       	ldi	r28, 0xFF	; 255
      ea:	d1 e2       	ldi	r29, 0x21	; 33
      ec:	de bf       	out	0x3e, r29	; 62
      ee:	cd bf       	out	0x3d, r28	; 61
      f0:	00 e0       	ldi	r16, 0x00	; 0
      f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
      f4:	12 e0       	ldi	r17, 0x02	; 2
      f6:	a0 e0       	ldi	r26, 0x00	; 0
      f8:	b2 e0       	ldi	r27, 0x02	; 2
      fa:	e2 ed       	ldi	r30, 0xD2	; 210
      fc:	f3 e1       	ldi	r31, 0x13	; 19
      fe:	00 e0       	ldi	r16, 0x00	; 0
     100:	0b bf       	out	0x3b, r16	; 59
     102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
     104:	07 90       	elpm	r0, Z+
     106:	0d 92       	st	X+, r0
     108:	a4 32       	cpi	r26, 0x24	; 36
     10a:	b1 07       	cpc	r27, r17
     10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>

0000010e <__do_clear_bss>:
     10e:	28 e0       	ldi	r18, 0x08	; 8
     110:	a4 e2       	ldi	r26, 0x24	; 36
     112:	b2 e0       	ldi	r27, 0x02	; 2
     114:	01 c0       	rjmp	.+2      	; 0x118 <.do_clear_bss_start>

00000116 <.do_clear_bss_loop>:
     116:	1d 92       	st	X+, r1

00000118 <.do_clear_bss_start>:
     118:	ac 33       	cpi	r26, 0x3C	; 60
     11a:	b2 07       	cpc	r27, r18
     11c:	e1 f7       	brne	.-8      	; 0x116 <.do_clear_bss_loop>
     11e:	b7 d0       	rcall	.+366    	; 0x28e <main>
     120:	0c 94 e7 09 	jmp	0x13ce	; 0x13ce <_exit>

00000124 <__bad_interrupt>:
     124:	6d cf       	rjmp	.-294    	; 0x0 <__vectors>

00000126 <initLEDport>:
#define MAX_LED_NR 7

void initLEDport()
{
  // Sæt alle PORTB's ben til at være udgange
  DDRB = 0xFF;
     126:	8f ef       	ldi	r24, 0xFF	; 255
     128:	84 b9       	out	0x04, r24	; 4
  // Sluk alle lysdioderne
  PORTB = 0;
     12a:	15 b8       	out	0x05, r1	; 5
     12c:	08 95       	ret

0000012e <initSwitchPort>:

// Læser alle switches samtidigt
unsigned char switchStatus()
{
  return (~PINA);
}
     12e:	11 b8       	out	0x01, r1	; 1
     130:	08 95       	ret

00000132 <switchOn>:
// Returnerer TRUE, hvis switchen med nummeret
// "switch_nr" er aktiveret - ellers returneres FALSE
unsigned char switchOn(unsigned char switch_nr)
{
unsigned char mask;
  if (switch_nr <= MAX_SWITCH_NR)
     132:	88 30       	cpi	r24, 0x08	; 8
     134:	70 f4       	brcc	.+28     	; 0x152 <switchOn+0x20>
  {
    mask = 0b00000001 << switch_nr;
    return (~PINA & mask);
     136:	90 b1       	in	r25, 0x00	; 0
     138:	49 2f       	mov	r20, r25
     13a:	40 95       	com	r20
     13c:	21 e0       	ldi	r18, 0x01	; 1
     13e:	30 e0       	ldi	r19, 0x00	; 0
     140:	b9 01       	movw	r22, r18
     142:	02 c0       	rjmp	.+4      	; 0x148 <switchOn+0x16>
     144:	66 0f       	add	r22, r22
     146:	77 1f       	adc	r23, r23
     148:	8a 95       	dec	r24
     14a:	e2 f7       	brpl	.-8      	; 0x144 <switchOn+0x12>
     14c:	cb 01       	movw	r24, r22
     14e:	84 23       	and	r24, r20
     150:	08 95       	ret
  }
  else
    return 0;
     152:	80 e0       	ldi	r24, 0x00	; 0
     154:	08 95       	ret

00000156 <InitUART>:
  // Wait for new character received
  while ( (UCSR0A & (1<<7)) == 0 )
  {}                        
  // Then return it
  return UDR0;
}
     156:	0f 93       	push	r16
     158:	1f 93       	push	r17
     15a:	52 2f       	mov	r21, r18
     15c:	8b 01       	movw	r16, r22
     15e:	9c 01       	movw	r18, r24
     160:	0c 52       	subi	r16, 0x2C	; 44
     162:	11 40       	sbci	r17, 0x01	; 1
     164:	21 09       	sbc	r18, r1
     166:	31 09       	sbc	r19, r1
     168:	05 3d       	cpi	r16, 0xD5	; 213
     16a:	10 4c       	sbci	r17, 0xC0	; 192
     16c:	21 40       	sbci	r18, 0x01	; 1
     16e:	31 05       	cpc	r19, r1
     170:	d8 f5       	brcc	.+118    	; 0x1e8 <InitUART+0x92>
     172:	45 50       	subi	r20, 0x05	; 5
     174:	44 30       	cpi	r20, 0x04	; 4
     176:	c0 f5       	brcc	.+112    	; 0x1e8 <InitUART+0x92>
     178:	20 e2       	ldi	r18, 0x20	; 32
     17a:	20 93 c0 00 	sts	0x00C0, r18	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7c00c0>
     17e:	28 e1       	ldi	r18, 0x18	; 24
     180:	20 93 c1 00 	sts	0x00C1, r18	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7c00c1>
     184:	44 0f       	add	r20, r20
     186:	40 93 c2 00 	sts	0x00C2, r20	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7c00c2>
     18a:	55 34       	cpi	r21, 0x45	; 69
     18c:	31 f4       	brne	.+12     	; 0x19a <InitUART+0x44>
     18e:	e2 ec       	ldi	r30, 0xC2	; 194
     190:	f0 e0       	ldi	r31, 0x00	; 0
     192:	20 81       	ld	r18, Z
     194:	20 62       	ori	r18, 0x20	; 32
     196:	20 83       	st	Z, r18
     198:	07 c0       	rjmp	.+14     	; 0x1a8 <InitUART+0x52>
     19a:	5f 34       	cpi	r21, 0x4F	; 79
     19c:	29 f4       	brne	.+10     	; 0x1a8 <InitUART+0x52>
     19e:	e2 ec       	ldi	r30, 0xC2	; 194
     1a0:	f0 e0       	ldi	r31, 0x00	; 0
     1a2:	20 81       	ld	r18, Z
     1a4:	20 63       	ori	r18, 0x30	; 48
     1a6:	20 83       	st	Z, r18
     1a8:	dc 01       	movw	r26, r24
     1aa:	cb 01       	movw	r24, r22
     1ac:	88 0f       	add	r24, r24
     1ae:	99 1f       	adc	r25, r25
     1b0:	aa 1f       	adc	r26, r26
     1b2:	bb 1f       	adc	r27, r27
     1b4:	88 0f       	add	r24, r24
     1b6:	99 1f       	adc	r25, r25
     1b8:	aa 1f       	adc	r26, r26
     1ba:	bb 1f       	adc	r27, r27
     1bc:	9c 01       	movw	r18, r24
     1be:	ad 01       	movw	r20, r26
     1c0:	22 0f       	add	r18, r18
     1c2:	33 1f       	adc	r19, r19
     1c4:	44 1f       	adc	r20, r20
     1c6:	55 1f       	adc	r21, r21
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	60 e0       	ldi	r22, 0x00	; 0
     1d2:	74 e2       	ldi	r23, 0x24	; 36
     1d4:	84 ef       	ldi	r24, 0xF4	; 244
     1d6:	90 e0       	ldi	r25, 0x00	; 0
     1d8:	0e 94 a6 09 	call	0x134c	; 0x134c <__udivmodsi4>
     1dc:	21 50       	subi	r18, 0x01	; 1
     1de:	31 09       	sbc	r19, r1
     1e0:	30 93 c5 00 	sts	0x00C5, r19	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7c00c5>
     1e4:	20 93 c4 00 	sts	0x00C4, r18	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7c00c4>
     1e8:	1f 91       	pop	r17
     1ea:	0f 91       	pop	r16
     1ec:	08 95       	ret

000001ee <SendChar>:
	Tegn : Character for sending. 
*************************************************************************/
void SendChar(char Tegn)
{
  // Wait for transmitter register empty (ready for new character)
  while ( (UCSR0A & (1<<5)) == 0 )
     1ee:	e0 ec       	ldi	r30, 0xC0	; 192
     1f0:	f0 e0       	ldi	r31, 0x00	; 0
     1f2:	90 81       	ld	r25, Z
     1f4:	95 ff       	sbrs	r25, 5
     1f6:	fd cf       	rjmp	.-6      	; 0x1f2 <SendChar+0x4>
  {}
  // Then send the character
  UDR0 = Tegn;
     1f8:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7c00c6>
     1fc:	08 95       	ret

000001fe <SendString>:
Sends 0 terminated string.
Parameter:
   Streng: Pointer to the string. 
*************************************************************************/
void SendString(char* Streng)
{
     1fe:	cf 93       	push	r28
     200:	df 93       	push	r29
     202:	ec 01       	movw	r28, r24
  // Repeat until zero-termination
  while (*Streng != 0)
     204:	88 81       	ld	r24, Y
     206:	88 23       	and	r24, r24
     208:	29 f0       	breq	.+10     	; 0x214 <SendString+0x16>
     20a:	21 96       	adiw	r28, 0x01	; 1
  {
    // Send the character pointed to by "Streng"
    SendChar(*Streng);
     20c:	f0 df       	rcall	.-32     	; 0x1ee <SendChar>
   Streng: Pointer to the string. 
*************************************************************************/
void SendString(char* Streng)
{
  // Repeat until zero-termination
  while (*Streng != 0)
     20e:	89 91       	ld	r24, Y+
     210:	81 11       	cpse	r24, r1
     212:	fc cf       	rjmp	.-8      	; 0x20c <SendString+0xe>
    // Send the character pointed to by "Streng"
    SendChar(*Streng);
    // Advance the pointer one step
    Streng++;
  }
}
     214:	df 91       	pop	r29
     216:	cf 91       	pop	r28
     218:	08 95       	ret

0000021a <vDecrementer>:
	 uint8_t buffer=0;
	 while (1)
	 {
		 xQueueReceive(xQueueCount,&buffer,0);
		 //SendInteger((char)buffer);
		 writeAllLEDs(buffer);
     21a:	cf 93       	push	r28
     21c:	df 93       	push	r29
     21e:	1f 92       	push	r1
     220:	1f 92       	push	r1
     222:	cd b7       	in	r28, 0x3d	; 61
     224:	de b7       	in	r29, 0x3e	; 62
     226:	f5 d5       	rcall	.+3050   	; 0xe12 <xTaskGetTickCount>
     228:	9a 83       	std	Y+2, r25	; 0x02
     22a:	89 83       	std	Y+1, r24	; 0x01
     22c:	80 e0       	ldi	r24, 0x00	; 0
     22e:	90 e0       	ldi	r25, 0x00	; 0
     230:	80 df       	rcall	.-256    	; 0x132 <switchOn>
     232:	89 2b       	or	r24, r25
     234:	d9 f3       	breq	.-10     	; 0x22c <vDecrementer+0x12>
     236:	20 e0       	ldi	r18, 0x00	; 0
     238:	40 e0       	ldi	r20, 0x00	; 0
     23a:	50 e0       	ldi	r21, 0x00	; 0
     23c:	60 e0       	ldi	r22, 0x00	; 0
     23e:	70 e0       	ldi	r23, 0x00	; 0
     240:	80 91 25 02 	lds	r24, 0x0225	; 0x800225 <xSemaphoreCount>
     244:	90 91 26 02 	lds	r25, 0x0226	; 0x800226 <xSemaphoreCount+0x1>
     248:	fc d3       	rcall	.+2040   	; 0xa42 <xQueueGenericReceive>
     24a:	80 91 24 02 	lds	r24, 0x0224	; 0x800224 <__data_end>
     24e:	81 50       	subi	r24, 0x01	; 1
     250:	80 93 24 02 	sts	0x0224, r24	; 0x800224 <__data_end>
     254:	82 e0       	ldi	r24, 0x02	; 2
     256:	92 e0       	ldi	r25, 0x02	; 2
     258:	d2 df       	rcall	.-92     	; 0x1fe <SendString>
     25a:	20 e0       	ldi	r18, 0x00	; 0
     25c:	40 e0       	ldi	r20, 0x00	; 0
     25e:	50 e0       	ldi	r21, 0x00	; 0
     260:	64 e2       	ldi	r22, 0x24	; 36
     262:	72 e0       	ldi	r23, 0x02	; 2
     264:	80 91 27 02 	lds	r24, 0x0227	; 0x800227 <xQueueCount>
     268:	90 91 28 02 	lds	r25, 0x0228	; 0x800228 <xQueueCount+0x1>
     26c:	5e d3       	rcall	.+1724   	; 0x92a <xQueueGenericSend>
     26e:	20 e0       	ldi	r18, 0x00	; 0
     270:	40 e0       	ldi	r20, 0x00	; 0
     272:	50 e0       	ldi	r21, 0x00	; 0
     274:	60 e0       	ldi	r22, 0x00	; 0
     276:	70 e0       	ldi	r23, 0x00	; 0
     278:	80 91 25 02 	lds	r24, 0x0225	; 0x800225 <xSemaphoreCount>
     27c:	90 91 26 02 	lds	r25, 0x0226	; 0x800226 <xSemaphoreCount+0x1>
     280:	54 d3       	rcall	.+1704   	; 0x92a <xQueueGenericSend>
     282:	64 ef       	ldi	r22, 0xF4	; 244
     284:	71 e0       	ldi	r23, 0x01	; 1
     286:	ce 01       	movw	r24, r28
     288:	01 96       	adiw	r24, 0x01	; 1
     28a:	0f d7       	rcall	.+3614   	; 0x10aa <vTaskDelayUntil>
     28c:	cf cf       	rjmp	.-98     	; 0x22c <vDecrementer+0x12>

0000028e <main>:
  while(1)
  {}
	  **/
	
	//exercise 3
  initSwitchPort();
     28e:	4f df       	rcall	.-354    	; 0x12e <initSwitchPort>
  initLEDport();
     290:	4a df       	rcall	.-364    	; 0x126 <initLEDport>
     292:	48 e0       	ldi	r20, 0x08	; 8
  InitUART(115200,8);
     294:	50 e0       	ldi	r21, 0x00	; 0
     296:	60 e0       	ldi	r22, 0x00	; 0
     298:	72 ec       	ldi	r23, 0xC2	; 194
     29a:	81 e0       	ldi	r24, 0x01	; 1
     29c:	90 e0       	ldi	r25, 0x00	; 0
     29e:	5b df       	rcall	.-330    	; 0x156 <InitUART>
     2a0:	43 e0       	ldi	r20, 0x03	; 3

  vSemaphoreCreateBinary(xSemaphoreCount);
     2a2:	60 e0       	ldi	r22, 0x00	; 0
     2a4:	81 e0       	ldi	r24, 0x01	; 1
     2a6:	f6 d2       	rcall	.+1516   	; 0x894 <xQueueGenericCreate>
     2a8:	90 93 26 02 	sts	0x0226, r25	; 0x800226 <xSemaphoreCount+0x1>
     2ac:	80 93 25 02 	sts	0x0225, r24	; 0x800225 <xSemaphoreCount>
     2b0:	00 97       	sbiw	r24, 0x00	; 0
     2b2:	31 f0       	breq	.+12     	; 0x2c0 <main+0x32>
     2b4:	20 e0       	ldi	r18, 0x00	; 0
     2b6:	40 e0       	ldi	r20, 0x00	; 0
     2b8:	50 e0       	ldi	r21, 0x00	; 0
     2ba:	60 e0       	ldi	r22, 0x00	; 0
     2bc:	70 e0       	ldi	r23, 0x00	; 0
     2be:	35 d3       	rcall	.+1642   	; 0x92a <xQueueGenericSend>
  xQueueCount = xQueueCreate(10,sizeof(uint8_t));
     2c0:	40 e0       	ldi	r20, 0x00	; 0
     2c2:	61 e0       	ldi	r22, 0x01	; 1
     2c4:	8a e0       	ldi	r24, 0x0A	; 10
     2c6:	e6 d2       	rcall	.+1484   	; 0x894 <xQueueGenericCreate>
     2c8:	90 93 28 02 	sts	0x0228, r25	; 0x800228 <xQueueCount+0x1>
     2cc:	80 93 27 02 	sts	0x0227, r24	; 0x800227 <xQueueCount>
     2d0:	a1 2c       	mov	r10, r1
  
  xTaskCreate( vDecrementer, ( signed char * ) "Dec", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY+1, NULL );
     2d2:	b1 2c       	mov	r11, r1
     2d4:	c1 2c       	mov	r12, r1
     2d6:	d1 2c       	mov	r13, r1
     2d8:	e1 2c       	mov	r14, r1
     2da:	f1 2c       	mov	r15, r1
     2dc:	01 e0       	ldi	r16, 0x01	; 1
     2de:	20 e0       	ldi	r18, 0x00	; 0
     2e0:	30 e0       	ldi	r19, 0x00	; 0
     2e2:	45 e5       	ldi	r20, 0x55	; 85
     2e4:	50 e0       	ldi	r21, 0x00	; 0
     2e6:	6a e1       	ldi	r22, 0x1A	; 26
     2e8:	72 e0       	ldi	r23, 0x02	; 2
     2ea:	8d e0       	ldi	r24, 0x0D	; 13
     2ec:	91 e0       	ldi	r25, 0x01	; 1
     2ee:	81 d4       	rcall	.+2306   	; 0xbf2 <xTaskGenericCreate>
  //xTaskCreate( vIncrementer, ( signed char * ) "Inc", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY+1, NULL );
  //xTaskCreate( vCounter, ( signed char * ) "Count", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
 
  
  vTaskStartScheduler();
     2f0:	61 d5       	rcall	.+2754   	; 0xdb4 <vTaskStartScheduler>
     2f2:	ff cf       	rjmp	.-2      	; 0x2f2 <main+0x64>

000002f4 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     2f4:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     2f6:	03 96       	adiw	r24, 0x03	; 3
     2f8:	92 83       	std	Z+2, r25	; 0x02
     2fa:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     2fc:	2f ef       	ldi	r18, 0xFF	; 255
     2fe:	3f ef       	ldi	r19, 0xFF	; 255
     300:	34 83       	std	Z+4, r19	; 0x04
     302:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     304:	96 83       	std	Z+6, r25	; 0x06
     306:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     308:	90 87       	std	Z+8, r25	; 0x08
     30a:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     30c:	10 82       	st	Z, r1
     30e:	08 95       	ret

00000310 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     310:	fc 01       	movw	r30, r24
     312:	11 86       	std	Z+9, r1	; 0x09
     314:	10 86       	std	Z+8, r1	; 0x08
     316:	08 95       	ret

00000318 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     318:	cf 93       	push	r28
     31a:	df 93       	push	r29
     31c:	fc 01       	movw	r30, r24
     31e:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     320:	21 81       	ldd	r18, Z+1	; 0x01
     322:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     324:	e9 01       	movw	r28, r18
     326:	8a 81       	ldd	r24, Y+2	; 0x02
     328:	9b 81       	ldd	r25, Y+3	; 0x03
     32a:	13 96       	adiw	r26, 0x03	; 3
     32c:	9c 93       	st	X, r25
     32e:	8e 93       	st	-X, r24
     330:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
     332:	81 81       	ldd	r24, Z+1	; 0x01
     334:	92 81       	ldd	r25, Z+2	; 0x02
     336:	15 96       	adiw	r26, 0x05	; 5
     338:	9c 93       	st	X, r25
     33a:	8e 93       	st	-X, r24
     33c:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     33e:	8a 81       	ldd	r24, Y+2	; 0x02
     340:	9b 81       	ldd	r25, Y+3	; 0x03
     342:	ec 01       	movw	r28, r24
     344:	7d 83       	std	Y+5, r23	; 0x05
     346:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     348:	e9 01       	movw	r28, r18
     34a:	7b 83       	std	Y+3, r23	; 0x03
     34c:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     34e:	72 83       	std	Z+2, r23	; 0x02
     350:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     352:	19 96       	adiw	r26, 0x09	; 9
     354:	fc 93       	st	X, r31
     356:	ee 93       	st	-X, r30
     358:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
     35a:	80 81       	ld	r24, Z
     35c:	8f 5f       	subi	r24, 0xFF	; 255
     35e:	80 83       	st	Z, r24
}
     360:	df 91       	pop	r29
     362:	cf 91       	pop	r28
     364:	08 95       	ret

00000366 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     366:	cf 93       	push	r28
     368:	df 93       	push	r29
     36a:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     36c:	48 81       	ld	r20, Y
     36e:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     370:	4f 3f       	cpi	r20, 0xFF	; 255
     372:	2f ef       	ldi	r18, 0xFF	; 255
     374:	52 07       	cpc	r21, r18
     376:	31 f4       	brne	.+12     	; 0x384 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     378:	dc 01       	movw	r26, r24
     37a:	17 96       	adiw	r26, 0x07	; 7
     37c:	ed 91       	ld	r30, X+
     37e:	fc 91       	ld	r31, X
     380:	18 97       	sbiw	r26, 0x08	; 8
     382:	17 c0       	rjmp	.+46     	; 0x3b2 <vListInsert+0x4c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     384:	fc 01       	movw	r30, r24
     386:	33 96       	adiw	r30, 0x03	; 3
     388:	dc 01       	movw	r26, r24
     38a:	15 96       	adiw	r26, 0x05	; 5
     38c:	2d 91       	ld	r18, X+
     38e:	3c 91       	ld	r19, X
     390:	16 97       	sbiw	r26, 0x06	; 6
     392:	d9 01       	movw	r26, r18
     394:	2d 91       	ld	r18, X+
     396:	3c 91       	ld	r19, X
     398:	42 17       	cp	r20, r18
     39a:	53 07       	cpc	r21, r19
     39c:	50 f0       	brcs	.+20     	; 0x3b2 <vListInsert+0x4c>
     39e:	02 80       	ldd	r0, Z+2	; 0x02
     3a0:	f3 81       	ldd	r31, Z+3	; 0x03
     3a2:	e0 2d       	mov	r30, r0
     3a4:	a2 81       	ldd	r26, Z+2	; 0x02
     3a6:	b3 81       	ldd	r27, Z+3	; 0x03
     3a8:	2d 91       	ld	r18, X+
     3aa:	3c 91       	ld	r19, X
     3ac:	42 17       	cp	r20, r18
     3ae:	53 07       	cpc	r21, r19
     3b0:	b0 f7       	brcc	.-20     	; 0x39e <vListInsert+0x38>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     3b2:	a2 81       	ldd	r26, Z+2	; 0x02
     3b4:	b3 81       	ldd	r27, Z+3	; 0x03
     3b6:	bb 83       	std	Y+3, r27	; 0x03
     3b8:	aa 83       	std	Y+2, r26	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     3ba:	15 96       	adiw	r26, 0x05	; 5
     3bc:	dc 93       	st	X, r29
     3be:	ce 93       	st	-X, r28
     3c0:	14 97       	sbiw	r26, 0x04	; 4
	pxNewListItem->pxPrevious = pxIterator;
     3c2:	fd 83       	std	Y+5, r31	; 0x05
     3c4:	ec 83       	std	Y+4, r30	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     3c6:	d3 83       	std	Z+3, r29	; 0x03
     3c8:	c2 83       	std	Z+2, r28	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     3ca:	99 87       	std	Y+9, r25	; 0x09
     3cc:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     3ce:	fc 01       	movw	r30, r24
     3d0:	20 81       	ld	r18, Z
     3d2:	2f 5f       	subi	r18, 0xFF	; 255
     3d4:	20 83       	st	Z, r18
}
     3d6:	df 91       	pop	r29
     3d8:	cf 91       	pop	r28
     3da:	08 95       	ret

000003dc <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     3dc:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     3de:	a2 81       	ldd	r26, Z+2	; 0x02
     3e0:	b3 81       	ldd	r27, Z+3	; 0x03
     3e2:	84 81       	ldd	r24, Z+4	; 0x04
     3e4:	95 81       	ldd	r25, Z+5	; 0x05
     3e6:	15 96       	adiw	r26, 0x05	; 5
     3e8:	9c 93       	st	X, r25
     3ea:	8e 93       	st	-X, r24
     3ec:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     3ee:	a4 81       	ldd	r26, Z+4	; 0x04
     3f0:	b5 81       	ldd	r27, Z+5	; 0x05
     3f2:	82 81       	ldd	r24, Z+2	; 0x02
     3f4:	93 81       	ldd	r25, Z+3	; 0x03
     3f6:	13 96       	adiw	r26, 0x03	; 3
     3f8:	9c 93       	st	X, r25
     3fa:	8e 93       	st	-X, r24
     3fc:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     3fe:	a0 85       	ldd	r26, Z+8	; 0x08
     400:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     402:	11 96       	adiw	r26, 0x01	; 1
     404:	8d 91       	ld	r24, X+
     406:	9c 91       	ld	r25, X
     408:	12 97       	sbiw	r26, 0x02	; 2
     40a:	e8 17       	cp	r30, r24
     40c:	f9 07       	cpc	r31, r25
     40e:	31 f4       	brne	.+12     	; 0x41c <__LOCK_REGION_LENGTH__+0x1c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     410:	84 81       	ldd	r24, Z+4	; 0x04
     412:	95 81       	ldd	r25, Z+5	; 0x05
     414:	12 96       	adiw	r26, 0x02	; 2
     416:	9c 93       	st	X, r25
     418:	8e 93       	st	-X, r24
     41a:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
     41c:	11 86       	std	Z+9, r1	; 0x09
     41e:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     420:	8c 91       	ld	r24, X
     422:	81 50       	subi	r24, 0x01	; 1
     424:	8c 93       	st	X, r24
     426:	08 95       	ret

00000428 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     428:	31 e1       	ldi	r19, 0x11	; 17
     42a:	fc 01       	movw	r30, r24
     42c:	30 83       	st	Z, r19
     42e:	31 97       	sbiw	r30, 0x01	; 1
     430:	22 e2       	ldi	r18, 0x22	; 34
     432:	20 83       	st	Z, r18
     434:	31 97       	sbiw	r30, 0x01	; 1
     436:	a3 e3       	ldi	r26, 0x33	; 51
     438:	a0 83       	st	Z, r26
     43a:	31 97       	sbiw	r30, 0x01	; 1
     43c:	60 83       	st	Z, r22
     43e:	31 97       	sbiw	r30, 0x01	; 1
     440:	70 83       	st	Z, r23
     442:	31 97       	sbiw	r30, 0x01	; 1
     444:	10 82       	st	Z, r1
     446:	31 97       	sbiw	r30, 0x01	; 1
     448:	10 82       	st	Z, r1
     44a:	31 97       	sbiw	r30, 0x01	; 1
     44c:	60 e8       	ldi	r22, 0x80	; 128
     44e:	60 83       	st	Z, r22
     450:	31 97       	sbiw	r30, 0x01	; 1
     452:	10 82       	st	Z, r1
     454:	31 97       	sbiw	r30, 0x01	; 1
     456:	10 82       	st	Z, r1
     458:	31 97       	sbiw	r30, 0x01	; 1
     45a:	10 82       	st	Z, r1
     45c:	31 97       	sbiw	r30, 0x01	; 1
     45e:	62 e0       	ldi	r22, 0x02	; 2
     460:	60 83       	st	Z, r22
     462:	31 97       	sbiw	r30, 0x01	; 1
     464:	63 e0       	ldi	r22, 0x03	; 3
     466:	60 83       	st	Z, r22
     468:	31 97       	sbiw	r30, 0x01	; 1
     46a:	64 e0       	ldi	r22, 0x04	; 4
     46c:	60 83       	st	Z, r22
     46e:	31 97       	sbiw	r30, 0x01	; 1
     470:	65 e0       	ldi	r22, 0x05	; 5
     472:	60 83       	st	Z, r22
     474:	31 97       	sbiw	r30, 0x01	; 1
     476:	66 e0       	ldi	r22, 0x06	; 6
     478:	60 83       	st	Z, r22
     47a:	31 97       	sbiw	r30, 0x01	; 1
     47c:	67 e0       	ldi	r22, 0x07	; 7
     47e:	60 83       	st	Z, r22
     480:	31 97       	sbiw	r30, 0x01	; 1
     482:	68 e0       	ldi	r22, 0x08	; 8
     484:	60 83       	st	Z, r22
     486:	31 97       	sbiw	r30, 0x01	; 1
     488:	69 e0       	ldi	r22, 0x09	; 9
     48a:	60 83       	st	Z, r22
     48c:	31 97       	sbiw	r30, 0x01	; 1
     48e:	60 e1       	ldi	r22, 0x10	; 16
     490:	60 83       	st	Z, r22
     492:	31 97       	sbiw	r30, 0x01	; 1
     494:	30 83       	st	Z, r19
     496:	31 97       	sbiw	r30, 0x01	; 1
     498:	32 e1       	ldi	r19, 0x12	; 18
     49a:	30 83       	st	Z, r19
     49c:	31 97       	sbiw	r30, 0x01	; 1
     49e:	33 e1       	ldi	r19, 0x13	; 19
     4a0:	30 83       	st	Z, r19
     4a2:	31 97       	sbiw	r30, 0x01	; 1
     4a4:	34 e1       	ldi	r19, 0x14	; 20
     4a6:	30 83       	st	Z, r19
     4a8:	31 97       	sbiw	r30, 0x01	; 1
     4aa:	35 e1       	ldi	r19, 0x15	; 21
     4ac:	30 83       	st	Z, r19
     4ae:	31 97       	sbiw	r30, 0x01	; 1
     4b0:	36 e1       	ldi	r19, 0x16	; 22
     4b2:	30 83       	st	Z, r19
     4b4:	31 97       	sbiw	r30, 0x01	; 1
     4b6:	37 e1       	ldi	r19, 0x17	; 23
     4b8:	30 83       	st	Z, r19
     4ba:	31 97       	sbiw	r30, 0x01	; 1
     4bc:	38 e1       	ldi	r19, 0x18	; 24
     4be:	30 83       	st	Z, r19
     4c0:	31 97       	sbiw	r30, 0x01	; 1
     4c2:	39 e1       	ldi	r19, 0x19	; 25
     4c4:	30 83       	st	Z, r19
     4c6:	31 97       	sbiw	r30, 0x01	; 1
     4c8:	30 e2       	ldi	r19, 0x20	; 32
     4ca:	30 83       	st	Z, r19
     4cc:	31 97       	sbiw	r30, 0x01	; 1
     4ce:	31 e2       	ldi	r19, 0x21	; 33
     4d0:	30 83       	st	Z, r19
     4d2:	31 97       	sbiw	r30, 0x01	; 1
     4d4:	20 83       	st	Z, r18
     4d6:	31 97       	sbiw	r30, 0x01	; 1
     4d8:	23 e2       	ldi	r18, 0x23	; 35
     4da:	20 83       	st	Z, r18
     4dc:	31 97       	sbiw	r30, 0x01	; 1
     4de:	40 83       	st	Z, r20
     4e0:	31 97       	sbiw	r30, 0x01	; 1
     4e2:	50 83       	st	Z, r21
     4e4:	31 97       	sbiw	r30, 0x01	; 1
     4e6:	26 e2       	ldi	r18, 0x26	; 38
     4e8:	20 83       	st	Z, r18
     4ea:	31 97       	sbiw	r30, 0x01	; 1
     4ec:	27 e2       	ldi	r18, 0x27	; 39
     4ee:	20 83       	st	Z, r18
     4f0:	31 97       	sbiw	r30, 0x01	; 1
     4f2:	28 e2       	ldi	r18, 0x28	; 40
     4f4:	20 83       	st	Z, r18
     4f6:	31 97       	sbiw	r30, 0x01	; 1
     4f8:	29 e2       	ldi	r18, 0x29	; 41
     4fa:	20 83       	st	Z, r18
     4fc:	31 97       	sbiw	r30, 0x01	; 1
     4fe:	20 e3       	ldi	r18, 0x30	; 48
     500:	20 83       	st	Z, r18
     502:	31 97       	sbiw	r30, 0x01	; 1
     504:	21 e3       	ldi	r18, 0x31	; 49
     506:	20 83       	st	Z, r18
     508:	89 97       	sbiw	r24, 0x29	; 41
     50a:	08 95       	ret

0000050c <xPortStartScheduler>:
     50c:	10 92 29 01 	sts	0x0129, r1	; 0x800129 <__TEXT_REGION_LENGTH__+0x7c0129>
     510:	89 ef       	ldi	r24, 0xF9	; 249
     512:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <__TEXT_REGION_LENGTH__+0x7c0128>
     516:	8b e0       	ldi	r24, 0x0B	; 11
     518:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <__TEXT_REGION_LENGTH__+0x7c0121>
     51c:	e3 e7       	ldi	r30, 0x73	; 115
     51e:	f0 e0       	ldi	r31, 0x00	; 0
     520:	80 81       	ld	r24, Z
     522:	82 60       	ori	r24, 0x02	; 2
     524:	80 83       	st	Z, r24
     526:	a0 91 3a 08 	lds	r26, 0x083A	; 0x80083a <pxCurrentTCB>
     52a:	b0 91 3b 08 	lds	r27, 0x083B	; 0x80083b <pxCurrentTCB+0x1>
     52e:	cd 91       	ld	r28, X+
     530:	cd bf       	out	0x3d, r28	; 61
     532:	dd 91       	ld	r29, X+
     534:	de bf       	out	0x3e, r29	; 62
     536:	ff 91       	pop	r31
     538:	ef 91       	pop	r30
     53a:	df 91       	pop	r29
     53c:	cf 91       	pop	r28
     53e:	bf 91       	pop	r27
     540:	af 91       	pop	r26
     542:	9f 91       	pop	r25
     544:	8f 91       	pop	r24
     546:	7f 91       	pop	r23
     548:	6f 91       	pop	r22
     54a:	5f 91       	pop	r21
     54c:	4f 91       	pop	r20
     54e:	3f 91       	pop	r19
     550:	2f 91       	pop	r18
     552:	1f 91       	pop	r17
     554:	0f 91       	pop	r16
     556:	ff 90       	pop	r15
     558:	ef 90       	pop	r14
     55a:	df 90       	pop	r13
     55c:	cf 90       	pop	r12
     55e:	bf 90       	pop	r11
     560:	af 90       	pop	r10
     562:	9f 90       	pop	r9
     564:	8f 90       	pop	r8
     566:	7f 90       	pop	r7
     568:	6f 90       	pop	r6
     56a:	5f 90       	pop	r5
     56c:	4f 90       	pop	r4
     56e:	3f 90       	pop	r3
     570:	2f 90       	pop	r2
     572:	1f 90       	pop	r1
     574:	0f 90       	pop	r0
     576:	0c be       	out	0x3c, r0	; 60
     578:	0f 90       	pop	r0
     57a:	0b be       	out	0x3b, r0	; 59
     57c:	0f 90       	pop	r0
     57e:	0f be       	out	0x3f, r0	; 63
     580:	0f 90       	pop	r0
     582:	08 95       	ret
     584:	81 e0       	ldi	r24, 0x01	; 1
     586:	08 95       	ret

00000588 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     588:	0f 92       	push	r0
     58a:	0f b6       	in	r0, 0x3f	; 63
     58c:	f8 94       	cli
     58e:	0f 92       	push	r0
     590:	0b b6       	in	r0, 0x3b	; 59
     592:	0f 92       	push	r0
     594:	0c b6       	in	r0, 0x3c	; 60
     596:	0f 92       	push	r0
     598:	1f 92       	push	r1
     59a:	11 24       	eor	r1, r1
     59c:	2f 92       	push	r2
     59e:	3f 92       	push	r3
     5a0:	4f 92       	push	r4
     5a2:	5f 92       	push	r5
     5a4:	6f 92       	push	r6
     5a6:	7f 92       	push	r7
     5a8:	8f 92       	push	r8
     5aa:	9f 92       	push	r9
     5ac:	af 92       	push	r10
     5ae:	bf 92       	push	r11
     5b0:	cf 92       	push	r12
     5b2:	df 92       	push	r13
     5b4:	ef 92       	push	r14
     5b6:	ff 92       	push	r15
     5b8:	0f 93       	push	r16
     5ba:	1f 93       	push	r17
     5bc:	2f 93       	push	r18
     5be:	3f 93       	push	r19
     5c0:	4f 93       	push	r20
     5c2:	5f 93       	push	r21
     5c4:	6f 93       	push	r22
     5c6:	7f 93       	push	r23
     5c8:	8f 93       	push	r24
     5ca:	9f 93       	push	r25
     5cc:	af 93       	push	r26
     5ce:	bf 93       	push	r27
     5d0:	cf 93       	push	r28
     5d2:	df 93       	push	r29
     5d4:	ef 93       	push	r30
     5d6:	ff 93       	push	r31
     5d8:	a0 91 3a 08 	lds	r26, 0x083A	; 0x80083a <pxCurrentTCB>
     5dc:	b0 91 3b 08 	lds	r27, 0x083B	; 0x80083b <pxCurrentTCB+0x1>
     5e0:	0d b6       	in	r0, 0x3d	; 61
     5e2:	0d 92       	st	X+, r0
     5e4:	0e b6       	in	r0, 0x3e	; 62
     5e6:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     5e8:	a5 d5       	rcall	.+2890   	; 0x1134 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     5ea:	a0 91 3a 08 	lds	r26, 0x083A	; 0x80083a <pxCurrentTCB>
     5ee:	b0 91 3b 08 	lds	r27, 0x083B	; 0x80083b <pxCurrentTCB+0x1>
     5f2:	cd 91       	ld	r28, X+
     5f4:	cd bf       	out	0x3d, r28	; 61
     5f6:	dd 91       	ld	r29, X+
     5f8:	de bf       	out	0x3e, r29	; 62
     5fa:	ff 91       	pop	r31
     5fc:	ef 91       	pop	r30
     5fe:	df 91       	pop	r29
     600:	cf 91       	pop	r28
     602:	bf 91       	pop	r27
     604:	af 91       	pop	r26
     606:	9f 91       	pop	r25
     608:	8f 91       	pop	r24
     60a:	7f 91       	pop	r23
     60c:	6f 91       	pop	r22
     60e:	5f 91       	pop	r21
     610:	4f 91       	pop	r20
     612:	3f 91       	pop	r19
     614:	2f 91       	pop	r18
     616:	1f 91       	pop	r17
     618:	0f 91       	pop	r16
     61a:	ff 90       	pop	r15
     61c:	ef 90       	pop	r14
     61e:	df 90       	pop	r13
     620:	cf 90       	pop	r12
     622:	bf 90       	pop	r11
     624:	af 90       	pop	r10
     626:	9f 90       	pop	r9
     628:	8f 90       	pop	r8
     62a:	7f 90       	pop	r7
     62c:	6f 90       	pop	r6
     62e:	5f 90       	pop	r5
     630:	4f 90       	pop	r4
     632:	3f 90       	pop	r3
     634:	2f 90       	pop	r2
     636:	1f 90       	pop	r1
     638:	0f 90       	pop	r0
     63a:	0c be       	out	0x3c, r0	; 60
     63c:	0f 90       	pop	r0
     63e:	0b be       	out	0x3b, r0	; 59
     640:	0f 90       	pop	r0
     642:	0f be       	out	0x3f, r0	; 63
     644:	0f 90       	pop	r0

	asm volatile ( "ret" );
     646:	08 95       	ret

00000648 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     648:	0f 92       	push	r0
     64a:	0f b6       	in	r0, 0x3f	; 63
     64c:	f8 94       	cli
     64e:	0f 92       	push	r0
     650:	0b b6       	in	r0, 0x3b	; 59
     652:	0f 92       	push	r0
     654:	0c b6       	in	r0, 0x3c	; 60
     656:	0f 92       	push	r0
     658:	1f 92       	push	r1
     65a:	11 24       	eor	r1, r1
     65c:	2f 92       	push	r2
     65e:	3f 92       	push	r3
     660:	4f 92       	push	r4
     662:	5f 92       	push	r5
     664:	6f 92       	push	r6
     666:	7f 92       	push	r7
     668:	8f 92       	push	r8
     66a:	9f 92       	push	r9
     66c:	af 92       	push	r10
     66e:	bf 92       	push	r11
     670:	cf 92       	push	r12
     672:	df 92       	push	r13
     674:	ef 92       	push	r14
     676:	ff 92       	push	r15
     678:	0f 93       	push	r16
     67a:	1f 93       	push	r17
     67c:	2f 93       	push	r18
     67e:	3f 93       	push	r19
     680:	4f 93       	push	r20
     682:	5f 93       	push	r21
     684:	6f 93       	push	r22
     686:	7f 93       	push	r23
     688:	8f 93       	push	r24
     68a:	9f 93       	push	r25
     68c:	af 93       	push	r26
     68e:	bf 93       	push	r27
     690:	cf 93       	push	r28
     692:	df 93       	push	r29
     694:	ef 93       	push	r30
     696:	ff 93       	push	r31
     698:	a0 91 3a 08 	lds	r26, 0x083A	; 0x80083a <pxCurrentTCB>
     69c:	b0 91 3b 08 	lds	r27, 0x083B	; 0x80083b <pxCurrentTCB+0x1>
     6a0:	0d b6       	in	r0, 0x3d	; 61
     6a2:	0d 92       	st	X+, r0
     6a4:	0e b6       	in	r0, 0x3e	; 62
     6a6:	0d 92       	st	X+, r0
	vTaskIncrementTick();
     6a8:	be d3       	rcall	.+1916   	; 0xe26 <vTaskIncrementTick>
	vTaskSwitchContext();
     6aa:	44 d5       	rcall	.+2696   	; 0x1134 <vTaskSwitchContext>
     6ac:	a0 91 3a 08 	lds	r26, 0x083A	; 0x80083a <pxCurrentTCB>
	portRESTORE_CONTEXT();
     6b0:	b0 91 3b 08 	lds	r27, 0x083B	; 0x80083b <pxCurrentTCB+0x1>
     6b4:	cd 91       	ld	r28, X+
     6b6:	cd bf       	out	0x3d, r28	; 61
     6b8:	dd 91       	ld	r29, X+
     6ba:	de bf       	out	0x3e, r29	; 62
     6bc:	ff 91       	pop	r31
     6be:	ef 91       	pop	r30
     6c0:	df 91       	pop	r29
     6c2:	cf 91       	pop	r28
     6c4:	bf 91       	pop	r27
     6c6:	af 91       	pop	r26
     6c8:	9f 91       	pop	r25
     6ca:	8f 91       	pop	r24
     6cc:	7f 91       	pop	r23
     6ce:	6f 91       	pop	r22
     6d0:	5f 91       	pop	r21
     6d2:	4f 91       	pop	r20
     6d4:	3f 91       	pop	r19
     6d6:	2f 91       	pop	r18
     6d8:	1f 91       	pop	r17
     6da:	0f 91       	pop	r16
     6dc:	ff 90       	pop	r15
     6de:	ef 90       	pop	r14
     6e0:	df 90       	pop	r13
     6e2:	cf 90       	pop	r12
     6e4:	bf 90       	pop	r11
     6e6:	af 90       	pop	r10
     6e8:	9f 90       	pop	r9
     6ea:	8f 90       	pop	r8
     6ec:	7f 90       	pop	r7
     6ee:	6f 90       	pop	r6
     6f0:	5f 90       	pop	r5
     6f2:	4f 90       	pop	r4
     6f4:	3f 90       	pop	r3
     6f6:	2f 90       	pop	r2
     6f8:	1f 90       	pop	r1
     6fa:	0f 90       	pop	r0
     6fc:	0c be       	out	0x3c, r0	; 60
     6fe:	0f 90       	pop	r0
     700:	0b be       	out	0x3b, r0	; 59
     702:	0f 90       	pop	r0
     704:	0f be       	out	0x3f, r0	; 63
     706:	0f 90       	pop	r0
     708:	08 95       	ret

0000070a <__vector_47>:
	asm volatile ( "ret" );
     70a:	9e df       	rcall	.-196    	; 0x648 <vPortYieldFromTick>
//	void SIG_OUTPUT_COMPARE1A( void )
	void TIMER5_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER5_COMPA_vect( void )
	{
		vPortYieldFromTick();
		asm volatile ( "reti" );
     70c:	18 95       	reti

0000070e <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     70e:	cf 93       	push	r28
     710:	df 93       	push	r29
     712:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     714:	78 d3       	rcall	.+1776   	; 0xe06 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     716:	20 91 29 02 	lds	r18, 0x0229	; 0x800229 <xNextFreeByte>
     71a:	30 91 2a 02 	lds	r19, 0x022A	; 0x80022a <xNextFreeByte+0x1>
     71e:	c9 01       	movw	r24, r18
     720:	8c 0f       	add	r24, r28
     722:	9d 1f       	adc	r25, r29
     724:	8c 3d       	cpi	r24, 0xDC	; 220
     726:	45 e0       	ldi	r20, 0x05	; 5
     728:	94 07       	cpc	r25, r20
     72a:	58 f4       	brcc	.+22     	; 0x742 <pvPortMalloc+0x34>
     72c:	28 17       	cp	r18, r24
     72e:	39 07       	cpc	r19, r25
     730:	58 f4       	brcc	.+22     	; 0x748 <pvPortMalloc+0x3a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     732:	e9 01       	movw	r28, r18
     734:	c5 5d       	subi	r28, 0xD5	; 213
     736:	dd 4f       	sbci	r29, 0xFD	; 253
			xNextFreeByte += xWantedSize;			
     738:	90 93 2a 02 	sts	0x022A, r25	; 0x80022a <xNextFreeByte+0x1>
     73c:	80 93 29 02 	sts	0x0229, r24	; 0x800229 <xNextFreeByte>
     740:	05 c0       	rjmp	.+10     	; 0x74c <pvPortMalloc+0x3e>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
     742:	c0 e0       	ldi	r28, 0x00	; 0
     744:	d0 e0       	ldi	r29, 0x00	; 0
     746:	02 c0       	rjmp	.+4      	; 0x74c <pvPortMalloc+0x3e>
     748:	c0 e0       	ldi	r28, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
     74a:	d0 e0       	ldi	r29, 0x00	; 0
     74c:	2d d4       	rcall	.+2138   	; 0xfa8 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
     74e:	ce 01       	movw	r24, r28
     750:	df 91       	pop	r29
     752:	cf 91       	pop	r28
     754:	08 95       	ret

00000756 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     756:	08 95       	ret

00000758 <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     758:	cf 93       	push	r28
     75a:	df 93       	push	r29
     75c:	ec 01       	movw	r28, r24
     75e:	8c 8d       	ldd	r24, Y+28	; 0x1c
     760:	88 23       	and	r24, r24
     762:	99 f1       	breq	.+102    	; 0x7ca <prvCopyDataToQueue+0x72>
     764:	41 11       	cpse	r20, r1
     766:	16 c0       	rjmp	.+44     	; 0x794 <prvCopyDataToQueue+0x3c>
     768:	48 2f       	mov	r20, r24
     76a:	50 e0       	ldi	r21, 0x00	; 0
     76c:	8c 81       	ldd	r24, Y+4	; 0x04
     76e:	9d 81       	ldd	r25, Y+5	; 0x05
     770:	0f d6       	rcall	.+3102   	; 0x1390 <memcpy>
     772:	2c 8d       	ldd	r18, Y+28	; 0x1c
     774:	8c 81       	ldd	r24, Y+4	; 0x04
     776:	9d 81       	ldd	r25, Y+5	; 0x05
     778:	82 0f       	add	r24, r18
     77a:	91 1d       	adc	r25, r1
     77c:	9d 83       	std	Y+5, r25	; 0x05
     77e:	8c 83       	std	Y+4, r24	; 0x04
     780:	2a 81       	ldd	r18, Y+2	; 0x02
     782:	3b 81       	ldd	r19, Y+3	; 0x03
     784:	82 17       	cp	r24, r18
     786:	93 07       	cpc	r25, r19
     788:	00 f1       	brcs	.+64     	; 0x7ca <prvCopyDataToQueue+0x72>
     78a:	88 81       	ld	r24, Y
     78c:	99 81       	ldd	r25, Y+1	; 0x01
     78e:	9d 83       	std	Y+5, r25	; 0x05
     790:	8c 83       	std	Y+4, r24	; 0x04
     792:	1b c0       	rjmp	.+54     	; 0x7ca <prvCopyDataToQueue+0x72>
     794:	48 2f       	mov	r20, r24
     796:	50 e0       	ldi	r21, 0x00	; 0
     798:	8e 81       	ldd	r24, Y+6	; 0x06
     79a:	9f 81       	ldd	r25, Y+7	; 0x07
     79c:	f9 d5       	rcall	.+3058   	; 0x1390 <memcpy>
     79e:	8c 8d       	ldd	r24, Y+28	; 0x1c
     7a0:	90 e0       	ldi	r25, 0x00	; 0
     7a2:	91 95       	neg	r25
     7a4:	81 95       	neg	r24
     7a6:	91 09       	sbc	r25, r1
     7a8:	2e 81       	ldd	r18, Y+6	; 0x06
     7aa:	3f 81       	ldd	r19, Y+7	; 0x07
     7ac:	28 0f       	add	r18, r24
     7ae:	39 1f       	adc	r19, r25
     7b0:	3f 83       	std	Y+7, r19	; 0x07
     7b2:	2e 83       	std	Y+6, r18	; 0x06
     7b4:	48 81       	ld	r20, Y
     7b6:	59 81       	ldd	r21, Y+1	; 0x01
     7b8:	24 17       	cp	r18, r20
     7ba:	35 07       	cpc	r19, r21
     7bc:	30 f4       	brcc	.+12     	; 0x7ca <prvCopyDataToQueue+0x72>
     7be:	2a 81       	ldd	r18, Y+2	; 0x02
     7c0:	3b 81       	ldd	r19, Y+3	; 0x03
     7c2:	82 0f       	add	r24, r18
     7c4:	93 1f       	adc	r25, r19
     7c6:	9f 83       	std	Y+7, r25	; 0x07
     7c8:	8e 83       	std	Y+6, r24	; 0x06
     7ca:	8a 8d       	ldd	r24, Y+26	; 0x1a
     7cc:	8f 5f       	subi	r24, 0xFF	; 255
     7ce:	8a 8f       	std	Y+26, r24	; 0x1a
     7d0:	df 91       	pop	r29
     7d2:	cf 91       	pop	r28
     7d4:	08 95       	ret

000007d6 <prvCopyDataFromQueue>:
     7d6:	fc 01       	movw	r30, r24
     7d8:	80 81       	ld	r24, Z
     7da:	91 81       	ldd	r25, Z+1	; 0x01
     7dc:	00 97       	sbiw	r24, 0x00	; 0
     7de:	99 f0       	breq	.+38     	; 0x806 <prvCopyDataFromQueue+0x30>
     7e0:	44 8d       	ldd	r20, Z+28	; 0x1c
     7e2:	50 e0       	ldi	r21, 0x00	; 0
     7e4:	26 81       	ldd	r18, Z+6	; 0x06
     7e6:	37 81       	ldd	r19, Z+7	; 0x07
     7e8:	24 0f       	add	r18, r20
     7ea:	35 1f       	adc	r19, r21
     7ec:	37 83       	std	Z+7, r19	; 0x07
     7ee:	26 83       	std	Z+6, r18	; 0x06
     7f0:	a2 81       	ldd	r26, Z+2	; 0x02
     7f2:	b3 81       	ldd	r27, Z+3	; 0x03
     7f4:	2a 17       	cp	r18, r26
     7f6:	3b 07       	cpc	r19, r27
     7f8:	10 f0       	brcs	.+4      	; 0x7fe <prvCopyDataFromQueue+0x28>
     7fa:	97 83       	std	Z+7, r25	; 0x07
     7fc:	86 83       	std	Z+6, r24	; 0x06
     7fe:	cb 01       	movw	r24, r22
     800:	66 81       	ldd	r22, Z+6	; 0x06
     802:	77 81       	ldd	r23, Z+7	; 0x07
     804:	c5 c5       	rjmp	.+2954   	; 0x1390 <memcpy>
     806:	08 95       	ret

00000808 <prvUnlockQueue>:
     808:	0f 93       	push	r16
     80a:	1f 93       	push	r17
     80c:	cf 93       	push	r28
     80e:	df 93       	push	r29
     810:	ec 01       	movw	r28, r24
     812:	0f b6       	in	r0, 0x3f	; 63
     814:	f8 94       	cli
     816:	0f 92       	push	r0
     818:	8e 8d       	ldd	r24, Y+30	; 0x1e
     81a:	18 16       	cp	r1, r24
     81c:	a4 f4       	brge	.+40     	; 0x846 <prvUnlockQueue+0x3e>
     81e:	89 89       	ldd	r24, Y+17	; 0x11
     820:	81 11       	cpse	r24, r1
     822:	05 c0       	rjmp	.+10     	; 0x82e <prvUnlockQueue+0x26>
     824:	10 c0       	rjmp	.+32     	; 0x846 <prvUnlockQueue+0x3e>
     826:	89 89       	ldd	r24, Y+17	; 0x11
     828:	81 11       	cpse	r24, r1
     82a:	04 c0       	rjmp	.+8      	; 0x834 <prvUnlockQueue+0x2c>
     82c:	0c c0       	rjmp	.+24     	; 0x846 <prvUnlockQueue+0x3e>
     82e:	8e 01       	movw	r16, r28
     830:	0f 5e       	subi	r16, 0xEF	; 239
     832:	1f 4f       	sbci	r17, 0xFF	; 255
     834:	c8 01       	movw	r24, r16
     836:	04 d5       	rcall	.+2568   	; 0x1240 <xTaskRemoveFromEventList>
     838:	81 11       	cpse	r24, r1
     83a:	84 d5       	rcall	.+2824   	; 0x1344 <vTaskMissedYield>
     83c:	8e 8d       	ldd	r24, Y+30	; 0x1e
     83e:	81 50       	subi	r24, 0x01	; 1
     840:	8e 8f       	std	Y+30, r24	; 0x1e
     842:	18 16       	cp	r1, r24
     844:	84 f3       	brlt	.-32     	; 0x826 <prvUnlockQueue+0x1e>
     846:	8f ef       	ldi	r24, 0xFF	; 255
     848:	8e 8f       	std	Y+30, r24	; 0x1e
     84a:	0f 90       	pop	r0
     84c:	0f be       	out	0x3f, r0	; 63
     84e:	0f b6       	in	r0, 0x3f	; 63
     850:	f8 94       	cli
     852:	0f 92       	push	r0
     854:	8d 8d       	ldd	r24, Y+29	; 0x1d
     856:	18 16       	cp	r1, r24
     858:	a4 f4       	brge	.+40     	; 0x882 <prvUnlockQueue+0x7a>
     85a:	88 85       	ldd	r24, Y+8	; 0x08
     85c:	81 11       	cpse	r24, r1
     85e:	05 c0       	rjmp	.+10     	; 0x86a <prvUnlockQueue+0x62>
     860:	10 c0       	rjmp	.+32     	; 0x882 <prvUnlockQueue+0x7a>
     862:	88 85       	ldd	r24, Y+8	; 0x08
     864:	81 11       	cpse	r24, r1
     866:	04 c0       	rjmp	.+8      	; 0x870 <prvUnlockQueue+0x68>
     868:	0c c0       	rjmp	.+24     	; 0x882 <prvUnlockQueue+0x7a>
     86a:	8e 01       	movw	r16, r28
     86c:	08 5f       	subi	r16, 0xF8	; 248
     86e:	1f 4f       	sbci	r17, 0xFF	; 255
     870:	c8 01       	movw	r24, r16
     872:	e6 d4       	rcall	.+2508   	; 0x1240 <xTaskRemoveFromEventList>
     874:	81 11       	cpse	r24, r1
     876:	66 d5       	rcall	.+2764   	; 0x1344 <vTaskMissedYield>
     878:	8d 8d       	ldd	r24, Y+29	; 0x1d
     87a:	81 50       	subi	r24, 0x01	; 1
     87c:	8d 8f       	std	Y+29, r24	; 0x1d
     87e:	18 16       	cp	r1, r24
     880:	84 f3       	brlt	.-32     	; 0x862 <prvUnlockQueue+0x5a>
     882:	8f ef       	ldi	r24, 0xFF	; 255
     884:	8d 8f       	std	Y+29, r24	; 0x1d
     886:	0f 90       	pop	r0
     888:	0f be       	out	0x3f, r0	; 63
     88a:	df 91       	pop	r29
     88c:	cf 91       	pop	r28
     88e:	1f 91       	pop	r17
     890:	0f 91       	pop	r16
     892:	08 95       	ret

00000894 <xQueueGenericCreate>:
     894:	cf 92       	push	r12
     896:	df 92       	push	r13
     898:	ef 92       	push	r14
     89a:	ff 92       	push	r15
     89c:	0f 93       	push	r16
     89e:	1f 93       	push	r17
     8a0:	cf 93       	push	r28
     8a2:	df 93       	push	r29
     8a4:	88 23       	and	r24, r24
     8a6:	a9 f1       	breq	.+106    	; 0x912 <xQueueGenericCreate+0x7e>
     8a8:	e6 2e       	mov	r14, r22
     8aa:	f8 2e       	mov	r15, r24
     8ac:	8f e1       	ldi	r24, 0x1F	; 31
     8ae:	90 e0       	ldi	r25, 0x00	; 0
     8b0:	2e df       	rcall	.-420    	; 0x70e <pvPortMalloc>
     8b2:	ec 01       	movw	r28, r24
     8b4:	89 2b       	or	r24, r25
     8b6:	79 f1       	breq	.+94     	; 0x916 <xQueueGenericCreate+0x82>
     8b8:	ce 2c       	mov	r12, r14
     8ba:	d1 2c       	mov	r13, r1
     8bc:	fc 9c       	mul	r15, r12
     8be:	80 01       	movw	r16, r0
     8c0:	fd 9c       	mul	r15, r13
     8c2:	10 0d       	add	r17, r0
     8c4:	11 24       	eor	r1, r1
     8c6:	c8 01       	movw	r24, r16
     8c8:	01 96       	adiw	r24, 0x01	; 1
     8ca:	21 df       	rcall	.-446    	; 0x70e <pvPortMalloc>
     8cc:	99 83       	std	Y+1, r25	; 0x01
     8ce:	88 83       	st	Y, r24
     8d0:	00 97       	sbiw	r24, 0x00	; 0
     8d2:	d1 f0       	breq	.+52     	; 0x908 <xQueueGenericCreate+0x74>
     8d4:	9c 01       	movw	r18, r24
     8d6:	20 0f       	add	r18, r16
     8d8:	31 1f       	adc	r19, r17
     8da:	3b 83       	std	Y+3, r19	; 0x03
     8dc:	2a 83       	std	Y+2, r18	; 0x02
     8de:	1a 8e       	std	Y+26, r1	; 0x1a
     8e0:	9d 83       	std	Y+5, r25	; 0x05
     8e2:	8c 83       	std	Y+4, r24	; 0x04
     8e4:	0c 19       	sub	r16, r12
     8e6:	1d 09       	sbc	r17, r13
     8e8:	08 0f       	add	r16, r24
     8ea:	19 1f       	adc	r17, r25
     8ec:	1f 83       	std	Y+7, r17	; 0x07
     8ee:	0e 83       	std	Y+6, r16	; 0x06
     8f0:	fb 8e       	std	Y+27, r15	; 0x1b
     8f2:	ec 8e       	std	Y+28, r14	; 0x1c
     8f4:	8f ef       	ldi	r24, 0xFF	; 255
     8f6:	8d 8f       	std	Y+29, r24	; 0x1d
     8f8:	8e 8f       	std	Y+30, r24	; 0x1e
     8fa:	ce 01       	movw	r24, r28
     8fc:	08 96       	adiw	r24, 0x08	; 8
     8fe:	fa dc       	rcall	.-1548   	; 0x2f4 <vListInitialise>
     900:	ce 01       	movw	r24, r28
     902:	41 96       	adiw	r24, 0x11	; 17
     904:	f7 dc       	rcall	.-1554   	; 0x2f4 <vListInitialise>
     906:	07 c0       	rjmp	.+14     	; 0x916 <xQueueGenericCreate+0x82>
     908:	ce 01       	movw	r24, r28
     90a:	25 df       	rcall	.-438    	; 0x756 <vPortFree>
     90c:	c0 e0       	ldi	r28, 0x00	; 0
     90e:	d0 e0       	ldi	r29, 0x00	; 0
     910:	02 c0       	rjmp	.+4      	; 0x916 <xQueueGenericCreate+0x82>
     912:	c0 e0       	ldi	r28, 0x00	; 0
     914:	d0 e0       	ldi	r29, 0x00	; 0
     916:	ce 01       	movw	r24, r28
     918:	df 91       	pop	r29
     91a:	cf 91       	pop	r28
     91c:	1f 91       	pop	r17
     91e:	0f 91       	pop	r16
     920:	ff 90       	pop	r15
     922:	ef 90       	pop	r14
     924:	df 90       	pop	r13
     926:	cf 90       	pop	r12
     928:	08 95       	ret

0000092a <xQueueGenericSend>:
     92a:	9f 92       	push	r9
     92c:	af 92       	push	r10
     92e:	bf 92       	push	r11
     930:	cf 92       	push	r12
     932:	df 92       	push	r13
     934:	ef 92       	push	r14
     936:	ff 92       	push	r15
     938:	0f 93       	push	r16
     93a:	1f 93       	push	r17
     93c:	cf 93       	push	r28
     93e:	df 93       	push	r29
     940:	00 d0       	rcall	.+0      	; 0x942 <xQueueGenericSend+0x18>
     942:	1f 92       	push	r1
     944:	1f 92       	push	r1
     946:	cd b7       	in	r28, 0x3d	; 61
     948:	de b7       	in	r29, 0x3e	; 62
     94a:	8c 01       	movw	r16, r24
     94c:	6b 01       	movw	r12, r22
     94e:	5d 83       	std	Y+5, r21	; 0x05
     950:	4c 83       	std	Y+4, r20	; 0x04
     952:	92 2e       	mov	r9, r18
     954:	b1 2c       	mov	r11, r1
     956:	aa 24       	eor	r10, r10
     958:	a3 94       	inc	r10
     95a:	7c 01       	movw	r14, r24
     95c:	88 e0       	ldi	r24, 0x08	; 8
     95e:	e8 0e       	add	r14, r24
     960:	f1 1c       	adc	r15, r1
     962:	0f b6       	in	r0, 0x3f	; 63
     964:	f8 94       	cli
     966:	0f 92       	push	r0
     968:	f8 01       	movw	r30, r16
     96a:	92 8d       	ldd	r25, Z+26	; 0x1a
     96c:	83 8d       	ldd	r24, Z+27	; 0x1b
     96e:	98 17       	cp	r25, r24
     970:	90 f4       	brcc	.+36     	; 0x996 <xQueueGenericSend+0x6c>
     972:	49 2d       	mov	r20, r9
     974:	b6 01       	movw	r22, r12
     976:	c8 01       	movw	r24, r16
     978:	ef de       	rcall	.-546    	; 0x758 <prvCopyDataToQueue>
     97a:	f8 01       	movw	r30, r16
     97c:	81 89       	ldd	r24, Z+17	; 0x11
     97e:	88 23       	and	r24, r24
     980:	31 f0       	breq	.+12     	; 0x98e <xQueueGenericSend+0x64>
     982:	c8 01       	movw	r24, r16
     984:	41 96       	adiw	r24, 0x11	; 17
     986:	5c d4       	rcall	.+2232   	; 0x1240 <xTaskRemoveFromEventList>
     988:	81 30       	cpi	r24, 0x01	; 1
     98a:	09 f4       	brne	.+2      	; 0x98e <xQueueGenericSend+0x64>
     98c:	fd dd       	rcall	.-1030   	; 0x588 <vPortYield>
     98e:	0f 90       	pop	r0
     990:	0f be       	out	0x3f, r0	; 63
     992:	81 e0       	ldi	r24, 0x01	; 1
     994:	45 c0       	rjmp	.+138    	; 0xa20 <xQueueGenericSend+0xf6>
     996:	8c 81       	ldd	r24, Y+4	; 0x04
     998:	9d 81       	ldd	r25, Y+5	; 0x05
     99a:	89 2b       	or	r24, r25
     99c:	21 f4       	brne	.+8      	; 0x9a6 <xQueueGenericSend+0x7c>
     99e:	0f 90       	pop	r0
     9a0:	0f be       	out	0x3f, r0	; 63
     9a2:	80 e0       	ldi	r24, 0x00	; 0
     9a4:	3d c0       	rjmp	.+122    	; 0xa20 <xQueueGenericSend+0xf6>
     9a6:	b1 10       	cpse	r11, r1
     9a8:	04 c0       	rjmp	.+8      	; 0x9b2 <xQueueGenericSend+0x88>
     9aa:	ce 01       	movw	r24, r28
     9ac:	01 96       	adiw	r24, 0x01	; 1
     9ae:	89 d4       	rcall	.+2322   	; 0x12c2 <vTaskSetTimeOutState>
     9b0:	ba 2c       	mov	r11, r10
     9b2:	0f 90       	pop	r0
     9b4:	0f be       	out	0x3f, r0	; 63
     9b6:	27 d2       	rcall	.+1102   	; 0xe06 <vTaskSuspendAll>
     9b8:	0f b6       	in	r0, 0x3f	; 63
     9ba:	f8 94       	cli
     9bc:	0f 92       	push	r0
     9be:	f8 01       	movw	r30, r16
     9c0:	85 8d       	ldd	r24, Z+29	; 0x1d
     9c2:	8f 3f       	cpi	r24, 0xFF	; 255
     9c4:	09 f4       	brne	.+2      	; 0x9c8 <xQueueGenericSend+0x9e>
     9c6:	15 8e       	std	Z+29, r1	; 0x1d
     9c8:	f8 01       	movw	r30, r16
     9ca:	86 8d       	ldd	r24, Z+30	; 0x1e
     9cc:	8f 3f       	cpi	r24, 0xFF	; 255
     9ce:	09 f4       	brne	.+2      	; 0x9d2 <xQueueGenericSend+0xa8>
     9d0:	16 8e       	std	Z+30, r1	; 0x1e
     9d2:	0f 90       	pop	r0
     9d4:	0f be       	out	0x3f, r0	; 63
     9d6:	be 01       	movw	r22, r28
     9d8:	6c 5f       	subi	r22, 0xFC	; 252
     9da:	7f 4f       	sbci	r23, 0xFF	; 255
     9dc:	ce 01       	movw	r24, r28
     9de:	01 96       	adiw	r24, 0x01	; 1
     9e0:	7b d4       	rcall	.+2294   	; 0x12d8 <xTaskCheckForTimeOut>
     9e2:	81 11       	cpse	r24, r1
     9e4:	19 c0       	rjmp	.+50     	; 0xa18 <xQueueGenericSend+0xee>
     9e6:	0f b6       	in	r0, 0x3f	; 63
     9e8:	f8 94       	cli
     9ea:	0f 92       	push	r0
     9ec:	f8 01       	movw	r30, r16
     9ee:	92 8d       	ldd	r25, Z+26	; 0x1a
     9f0:	0f 90       	pop	r0
     9f2:	0f be       	out	0x3f, r0	; 63
     9f4:	83 8d       	ldd	r24, Z+27	; 0x1b
     9f6:	98 13       	cpse	r25, r24
     9f8:	0b c0       	rjmp	.+22     	; 0xa10 <xQueueGenericSend+0xe6>
     9fa:	6c 81       	ldd	r22, Y+4	; 0x04
     9fc:	7d 81       	ldd	r23, Y+5	; 0x05
     9fe:	c7 01       	movw	r24, r14
     a00:	05 d4       	rcall	.+2058   	; 0x120c <vTaskPlaceOnEventList>
     a02:	c8 01       	movw	r24, r16
     a04:	01 df       	rcall	.-510    	; 0x808 <prvUnlockQueue>
     a06:	d0 d2       	rcall	.+1440   	; 0xfa8 <xTaskResumeAll>
     a08:	81 11       	cpse	r24, r1
     a0a:	ab cf       	rjmp	.-170    	; 0x962 <xQueueGenericSend+0x38>
     a0c:	bd dd       	rcall	.-1158   	; 0x588 <vPortYield>
     a0e:	a9 cf       	rjmp	.-174    	; 0x962 <xQueueGenericSend+0x38>
     a10:	c8 01       	movw	r24, r16
     a12:	fa de       	rcall	.-524    	; 0x808 <prvUnlockQueue>
     a14:	c9 d2       	rcall	.+1426   	; 0xfa8 <xTaskResumeAll>
     a16:	a5 cf       	rjmp	.-182    	; 0x962 <xQueueGenericSend+0x38>
     a18:	c8 01       	movw	r24, r16
     a1a:	f6 de       	rcall	.-532    	; 0x808 <prvUnlockQueue>
     a1c:	c5 d2       	rcall	.+1418   	; 0xfa8 <xTaskResumeAll>
     a1e:	80 e0       	ldi	r24, 0x00	; 0
     a20:	0f 90       	pop	r0
     a22:	0f 90       	pop	r0
     a24:	0f 90       	pop	r0
     a26:	0f 90       	pop	r0
     a28:	0f 90       	pop	r0
     a2a:	df 91       	pop	r29
     a2c:	cf 91       	pop	r28
     a2e:	1f 91       	pop	r17
     a30:	0f 91       	pop	r16
     a32:	ff 90       	pop	r15
     a34:	ef 90       	pop	r14
     a36:	df 90       	pop	r13
     a38:	cf 90       	pop	r12
     a3a:	bf 90       	pop	r11
     a3c:	af 90       	pop	r10
     a3e:	9f 90       	pop	r9
     a40:	08 95       	ret

00000a42 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
     a42:	9f 92       	push	r9
     a44:	af 92       	push	r10
     a46:	bf 92       	push	r11
     a48:	cf 92       	push	r12
     a4a:	df 92       	push	r13
     a4c:	ef 92       	push	r14
     a4e:	ff 92       	push	r15
     a50:	0f 93       	push	r16
     a52:	1f 93       	push	r17
     a54:	cf 93       	push	r28
     a56:	df 93       	push	r29
     a58:	00 d0       	rcall	.+0      	; 0xa5a <xQueueGenericReceive+0x18>
     a5a:	1f 92       	push	r1
     a5c:	1f 92       	push	r1
     a5e:	cd b7       	in	r28, 0x3d	; 61
     a60:	de b7       	in	r29, 0x3e	; 62
     a62:	8c 01       	movw	r16, r24
     a64:	6b 01       	movw	r12, r22
     a66:	5d 83       	std	Y+5, r21	; 0x05
     a68:	4c 83       	std	Y+4, r20	; 0x04
     a6a:	92 2e       	mov	r9, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
     a6c:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     a6e:	aa 24       	eor	r10, r10
     a70:	a3 94       	inc	r10
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     a72:	7c 01       	movw	r14, r24
     a74:	81 e1       	ldi	r24, 0x11	; 17
     a76:	e8 0e       	add	r14, r24
     a78:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     a7a:	0f b6       	in	r0, 0x3f	; 63
     a7c:	f8 94       	cli
     a7e:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
     a80:	f8 01       	movw	r30, r16
     a82:	82 8d       	ldd	r24, Z+26	; 0x1a
     a84:	88 23       	and	r24, r24
     a86:	21 f1       	breq	.+72     	; 0xad0 <xQueueGenericReceive+0x8e>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
     a88:	e6 80       	ldd	r14, Z+6	; 0x06
     a8a:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     a8c:	b6 01       	movw	r22, r12
     a8e:	c8 01       	movw	r24, r16
     a90:	a2 de       	rcall	.-700    	; 0x7d6 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     a92:	91 10       	cpse	r9, r1
     a94:	0e c0       	rjmp	.+28     	; 0xab2 <xQueueGenericReceive+0x70>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
     a96:	f8 01       	movw	r30, r16
     a98:	82 8d       	ldd	r24, Z+26	; 0x1a
     a9a:	81 50       	subi	r24, 0x01	; 1
     a9c:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     a9e:	80 85       	ldd	r24, Z+8	; 0x08
     aa0:	88 23       	and	r24, r24
     aa2:	91 f0       	breq	.+36     	; 0xac8 <xQueueGenericReceive+0x86>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     aa4:	c8 01       	movw	r24, r16
     aa6:	08 96       	adiw	r24, 0x08	; 8
     aa8:	cb d3       	rcall	.+1942   	; 0x1240 <xTaskRemoveFromEventList>
     aaa:	81 30       	cpi	r24, 0x01	; 1
						{
							portYIELD_WITHIN_API();
     aac:	69 f4       	brne	.+26     	; 0xac8 <xQueueGenericReceive+0x86>
     aae:	6c dd       	rcall	.-1320   	; 0x588 <vPortYield>
     ab0:	0b c0       	rjmp	.+22     	; 0xac8 <xQueueGenericReceive+0x86>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
     ab2:	f8 01       	movw	r30, r16
     ab4:	f7 82       	std	Z+7, r15	; 0x07
     ab6:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     ab8:	81 89       	ldd	r24, Z+17	; 0x11
     aba:	88 23       	and	r24, r24
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     abc:	29 f0       	breq	.+10     	; 0xac8 <xQueueGenericReceive+0x86>
     abe:	c8 01       	movw	r24, r16
     ac0:	41 96       	adiw	r24, 0x11	; 17
     ac2:	be d3       	rcall	.+1916   	; 0x1240 <xTaskRemoveFromEventList>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
     ac4:	81 11       	cpse	r24, r1
     ac6:	60 dd       	rcall	.-1344   	; 0x588 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
     ac8:	0f 90       	pop	r0
     aca:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     acc:	81 e0       	ldi	r24, 0x01	; 1
     ace:	44 c0       	rjmp	.+136    	; 0xb58 <xQueueGenericReceive+0x116>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
     ad0:	8c 81       	ldd	r24, Y+4	; 0x04
     ad2:	9d 81       	ldd	r25, Y+5	; 0x05
     ad4:	89 2b       	or	r24, r25
     ad6:	21 f4       	brne	.+8      	; 0xae0 <xQueueGenericReceive+0x9e>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     ad8:	0f 90       	pop	r0
     ada:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     adc:	80 e0       	ldi	r24, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
     ade:	3c c0       	rjmp	.+120    	; 0xb58 <xQueueGenericReceive+0x116>
     ae0:	b1 10       	cpse	r11, r1
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     ae2:	04 c0       	rjmp	.+8      	; 0xaec <xQueueGenericReceive+0xaa>
     ae4:	ce 01       	movw	r24, r28
     ae6:	01 96       	adiw	r24, 0x01	; 1
					xEntryTimeSet = pdTRUE;
     ae8:	ec d3       	rcall	.+2008   	; 0x12c2 <vTaskSetTimeOutState>
				}
			}
		}
		taskEXIT_CRITICAL();
     aea:	ba 2c       	mov	r11, r10
     aec:	0f 90       	pop	r0

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     aee:	0f be       	out	0x3f, r0	; 63
     af0:	8a d1       	rcall	.+788    	; 0xe06 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     af2:	0f b6       	in	r0, 0x3f	; 63
     af4:	f8 94       	cli
     af6:	0f 92       	push	r0
     af8:	f8 01       	movw	r30, r16
     afa:	85 8d       	ldd	r24, Z+29	; 0x1d
     afc:	8f 3f       	cpi	r24, 0xFF	; 255
     afe:	09 f4       	brne	.+2      	; 0xb02 <xQueueGenericReceive+0xc0>
     b00:	15 8e       	std	Z+29, r1	; 0x1d
     b02:	f8 01       	movw	r30, r16
     b04:	86 8d       	ldd	r24, Z+30	; 0x1e
     b06:	8f 3f       	cpi	r24, 0xFF	; 255
     b08:	09 f4       	brne	.+2      	; 0xb0c <xQueueGenericReceive+0xca>
     b0a:	16 8e       	std	Z+30, r1	; 0x1e
     b0c:	0f 90       	pop	r0

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     b0e:	0f be       	out	0x3f, r0	; 63
     b10:	be 01       	movw	r22, r28
     b12:	6c 5f       	subi	r22, 0xFC	; 252
     b14:	7f 4f       	sbci	r23, 0xFF	; 255
     b16:	ce 01       	movw	r24, r28
     b18:	01 96       	adiw	r24, 0x01	; 1
     b1a:	de d3       	rcall	.+1980   	; 0x12d8 <xTaskCheckForTimeOut>
     b1c:	81 11       	cpse	r24, r1
     b1e:	18 c0       	rjmp	.+48     	; 0xb50 <xQueueGenericReceive+0x10e>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
     b20:	0f b6       	in	r0, 0x3f	; 63
     b22:	f8 94       	cli
     b24:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
     b26:	f8 01       	movw	r30, r16
	taskEXIT_CRITICAL();
     b28:	82 8d       	ldd	r24, Z+26	; 0x1a
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     b2a:	0f 90       	pop	r0
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     b2c:	0f be       	out	0x3f, r0	; 63
     b2e:	81 11       	cpse	r24, r1
     b30:	0b c0       	rjmp	.+22     	; 0xb48 <xQueueGenericReceive+0x106>
     b32:	6c 81       	ldd	r22, Y+4	; 0x04
				prvUnlockQueue( pxQueue );
     b34:	7d 81       	ldd	r23, Y+5	; 0x05
     b36:	c7 01       	movw	r24, r14
				if( xTaskResumeAll() == pdFALSE )
     b38:	69 d3       	rcall	.+1746   	; 0x120c <vTaskPlaceOnEventList>
     b3a:	c8 01       	movw	r24, r16
				{
					portYIELD_WITHIN_API();
     b3c:	65 de       	rcall	.-822    	; 0x808 <prvUnlockQueue>
     b3e:	34 d2       	rcall	.+1128   	; 0xfa8 <xTaskResumeAll>
     b40:	81 11       	cpse	r24, r1
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     b42:	9b cf       	rjmp	.-202    	; 0xa7a <xQueueGenericReceive+0x38>
     b44:	21 dd       	rcall	.-1470   	; 0x588 <vPortYield>
     b46:	99 cf       	rjmp	.-206    	; 0xa7a <xQueueGenericReceive+0x38>
				( void ) xTaskResumeAll();
     b48:	c8 01       	movw	r24, r16
     b4a:	5e de       	rcall	.-836    	; 0x808 <prvUnlockQueue>
     b4c:	2d d2       	rcall	.+1114   	; 0xfa8 <xTaskResumeAll>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     b4e:	95 cf       	rjmp	.-214    	; 0xa7a <xQueueGenericReceive+0x38>
     b50:	c8 01       	movw	r24, r16
     b52:	5a de       	rcall	.-844    	; 0x808 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     b54:	29 d2       	rcall	.+1106   	; 0xfa8 <xTaskResumeAll>
     b56:	80 e0       	ldi	r24, 0x00	; 0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
     b58:	0f 90       	pop	r0
		}
	}
}
     b5a:	0f 90       	pop	r0
     b5c:	0f 90       	pop	r0
     b5e:	0f 90       	pop	r0
     b60:	0f 90       	pop	r0
     b62:	df 91       	pop	r29
     b64:	cf 91       	pop	r28
     b66:	1f 91       	pop	r17
     b68:	0f 91       	pop	r16
     b6a:	ff 90       	pop	r15
     b6c:	ef 90       	pop	r14
     b6e:	df 90       	pop	r13
     b70:	cf 90       	pop	r12
     b72:	bf 90       	pop	r11
     b74:	af 90       	pop	r10
     b76:	9f 90       	pop	r9
     b78:	08 95       	ret

00000b7a <prvIdleTask>:
     b7a:	c1 e3       	ldi	r28, 0x31	; 49
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
     b7c:	d8 e0       	ldi	r29, 0x08	; 8
     b7e:	88 81       	ld	r24, Y
     b80:	82 30       	cpi	r24, 0x02	; 2
     b82:	e8 f3       	brcs	.-6      	; 0xb7e <prvIdleTask+0x4>
     b84:	01 dd       	rcall	.-1534   	; 0x588 <vPortYield>
     b86:	fb cf       	rjmp	.-10     	; 0xb7e <prvIdleTask+0x4>

00000b88 <prvAddCurrentTaskToDelayedList>:
     b88:	cf 93       	push	r28
     b8a:	df 93       	push	r29
     b8c:	ec 01       	movw	r28, r24
     b8e:	e0 91 3a 08 	lds	r30, 0x083A	; 0x80083a <pxCurrentTCB>
     b92:	f0 91 3b 08 	lds	r31, 0x083B	; 0x80083b <pxCurrentTCB+0x1>
     b96:	93 83       	std	Z+3, r25	; 0x03
     b98:	82 83       	std	Z+2, r24	; 0x02
     b9a:	80 91 0f 08 	lds	r24, 0x080F	; 0x80080f <xTickCount>
     b9e:	90 91 10 08 	lds	r25, 0x0810	; 0x800810 <xTickCount+0x1>
     ba2:	c8 17       	cp	r28, r24
     ba4:	d9 07       	cpc	r29, r25
     ba6:	60 f4       	brcc	.+24     	; 0xbc0 <prvAddCurrentTaskToDelayedList+0x38>
     ba8:	60 91 3a 08 	lds	r22, 0x083A	; 0x80083a <pxCurrentTCB>
     bac:	70 91 3b 08 	lds	r23, 0x083B	; 0x80083b <pxCurrentTCB+0x1>
     bb0:	80 91 1b 08 	lds	r24, 0x081B	; 0x80081b <pxOverflowDelayedTaskList>
     bb4:	90 91 1c 08 	lds	r25, 0x081C	; 0x80081c <pxOverflowDelayedTaskList+0x1>
     bb8:	6e 5f       	subi	r22, 0xFE	; 254
     bba:	7f 4f       	sbci	r23, 0xFF	; 255
     bbc:	d4 db       	rcall	.-2136   	; 0x366 <vListInsert>
     bbe:	16 c0       	rjmp	.+44     	; 0xbec <prvAddCurrentTaskToDelayedList+0x64>
     bc0:	60 91 3a 08 	lds	r22, 0x083A	; 0x80083a <pxCurrentTCB>
     bc4:	70 91 3b 08 	lds	r23, 0x083B	; 0x80083b <pxCurrentTCB+0x1>
     bc8:	80 91 1d 08 	lds	r24, 0x081D	; 0x80081d <pxDelayedTaskList>
     bcc:	90 91 1e 08 	lds	r25, 0x081E	; 0x80081e <pxDelayedTaskList+0x1>
     bd0:	6e 5f       	subi	r22, 0xFE	; 254
     bd2:	7f 4f       	sbci	r23, 0xFF	; 255
     bd4:	c8 db       	rcall	.-2160   	; 0x366 <vListInsert>
     bd6:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <__DATA_REGION_ORIGIN__>
     bda:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
     bde:	c8 17       	cp	r28, r24
     be0:	d9 07       	cpc	r29, r25
     be2:	20 f4       	brcc	.+8      	; 0xbec <prvAddCurrentTaskToDelayedList+0x64>
     be4:	d0 93 01 02 	sts	0x0201, r29	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
     be8:	c0 93 00 02 	sts	0x0200, r28	; 0x800200 <__DATA_REGION_ORIGIN__>
     bec:	df 91       	pop	r29
     bee:	cf 91       	pop	r28
     bf0:	08 95       	ret

00000bf2 <xTaskGenericCreate>:
     bf2:	4f 92       	push	r4
     bf4:	5f 92       	push	r5
     bf6:	6f 92       	push	r6
     bf8:	7f 92       	push	r7
     bfa:	8f 92       	push	r8
     bfc:	9f 92       	push	r9
     bfe:	af 92       	push	r10
     c00:	bf 92       	push	r11
     c02:	cf 92       	push	r12
     c04:	df 92       	push	r13
     c06:	ef 92       	push	r14
     c08:	ff 92       	push	r15
     c0a:	0f 93       	push	r16
     c0c:	cf 93       	push	r28
     c0e:	df 93       	push	r29
     c10:	5c 01       	movw	r10, r24
     c12:	4b 01       	movw	r8, r22
     c14:	3a 01       	movw	r6, r20
     c16:	29 01       	movw	r4, r18
     c18:	81 e2       	ldi	r24, 0x21	; 33
     c1a:	90 e0       	ldi	r25, 0x00	; 0
     c1c:	78 dd       	rcall	.-1296   	; 0x70e <pvPortMalloc>
     c1e:	ec 01       	movw	r28, r24
     c20:	89 2b       	or	r24, r25
     c22:	09 f4       	brne	.+2      	; 0xc26 <xTaskGenericCreate+0x34>
     c24:	9c c0       	rjmp	.+312    	; 0xd5e <xTaskGenericCreate+0x16c>
     c26:	c1 14       	cp	r12, r1
     c28:	d1 04       	cpc	r13, r1
     c2a:	09 f0       	breq	.+2      	; 0xc2e <xTaskGenericCreate+0x3c>
     c2c:	94 c0       	rjmp	.+296    	; 0xd56 <xTaskGenericCreate+0x164>
     c2e:	c3 01       	movw	r24, r6
     c30:	6e dd       	rcall	.-1316   	; 0x70e <pvPortMalloc>
     c32:	98 8f       	std	Y+24, r25	; 0x18
     c34:	8f 8b       	std	Y+23, r24	; 0x17
     c36:	00 97       	sbiw	r24, 0x00	; 0
     c38:	19 f4       	brne	.+6      	; 0xc40 <xTaskGenericCreate+0x4e>
     c3a:	ce 01       	movw	r24, r28
     c3c:	8c dd       	rcall	.-1256   	; 0x756 <vPortFree>
     c3e:	8f c0       	rjmp	.+286    	; 0xd5e <xTaskGenericCreate+0x16c>
     c40:	a3 01       	movw	r20, r6
     c42:	65 ea       	ldi	r22, 0xA5	; 165
     c44:	70 e0       	ldi	r23, 0x00	; 0
     c46:	ad d3       	rcall	.+1882   	; 0x13a2 <memset>
     c48:	93 01       	movw	r18, r6
     c4a:	21 50       	subi	r18, 0x01	; 1
     c4c:	31 09       	sbc	r19, r1
     c4e:	8f 89       	ldd	r24, Y+23	; 0x17
     c50:	98 8d       	ldd	r25, Y+24	; 0x18
     c52:	3c 01       	movw	r6, r24
     c54:	62 0e       	add	r6, r18
     c56:	73 1e       	adc	r7, r19
     c58:	48 e0       	ldi	r20, 0x08	; 8
     c5a:	50 e0       	ldi	r21, 0x00	; 0
     c5c:	b4 01       	movw	r22, r8
     c5e:	ce 01       	movw	r24, r28
     c60:	49 96       	adiw	r24, 0x19	; 25
     c62:	a6 d3       	rcall	.+1868   	; 0x13b0 <strncpy>
     c64:	18 a2       	std	Y+32, r1	; 0x20
     c66:	1e 8a       	std	Y+22, r1	; 0x16
     c68:	6e 01       	movw	r12, r28
     c6a:	82 e0       	ldi	r24, 0x02	; 2
     c6c:	c8 0e       	add	r12, r24
     c6e:	d1 1c       	adc	r13, r1
     c70:	c6 01       	movw	r24, r12
     c72:	4e db       	rcall	.-2404   	; 0x310 <vListInitialiseItem>
     c74:	ce 01       	movw	r24, r28
     c76:	0c 96       	adiw	r24, 0x0c	; 12
     c78:	4b db       	rcall	.-2410   	; 0x310 <vListInitialiseItem>
     c7a:	d9 87       	std	Y+9, r29	; 0x09
     c7c:	c8 87       	std	Y+8, r28	; 0x08
     c7e:	81 e0       	ldi	r24, 0x01	; 1
     c80:	90 e0       	ldi	r25, 0x00	; 0
     c82:	9d 87       	std	Y+13, r25	; 0x0d
     c84:	8c 87       	std	Y+12, r24	; 0x0c
     c86:	db 8b       	std	Y+19, r29	; 0x13
     c88:	ca 8b       	std	Y+18, r28	; 0x12
     c8a:	a2 01       	movw	r20, r4
     c8c:	b5 01       	movw	r22, r10
     c8e:	c3 01       	movw	r24, r6
     c90:	cb db       	rcall	.-2154   	; 0x428 <pxPortInitialiseStack>
     c92:	99 83       	std	Y+1, r25	; 0x01
     c94:	88 83       	st	Y, r24
     c96:	e1 14       	cp	r14, r1
     c98:	f1 04       	cpc	r15, r1
     c9a:	19 f0       	breq	.+6      	; 0xca2 <xTaskGenericCreate+0xb0>
     c9c:	f7 01       	movw	r30, r14
     c9e:	d1 83       	std	Z+1, r29	; 0x01
     ca0:	c0 83       	st	Z, r28
     ca2:	0f b6       	in	r0, 0x3f	; 63
     ca4:	f8 94       	cli
     ca6:	0f 92       	push	r0
     ca8:	80 91 11 08 	lds	r24, 0x0811	; 0x800811 <uxCurrentNumberOfTasks>
     cac:	8f 5f       	subi	r24, 0xFF	; 255
     cae:	80 93 11 08 	sts	0x0811, r24	; 0x800811 <uxCurrentNumberOfTasks>
     cb2:	80 91 3a 08 	lds	r24, 0x083A	; 0x80083a <pxCurrentTCB>
     cb6:	90 91 3b 08 	lds	r25, 0x083B	; 0x80083b <pxCurrentTCB+0x1>
     cba:	89 2b       	or	r24, r25
     cbc:	49 f4       	brne	.+18     	; 0xcd0 <xTaskGenericCreate+0xde>
     cbe:	d0 93 3b 08 	sts	0x083B, r29	; 0x80083b <pxCurrentTCB+0x1>
     cc2:	c0 93 3a 08 	sts	0x083A, r28	; 0x80083a <pxCurrentTCB>
     cc6:	80 91 11 08 	lds	r24, 0x0811	; 0x800811 <uxCurrentNumberOfTasks>
     cca:	81 30       	cpi	r24, 0x01	; 1
     ccc:	81 f4       	brne	.+32     	; 0xcee <xTaskGenericCreate+0xfc>
     cce:	49 c0       	rjmp	.+146    	; 0xd62 <xTaskGenericCreate+0x170>
     cd0:	80 91 0c 08 	lds	r24, 0x080C	; 0x80080c <xSchedulerRunning>
     cd4:	81 11       	cpse	r24, r1
     cd6:	0b c0       	rjmp	.+22     	; 0xcee <xTaskGenericCreate+0xfc>
     cd8:	e0 91 3a 08 	lds	r30, 0x083A	; 0x80083a <pxCurrentTCB>
     cdc:	f0 91 3b 08 	lds	r31, 0x083B	; 0x80083b <pxCurrentTCB+0x1>
     ce0:	86 89       	ldd	r24, Z+22	; 0x16
     ce2:	08 17       	cp	r16, r24
     ce4:	20 f0       	brcs	.+8      	; 0xcee <xTaskGenericCreate+0xfc>
     ce6:	d0 93 3b 08 	sts	0x083B, r29	; 0x80083b <pxCurrentTCB+0x1>
     cea:	c0 93 3a 08 	sts	0x083A, r28	; 0x80083a <pxCurrentTCB>
     cee:	8e 89       	ldd	r24, Y+22	; 0x16
     cf0:	90 91 0e 08 	lds	r25, 0x080E	; 0x80080e <uxTopUsedPriority>
     cf4:	98 17       	cp	r25, r24
     cf6:	10 f4       	brcc	.+4      	; 0xcfc <xTaskGenericCreate+0x10a>
     cf8:	80 93 0e 08 	sts	0x080E, r24	; 0x80080e <uxTopUsedPriority>
     cfc:	90 91 07 08 	lds	r25, 0x0807	; 0x800807 <uxTCBNumber>
     d00:	9f 5f       	subi	r25, 0xFF	; 255
     d02:	90 93 07 08 	sts	0x0807, r25	; 0x800807 <uxTCBNumber>
     d06:	90 91 0d 08 	lds	r25, 0x080D	; 0x80080d <uxTopReadyPriority>
     d0a:	98 17       	cp	r25, r24
     d0c:	10 f4       	brcc	.+4      	; 0xd12 <xTaskGenericCreate+0x120>
     d0e:	80 93 0d 08 	sts	0x080D, r24	; 0x80080d <uxTopReadyPriority>
     d12:	90 e0       	ldi	r25, 0x00	; 0
     d14:	9c 01       	movw	r18, r24
     d16:	22 0f       	add	r18, r18
     d18:	33 1f       	adc	r19, r19
     d1a:	22 0f       	add	r18, r18
     d1c:	33 1f       	adc	r19, r19
     d1e:	22 0f       	add	r18, r18
     d20:	33 1f       	adc	r19, r19
     d22:	82 0f       	add	r24, r18
     d24:	93 1f       	adc	r25, r19
     d26:	b6 01       	movw	r22, r12
     d28:	8f 5c       	subi	r24, 0xCF	; 207
     d2a:	97 4f       	sbci	r25, 0xF7	; 247
     d2c:	f5 da       	rcall	.-2582   	; 0x318 <vListInsertEnd>
     d2e:	0f 90       	pop	r0
     d30:	0f be       	out	0x3f, r0	; 63
     d32:	80 91 0c 08 	lds	r24, 0x080C	; 0x80080c <xSchedulerRunning>
     d36:	88 23       	and	r24, r24
     d38:	51 f0       	breq	.+20     	; 0xd4e <xTaskGenericCreate+0x15c>
     d3a:	e0 91 3a 08 	lds	r30, 0x083A	; 0x80083a <pxCurrentTCB>
     d3e:	f0 91 3b 08 	lds	r31, 0x083B	; 0x80083b <pxCurrentTCB+0x1>
     d42:	86 89       	ldd	r24, Z+22	; 0x16
     d44:	80 17       	cp	r24, r16
     d46:	28 f4       	brcc	.+10     	; 0xd52 <xTaskGenericCreate+0x160>
     d48:	1f dc       	rcall	.-1986   	; 0x588 <vPortYield>
     d4a:	81 e0       	ldi	r24, 0x01	; 1
     d4c:	23 c0       	rjmp	.+70     	; 0xd94 <xTaskGenericCreate+0x1a2>
     d4e:	81 e0       	ldi	r24, 0x01	; 1
     d50:	21 c0       	rjmp	.+66     	; 0xd94 <xTaskGenericCreate+0x1a2>
     d52:	81 e0       	ldi	r24, 0x01	; 1
     d54:	1f c0       	rjmp	.+62     	; 0xd94 <xTaskGenericCreate+0x1a2>
     d56:	d8 8e       	std	Y+24, r13	; 0x18
     d58:	cf 8a       	std	Y+23, r12	; 0x17
     d5a:	c6 01       	movw	r24, r12
     d5c:	71 cf       	rjmp	.-286    	; 0xc40 <xTaskGenericCreate+0x4e>
     d5e:	8f ef       	ldi	r24, 0xFF	; 255
     d60:	19 c0       	rjmp	.+50     	; 0xd94 <xTaskGenericCreate+0x1a2>
     d62:	81 e3       	ldi	r24, 0x31	; 49
     d64:	98 e0       	ldi	r25, 0x08	; 8
     d66:	c6 da       	rcall	.-2676   	; 0x2f4 <vListInitialise>
     d68:	88 e2       	ldi	r24, 0x28	; 40
     d6a:	98 e0       	ldi	r25, 0x08	; 8
     d6c:	c3 da       	rcall	.-2682   	; 0x2f4 <vListInitialise>
     d6e:	8f e1       	ldi	r24, 0x1F	; 31
     d70:	98 e0       	ldi	r25, 0x08	; 8
     d72:	c0 da       	rcall	.-2688   	; 0x2f4 <vListInitialise>
     d74:	82 e1       	ldi	r24, 0x12	; 18
     d76:	98 e0       	ldi	r25, 0x08	; 8
     d78:	bd da       	rcall	.-2694   	; 0x2f4 <vListInitialise>
     d7a:	88 e2       	ldi	r24, 0x28	; 40
     d7c:	98 e0       	ldi	r25, 0x08	; 8
     d7e:	90 93 1e 08 	sts	0x081E, r25	; 0x80081e <pxDelayedTaskList+0x1>
     d82:	80 93 1d 08 	sts	0x081D, r24	; 0x80081d <pxDelayedTaskList>
     d86:	8f e1       	ldi	r24, 0x1F	; 31
     d88:	98 e0       	ldi	r25, 0x08	; 8
     d8a:	90 93 1c 08 	sts	0x081C, r25	; 0x80081c <pxOverflowDelayedTaskList+0x1>
     d8e:	80 93 1b 08 	sts	0x081B, r24	; 0x80081b <pxOverflowDelayedTaskList>
     d92:	ad cf       	rjmp	.-166    	; 0xcee <xTaskGenericCreate+0xfc>
     d94:	df 91       	pop	r29
     d96:	cf 91       	pop	r28
     d98:	0f 91       	pop	r16
     d9a:	ff 90       	pop	r15
     d9c:	ef 90       	pop	r14
     d9e:	df 90       	pop	r13
     da0:	cf 90       	pop	r12
     da2:	bf 90       	pop	r11
     da4:	af 90       	pop	r10
     da6:	9f 90       	pop	r9
     da8:	8f 90       	pop	r8
     daa:	7f 90       	pop	r7
     dac:	6f 90       	pop	r6
     dae:	5f 90       	pop	r5
     db0:	4f 90       	pop	r4
     db2:	08 95       	ret

00000db4 <vTaskStartScheduler>:
     db4:	af 92       	push	r10
     db6:	bf 92       	push	r11
     db8:	cf 92       	push	r12
     dba:	df 92       	push	r13
     dbc:	ef 92       	push	r14
     dbe:	ff 92       	push	r15
     dc0:	0f 93       	push	r16
     dc2:	a1 2c       	mov	r10, r1
     dc4:	b1 2c       	mov	r11, r1
     dc6:	c1 2c       	mov	r12, r1
     dc8:	d1 2c       	mov	r13, r1
     dca:	e1 2c       	mov	r14, r1
     dcc:	f1 2c       	mov	r15, r1
     dce:	00 e0       	ldi	r16, 0x00	; 0
     dd0:	20 e0       	ldi	r18, 0x00	; 0
     dd2:	30 e0       	ldi	r19, 0x00	; 0
     dd4:	45 e5       	ldi	r20, 0x55	; 85
     dd6:	50 e0       	ldi	r21, 0x00	; 0
     dd8:	6e e1       	ldi	r22, 0x1E	; 30
     dda:	72 e0       	ldi	r23, 0x02	; 2
     ddc:	8d eb       	ldi	r24, 0xBD	; 189
     dde:	95 e0       	ldi	r25, 0x05	; 5
     de0:	08 df       	rcall	.-496    	; 0xbf2 <xTaskGenericCreate>
     de2:	81 30       	cpi	r24, 0x01	; 1
     de4:	41 f4       	brne	.+16     	; 0xdf6 <vTaskStartScheduler+0x42>
     de6:	f8 94       	cli
     de8:	80 93 0c 08 	sts	0x080C, r24	; 0x80080c <xSchedulerRunning>
     dec:	10 92 10 08 	sts	0x0810, r1	; 0x800810 <xTickCount+0x1>
     df0:	10 92 0f 08 	sts	0x080F, r1	; 0x80080f <xTickCount>
     df4:	8b db       	rcall	.-2282   	; 0x50c <xPortStartScheduler>
     df6:	0f 91       	pop	r16
     df8:	ff 90       	pop	r15
     dfa:	ef 90       	pop	r14
     dfc:	df 90       	pop	r13
     dfe:	cf 90       	pop	r12
     e00:	bf 90       	pop	r11
     e02:	af 90       	pop	r10
     e04:	08 95       	ret

00000e06 <vTaskSuspendAll>:
     e06:	80 91 0b 08 	lds	r24, 0x080B	; 0x80080b <uxSchedulerSuspended>
     e0a:	8f 5f       	subi	r24, 0xFF	; 255
     e0c:	80 93 0b 08 	sts	0x080B, r24	; 0x80080b <uxSchedulerSuspended>
     e10:	08 95       	ret

00000e12 <xTaskGetTickCount>:
     e12:	0f b6       	in	r0, 0x3f	; 63
     e14:	f8 94       	cli
     e16:	0f 92       	push	r0
     e18:	80 91 0f 08 	lds	r24, 0x080F	; 0x80080f <xTickCount>
     e1c:	90 91 10 08 	lds	r25, 0x0810	; 0x800810 <xTickCount+0x1>
     e20:	0f 90       	pop	r0
     e22:	0f be       	out	0x3f, r0	; 63
     e24:	08 95       	ret

00000e26 <vTaskIncrementTick>:
     e26:	0f 93       	push	r16
     e28:	1f 93       	push	r17
     e2a:	cf 93       	push	r28
     e2c:	df 93       	push	r29
     e2e:	80 91 0b 08 	lds	r24, 0x080B	; 0x80080b <uxSchedulerSuspended>
     e32:	81 11       	cpse	r24, r1
     e34:	af c0       	rjmp	.+350    	; 0xf94 <vTaskIncrementTick+0x16e>
     e36:	80 91 0f 08 	lds	r24, 0x080F	; 0x80080f <xTickCount>
     e3a:	90 91 10 08 	lds	r25, 0x0810	; 0x800810 <xTickCount+0x1>
     e3e:	01 96       	adiw	r24, 0x01	; 1
     e40:	90 93 10 08 	sts	0x0810, r25	; 0x800810 <xTickCount+0x1>
     e44:	80 93 0f 08 	sts	0x080F, r24	; 0x80080f <xTickCount>
     e48:	80 91 0f 08 	lds	r24, 0x080F	; 0x80080f <xTickCount>
     e4c:	90 91 10 08 	lds	r25, 0x0810	; 0x800810 <xTickCount+0x1>
     e50:	89 2b       	or	r24, r25
     e52:	99 f5       	brne	.+102    	; 0xeba <vTaskIncrementTick+0x94>
     e54:	80 91 1d 08 	lds	r24, 0x081D	; 0x80081d <pxDelayedTaskList>
     e58:	90 91 1e 08 	lds	r25, 0x081E	; 0x80081e <pxDelayedTaskList+0x1>
     e5c:	20 91 1b 08 	lds	r18, 0x081B	; 0x80081b <pxOverflowDelayedTaskList>
     e60:	30 91 1c 08 	lds	r19, 0x081C	; 0x80081c <pxOverflowDelayedTaskList+0x1>
     e64:	30 93 1e 08 	sts	0x081E, r19	; 0x80081e <pxDelayedTaskList+0x1>
     e68:	20 93 1d 08 	sts	0x081D, r18	; 0x80081d <pxDelayedTaskList>
     e6c:	90 93 1c 08 	sts	0x081C, r25	; 0x80081c <pxOverflowDelayedTaskList+0x1>
     e70:	80 93 1b 08 	sts	0x081B, r24	; 0x80081b <pxOverflowDelayedTaskList>
     e74:	80 91 08 08 	lds	r24, 0x0808	; 0x800808 <xNumOfOverflows>
     e78:	8f 5f       	subi	r24, 0xFF	; 255
     e7a:	80 93 08 08 	sts	0x0808, r24	; 0x800808 <xNumOfOverflows>
     e7e:	e0 91 1d 08 	lds	r30, 0x081D	; 0x80081d <pxDelayedTaskList>
     e82:	f0 91 1e 08 	lds	r31, 0x081E	; 0x80081e <pxDelayedTaskList+0x1>
     e86:	80 81       	ld	r24, Z
     e88:	81 11       	cpse	r24, r1
     e8a:	07 c0       	rjmp	.+14     	; 0xe9a <vTaskIncrementTick+0x74>
     e8c:	8f ef       	ldi	r24, 0xFF	; 255
     e8e:	9f ef       	ldi	r25, 0xFF	; 255
     e90:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
     e94:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <__DATA_REGION_ORIGIN__>
     e98:	10 c0       	rjmp	.+32     	; 0xeba <vTaskIncrementTick+0x94>
     e9a:	e0 91 1d 08 	lds	r30, 0x081D	; 0x80081d <pxDelayedTaskList>
     e9e:	f0 91 1e 08 	lds	r31, 0x081E	; 0x80081e <pxDelayedTaskList+0x1>
     ea2:	05 80       	ldd	r0, Z+5	; 0x05
     ea4:	f6 81       	ldd	r31, Z+6	; 0x06
     ea6:	e0 2d       	mov	r30, r0
     ea8:	06 80       	ldd	r0, Z+6	; 0x06
     eaa:	f7 81       	ldd	r31, Z+7	; 0x07
     eac:	e0 2d       	mov	r30, r0
     eae:	82 81       	ldd	r24, Z+2	; 0x02
     eb0:	93 81       	ldd	r25, Z+3	; 0x03
     eb2:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
     eb6:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <__DATA_REGION_ORIGIN__>
     eba:	20 91 0f 08 	lds	r18, 0x080F	; 0x80080f <xTickCount>
     ebe:	30 91 10 08 	lds	r19, 0x0810	; 0x800810 <xTickCount+0x1>
     ec2:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <__DATA_REGION_ORIGIN__>
     ec6:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
     eca:	28 17       	cp	r18, r24
     ecc:	39 07       	cpc	r19, r25
     ece:	08 f4       	brcc	.+2      	; 0xed2 <vTaskIncrementTick+0xac>
     ed0:	66 c0       	rjmp	.+204    	; 0xf9e <vTaskIncrementTick+0x178>
     ed2:	e0 91 1d 08 	lds	r30, 0x081D	; 0x80081d <pxDelayedTaskList>
     ed6:	f0 91 1e 08 	lds	r31, 0x081E	; 0x80081e <pxDelayedTaskList+0x1>
     eda:	80 81       	ld	r24, Z
     edc:	88 23       	and	r24, r24
     ede:	99 f0       	breq	.+38     	; 0xf06 <vTaskIncrementTick+0xe0>
     ee0:	e0 91 1d 08 	lds	r30, 0x081D	; 0x80081d <pxDelayedTaskList>
     ee4:	f0 91 1e 08 	lds	r31, 0x081E	; 0x80081e <pxDelayedTaskList+0x1>
     ee8:	05 80       	ldd	r0, Z+5	; 0x05
     eea:	f6 81       	ldd	r31, Z+6	; 0x06
     eec:	e0 2d       	mov	r30, r0
     eee:	c6 81       	ldd	r28, Z+6	; 0x06
     ef0:	d7 81       	ldd	r29, Z+7	; 0x07
     ef2:	8a 81       	ldd	r24, Y+2	; 0x02
     ef4:	9b 81       	ldd	r25, Y+3	; 0x03
     ef6:	20 91 0f 08 	lds	r18, 0x080F	; 0x80080f <xTickCount>
     efa:	30 91 10 08 	lds	r19, 0x0810	; 0x800810 <xTickCount+0x1>
     efe:	28 17       	cp	r18, r24
     f00:	39 07       	cpc	r19, r25
     f02:	f8 f4       	brcc	.+62     	; 0xf42 <vTaskIncrementTick+0x11c>
     f04:	19 c0       	rjmp	.+50     	; 0xf38 <vTaskIncrementTick+0x112>
     f06:	8f ef       	ldi	r24, 0xFF	; 255
     f08:	9f ef       	ldi	r25, 0xFF	; 255
     f0a:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
     f0e:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <__DATA_REGION_ORIGIN__>
     f12:	45 c0       	rjmp	.+138    	; 0xf9e <vTaskIncrementTick+0x178>
     f14:	e0 91 1d 08 	lds	r30, 0x081D	; 0x80081d <pxDelayedTaskList>
     f18:	f0 91 1e 08 	lds	r31, 0x081E	; 0x80081e <pxDelayedTaskList+0x1>
     f1c:	05 80       	ldd	r0, Z+5	; 0x05
     f1e:	f6 81       	ldd	r31, Z+6	; 0x06
     f20:	e0 2d       	mov	r30, r0
     f22:	c6 81       	ldd	r28, Z+6	; 0x06
     f24:	d7 81       	ldd	r29, Z+7	; 0x07
     f26:	8a 81       	ldd	r24, Y+2	; 0x02
     f28:	9b 81       	ldd	r25, Y+3	; 0x03
     f2a:	20 91 0f 08 	lds	r18, 0x080F	; 0x80080f <xTickCount>
     f2e:	30 91 10 08 	lds	r19, 0x0810	; 0x800810 <xTickCount+0x1>
     f32:	28 17       	cp	r18, r24
     f34:	39 07       	cpc	r19, r25
     f36:	28 f4       	brcc	.+10     	; 0xf42 <vTaskIncrementTick+0x11c>
     f38:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
     f3c:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <__DATA_REGION_ORIGIN__>
     f40:	2e c0       	rjmp	.+92     	; 0xf9e <vTaskIncrementTick+0x178>
     f42:	8e 01       	movw	r16, r28
     f44:	0e 5f       	subi	r16, 0xFE	; 254
     f46:	1f 4f       	sbci	r17, 0xFF	; 255
     f48:	c8 01       	movw	r24, r16
     f4a:	48 da       	rcall	.-2928   	; 0x3dc <vListRemove>
     f4c:	8c 89       	ldd	r24, Y+20	; 0x14
     f4e:	9d 89       	ldd	r25, Y+21	; 0x15
     f50:	89 2b       	or	r24, r25
     f52:	19 f0       	breq	.+6      	; 0xf5a <vTaskIncrementTick+0x134>
     f54:	ce 01       	movw	r24, r28
     f56:	0c 96       	adiw	r24, 0x0c	; 12
     f58:	41 da       	rcall	.-2942   	; 0x3dc <vListRemove>
     f5a:	8e 89       	ldd	r24, Y+22	; 0x16
     f5c:	90 91 0d 08 	lds	r25, 0x080D	; 0x80080d <uxTopReadyPriority>
     f60:	98 17       	cp	r25, r24
     f62:	10 f4       	brcc	.+4      	; 0xf68 <vTaskIncrementTick+0x142>
     f64:	80 93 0d 08 	sts	0x080D, r24	; 0x80080d <uxTopReadyPriority>
     f68:	90 e0       	ldi	r25, 0x00	; 0
     f6a:	9c 01       	movw	r18, r24
     f6c:	22 0f       	add	r18, r18
     f6e:	33 1f       	adc	r19, r19
     f70:	22 0f       	add	r18, r18
     f72:	33 1f       	adc	r19, r19
     f74:	22 0f       	add	r18, r18
     f76:	33 1f       	adc	r19, r19
     f78:	82 0f       	add	r24, r18
     f7a:	93 1f       	adc	r25, r19
     f7c:	b8 01       	movw	r22, r16
     f7e:	8f 5c       	subi	r24, 0xCF	; 207
     f80:	97 4f       	sbci	r25, 0xF7	; 247
     f82:	ca d9       	rcall	.-3180   	; 0x318 <vListInsertEnd>
     f84:	e0 91 1d 08 	lds	r30, 0x081D	; 0x80081d <pxDelayedTaskList>
     f88:	f0 91 1e 08 	lds	r31, 0x081E	; 0x80081e <pxDelayedTaskList+0x1>
     f8c:	80 81       	ld	r24, Z
     f8e:	81 11       	cpse	r24, r1
     f90:	c1 cf       	rjmp	.-126    	; 0xf14 <vTaskIncrementTick+0xee>
     f92:	b9 cf       	rjmp	.-142    	; 0xf06 <vTaskIncrementTick+0xe0>
     f94:	80 91 0a 08 	lds	r24, 0x080A	; 0x80080a <uxMissedTicks>
     f98:	8f 5f       	subi	r24, 0xFF	; 255
     f9a:	80 93 0a 08 	sts	0x080A, r24	; 0x80080a <uxMissedTicks>
     f9e:	df 91       	pop	r29
     fa0:	cf 91       	pop	r28
     fa2:	1f 91       	pop	r17
     fa4:	0f 91       	pop	r16
     fa6:	08 95       	ret

00000fa8 <xTaskResumeAll>:
     fa8:	cf 92       	push	r12
     faa:	df 92       	push	r13
     fac:	ef 92       	push	r14
     fae:	ff 92       	push	r15
     fb0:	0f 93       	push	r16
     fb2:	1f 93       	push	r17
     fb4:	cf 93       	push	r28
     fb6:	df 93       	push	r29
     fb8:	0f b6       	in	r0, 0x3f	; 63
     fba:	f8 94       	cli
     fbc:	0f 92       	push	r0
     fbe:	80 91 0b 08 	lds	r24, 0x080B	; 0x80080b <uxSchedulerSuspended>
     fc2:	81 50       	subi	r24, 0x01	; 1
     fc4:	80 93 0b 08 	sts	0x080B, r24	; 0x80080b <uxSchedulerSuspended>
     fc8:	80 91 0b 08 	lds	r24, 0x080B	; 0x80080b <uxSchedulerSuspended>
     fcc:	81 11       	cpse	r24, r1
     fce:	5f c0       	rjmp	.+190    	; 0x108e <__EEPROM_REGION_LENGTH__+0x8e>
     fd0:	80 91 11 08 	lds	r24, 0x0811	; 0x800811 <uxCurrentNumberOfTasks>
     fd4:	81 11       	cpse	r24, r1
     fd6:	2f c0       	rjmp	.+94     	; 0x1036 <__EEPROM_REGION_LENGTH__+0x36>
     fd8:	5d c0       	rjmp	.+186    	; 0x1094 <__EEPROM_REGION_LENGTH__+0x94>
     fda:	d7 01       	movw	r26, r14
     fdc:	15 96       	adiw	r26, 0x05	; 5
     fde:	ed 91       	ld	r30, X+
     fe0:	fc 91       	ld	r31, X
     fe2:	16 97       	sbiw	r26, 0x06	; 6
     fe4:	c6 81       	ldd	r28, Z+6	; 0x06
     fe6:	d7 81       	ldd	r29, Z+7	; 0x07
     fe8:	ce 01       	movw	r24, r28
     fea:	0c 96       	adiw	r24, 0x0c	; 12
     fec:	f7 d9       	rcall	.-3090   	; 0x3dc <vListRemove>
     fee:	8e 01       	movw	r16, r28
     ff0:	0e 5f       	subi	r16, 0xFE	; 254
     ff2:	1f 4f       	sbci	r17, 0xFF	; 255
     ff4:	c8 01       	movw	r24, r16
     ff6:	f2 d9       	rcall	.-3100   	; 0x3dc <vListRemove>
     ff8:	8e 89       	ldd	r24, Y+22	; 0x16
     ffa:	90 91 0d 08 	lds	r25, 0x080D	; 0x80080d <uxTopReadyPriority>
     ffe:	98 17       	cp	r25, r24
    1000:	10 f4       	brcc	.+4      	; 0x1006 <__EEPROM_REGION_LENGTH__+0x6>
    1002:	80 93 0d 08 	sts	0x080D, r24	; 0x80080d <uxTopReadyPriority>
    1006:	90 e0       	ldi	r25, 0x00	; 0
    1008:	9c 01       	movw	r18, r24
    100a:	22 0f       	add	r18, r18
    100c:	33 1f       	adc	r19, r19
    100e:	22 0f       	add	r18, r18
    1010:	33 1f       	adc	r19, r19
    1012:	22 0f       	add	r18, r18
    1014:	33 1f       	adc	r19, r19
    1016:	82 0f       	add	r24, r18
    1018:	93 1f       	adc	r25, r19
    101a:	b8 01       	movw	r22, r16
    101c:	8f 5c       	subi	r24, 0xCF	; 207
    101e:	97 4f       	sbci	r25, 0xF7	; 247
    1020:	7b d9       	rcall	.-3338   	; 0x318 <vListInsertEnd>
    1022:	e0 91 3a 08 	lds	r30, 0x083A	; 0x80083a <pxCurrentTCB>
    1026:	f0 91 3b 08 	lds	r31, 0x083B	; 0x80083b <pxCurrentTCB+0x1>
    102a:	9e 89       	ldd	r25, Y+22	; 0x16
    102c:	86 89       	ldd	r24, Z+22	; 0x16
    102e:	98 17       	cp	r25, r24
    1030:	58 f0       	brcs	.+22     	; 0x1048 <__EEPROM_REGION_LENGTH__+0x48>
    1032:	dc 2c       	mov	r13, r12
    1034:	09 c0       	rjmp	.+18     	; 0x1048 <__EEPROM_REGION_LENGTH__+0x48>
    1036:	d1 2c       	mov	r13, r1
    1038:	0f 2e       	mov	r0, r31
    103a:	f2 e1       	ldi	r31, 0x12	; 18
    103c:	ef 2e       	mov	r14, r31
    103e:	f8 e0       	ldi	r31, 0x08	; 8
    1040:	ff 2e       	mov	r15, r31
    1042:	f0 2d       	mov	r31, r0
    1044:	cc 24       	eor	r12, r12
    1046:	c3 94       	inc	r12
    1048:	f7 01       	movw	r30, r14
    104a:	80 81       	ld	r24, Z
    104c:	81 11       	cpse	r24, r1
    104e:	c5 cf       	rjmp	.-118    	; 0xfda <xTaskResumeAll+0x32>
    1050:	80 91 0a 08 	lds	r24, 0x080A	; 0x80080a <uxMissedTicks>
    1054:	88 23       	and	r24, r24
    1056:	79 f0       	breq	.+30     	; 0x1076 <__EEPROM_REGION_LENGTH__+0x76>
    1058:	80 91 0a 08 	lds	r24, 0x080A	; 0x80080a <uxMissedTicks>
    105c:	88 23       	and	r24, r24
    105e:	91 f0       	breq	.+36     	; 0x1084 <__EEPROM_REGION_LENGTH__+0x84>
    1060:	e2 de       	rcall	.-572    	; 0xe26 <vTaskIncrementTick>
    1062:	80 91 0a 08 	lds	r24, 0x080A	; 0x80080a <uxMissedTicks>
    1066:	81 50       	subi	r24, 0x01	; 1
    1068:	80 93 0a 08 	sts	0x080A, r24	; 0x80080a <uxMissedTicks>
    106c:	80 91 0a 08 	lds	r24, 0x080A	; 0x80080a <uxMissedTicks>
    1070:	81 11       	cpse	r24, r1
    1072:	f6 cf       	rjmp	.-20     	; 0x1060 <__EEPROM_REGION_LENGTH__+0x60>
    1074:	07 c0       	rjmp	.+14     	; 0x1084 <__EEPROM_REGION_LENGTH__+0x84>
    1076:	f1 e0       	ldi	r31, 0x01	; 1
    1078:	df 16       	cp	r13, r31
    107a:	21 f0       	breq	.+8      	; 0x1084 <__EEPROM_REGION_LENGTH__+0x84>
    107c:	80 91 09 08 	lds	r24, 0x0809	; 0x800809 <xMissedYield>
    1080:	81 30       	cpi	r24, 0x01	; 1
    1082:	39 f4       	brne	.+14     	; 0x1092 <__EEPROM_REGION_LENGTH__+0x92>
    1084:	10 92 09 08 	sts	0x0809, r1	; 0x800809 <xMissedYield>
    1088:	7f da       	rcall	.-2818   	; 0x588 <vPortYield>
    108a:	81 e0       	ldi	r24, 0x01	; 1
    108c:	03 c0       	rjmp	.+6      	; 0x1094 <__EEPROM_REGION_LENGTH__+0x94>
    108e:	80 e0       	ldi	r24, 0x00	; 0
    1090:	01 c0       	rjmp	.+2      	; 0x1094 <__EEPROM_REGION_LENGTH__+0x94>
    1092:	80 e0       	ldi	r24, 0x00	; 0
    1094:	0f 90       	pop	r0
    1096:	0f be       	out	0x3f, r0	; 63
    1098:	df 91       	pop	r29
    109a:	cf 91       	pop	r28
    109c:	1f 91       	pop	r17
    109e:	0f 91       	pop	r16
    10a0:	ff 90       	pop	r15
    10a2:	ef 90       	pop	r14
    10a4:	df 90       	pop	r13
    10a6:	cf 90       	pop	r12
    10a8:	08 95       	ret

000010aa <vTaskDelayUntil>:
    10aa:	0f 93       	push	r16
    10ac:	1f 93       	push	r17
    10ae:	cf 93       	push	r28
    10b0:	df 93       	push	r29
    10b2:	8c 01       	movw	r16, r24
    10b4:	eb 01       	movw	r28, r22
    10b6:	a7 de       	rcall	.-690    	; 0xe06 <vTaskSuspendAll>
    10b8:	f8 01       	movw	r30, r16
    10ba:	80 81       	ld	r24, Z
    10bc:	91 81       	ldd	r25, Z+1	; 0x01
    10be:	c8 0f       	add	r28, r24
    10c0:	d9 1f       	adc	r29, r25
    10c2:	20 91 0f 08 	lds	r18, 0x080F	; 0x80080f <xTickCount>
    10c6:	30 91 10 08 	lds	r19, 0x0810	; 0x800810 <xTickCount+0x1>
    10ca:	28 17       	cp	r18, r24
    10cc:	39 07       	cpc	r19, r25
    10ce:	68 f4       	brcc	.+26     	; 0x10ea <vTaskDelayUntil+0x40>
    10d0:	c8 17       	cp	r28, r24
    10d2:	d9 07       	cpc	r29, r25
    10d4:	30 f5       	brcc	.+76     	; 0x1122 <vTaskDelayUntil+0x78>
    10d6:	80 91 0f 08 	lds	r24, 0x080F	; 0x80080f <xTickCount>
    10da:	90 91 10 08 	lds	r25, 0x0810	; 0x800810 <xTickCount+0x1>
    10de:	d1 83       	std	Z+1, r29	; 0x01
    10e0:	c0 83       	st	Z, r28
    10e2:	8c 17       	cp	r24, r28
    10e4:	9d 07       	cpc	r25, r29
    10e6:	a0 f4       	brcc	.+40     	; 0x1110 <vTaskDelayUntil+0x66>
    10e8:	0b c0       	rjmp	.+22     	; 0x1100 <vTaskDelayUntil+0x56>
    10ea:	c8 17       	cp	r28, r24
    10ec:	d9 07       	cpc	r29, r25
    10ee:	a8 f0       	brcs	.+42     	; 0x111a <vTaskDelayUntil+0x70>
    10f0:	80 91 0f 08 	lds	r24, 0x080F	; 0x80080f <xTickCount>
    10f4:	90 91 10 08 	lds	r25, 0x0810	; 0x800810 <xTickCount+0x1>
    10f8:	8c 17       	cp	r24, r28
    10fa:	9d 07       	cpc	r25, r29
    10fc:	70 f0       	brcs	.+28     	; 0x111a <vTaskDelayUntil+0x70>
    10fe:	11 c0       	rjmp	.+34     	; 0x1122 <vTaskDelayUntil+0x78>
    1100:	80 91 3a 08 	lds	r24, 0x083A	; 0x80083a <pxCurrentTCB>
    1104:	90 91 3b 08 	lds	r25, 0x083B	; 0x80083b <pxCurrentTCB+0x1>
    1108:	02 96       	adiw	r24, 0x02	; 2
    110a:	68 d9       	rcall	.-3376   	; 0x3dc <vListRemove>
    110c:	ce 01       	movw	r24, r28
    110e:	3c dd       	rcall	.-1416   	; 0xb88 <prvAddCurrentTaskToDelayedList>
    1110:	4b df       	rcall	.-362    	; 0xfa8 <xTaskResumeAll>
    1112:	81 11       	cpse	r24, r1
    1114:	0a c0       	rjmp	.+20     	; 0x112a <vTaskDelayUntil+0x80>
    1116:	38 da       	rcall	.-2960   	; 0x588 <vPortYield>
    1118:	08 c0       	rjmp	.+16     	; 0x112a <vTaskDelayUntil+0x80>
    111a:	f8 01       	movw	r30, r16
    111c:	d1 83       	std	Z+1, r29	; 0x01
    111e:	c0 83       	st	Z, r28
    1120:	ef cf       	rjmp	.-34     	; 0x1100 <vTaskDelayUntil+0x56>
    1122:	f8 01       	movw	r30, r16
    1124:	d1 83       	std	Z+1, r29	; 0x01
    1126:	c0 83       	st	Z, r28
    1128:	f3 cf       	rjmp	.-26     	; 0x1110 <vTaskDelayUntil+0x66>
    112a:	df 91       	pop	r29
    112c:	cf 91       	pop	r28
    112e:	1f 91       	pop	r17
    1130:	0f 91       	pop	r16
    1132:	08 95       	ret

00001134 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    1134:	80 91 0b 08 	lds	r24, 0x080B	; 0x80080b <uxSchedulerSuspended>
    1138:	81 11       	cpse	r24, r1
    113a:	13 c0       	rjmp	.+38     	; 0x1162 <vTaskSwitchContext+0x2e>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    113c:	80 91 0d 08 	lds	r24, 0x080D	; 0x80080d <uxTopReadyPriority>
    1140:	90 e0       	ldi	r25, 0x00	; 0
    1142:	fc 01       	movw	r30, r24
    1144:	ee 0f       	add	r30, r30
    1146:	ff 1f       	adc	r31, r31
    1148:	ee 0f       	add	r30, r30
    114a:	ff 1f       	adc	r31, r31
    114c:	ee 0f       	add	r30, r30
    114e:	ff 1f       	adc	r31, r31
    1150:	8e 0f       	add	r24, r30
    1152:	9f 1f       	adc	r25, r31
    1154:	fc 01       	movw	r30, r24
    1156:	ef 5c       	subi	r30, 0xCF	; 207
    1158:	f7 4f       	sbci	r31, 0xF7	; 247
    115a:	80 81       	ld	r24, Z
    115c:	88 23       	and	r24, r24
    115e:	29 f0       	breq	.+10     	; 0x116a <vTaskSwitchContext+0x36>
    1160:	1b c0       	rjmp	.+54     	; 0x1198 <vTaskSwitchContext+0x64>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    1162:	81 e0       	ldi	r24, 0x01	; 1
    1164:	80 93 09 08 	sts	0x0809, r24	; 0x800809 <xMissedYield>
    1168:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    116a:	80 91 0d 08 	lds	r24, 0x080D	; 0x80080d <uxTopReadyPriority>
    116e:	81 50       	subi	r24, 0x01	; 1
    1170:	80 93 0d 08 	sts	0x080D, r24	; 0x80080d <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    1174:	80 91 0d 08 	lds	r24, 0x080D	; 0x80080d <uxTopReadyPriority>
    1178:	90 e0       	ldi	r25, 0x00	; 0
    117a:	fc 01       	movw	r30, r24
    117c:	ee 0f       	add	r30, r30
    117e:	ff 1f       	adc	r31, r31
    1180:	ee 0f       	add	r30, r30
    1182:	ff 1f       	adc	r31, r31
    1184:	ee 0f       	add	r30, r30
    1186:	ff 1f       	adc	r31, r31
    1188:	8e 0f       	add	r24, r30
    118a:	9f 1f       	adc	r25, r31
    118c:	fc 01       	movw	r30, r24
    118e:	ef 5c       	subi	r30, 0xCF	; 207
    1190:	f7 4f       	sbci	r31, 0xF7	; 247
    1192:	80 81       	ld	r24, Z
    1194:	88 23       	and	r24, r24
    1196:	49 f3       	breq	.-46     	; 0x116a <vTaskSwitchContext+0x36>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    1198:	80 91 0d 08 	lds	r24, 0x080D	; 0x80080d <uxTopReadyPriority>
    119c:	90 e0       	ldi	r25, 0x00	; 0
    119e:	9c 01       	movw	r18, r24
    11a0:	22 0f       	add	r18, r18
    11a2:	33 1f       	adc	r19, r19
    11a4:	22 0f       	add	r18, r18
    11a6:	33 1f       	adc	r19, r19
    11a8:	22 0f       	add	r18, r18
    11aa:	33 1f       	adc	r19, r19
    11ac:	28 0f       	add	r18, r24
    11ae:	39 1f       	adc	r19, r25
    11b0:	d9 01       	movw	r26, r18
    11b2:	af 5c       	subi	r26, 0xCF	; 207
    11b4:	b7 4f       	sbci	r27, 0xF7	; 247
    11b6:	11 96       	adiw	r26, 0x01	; 1
    11b8:	ed 91       	ld	r30, X+
    11ba:	fc 91       	ld	r31, X
    11bc:	12 97       	sbiw	r26, 0x02	; 2
    11be:	02 80       	ldd	r0, Z+2	; 0x02
    11c0:	f3 81       	ldd	r31, Z+3	; 0x03
    11c2:	e0 2d       	mov	r30, r0
    11c4:	12 96       	adiw	r26, 0x02	; 2
    11c6:	fc 93       	st	X, r31
    11c8:	ee 93       	st	-X, r30
    11ca:	11 97       	sbiw	r26, 0x01	; 1
    11cc:	2c 5c       	subi	r18, 0xCC	; 204
    11ce:	37 4f       	sbci	r19, 0xF7	; 247
    11d0:	e2 17       	cp	r30, r18
    11d2:	f3 07       	cpc	r31, r19
    11d4:	29 f4       	brne	.+10     	; 0x11e0 <vTaskSwitchContext+0xac>
    11d6:	22 81       	ldd	r18, Z+2	; 0x02
    11d8:	33 81       	ldd	r19, Z+3	; 0x03
    11da:	fd 01       	movw	r30, r26
    11dc:	32 83       	std	Z+2, r19	; 0x02
    11de:	21 83       	std	Z+1, r18	; 0x01
    11e0:	fc 01       	movw	r30, r24
    11e2:	ee 0f       	add	r30, r30
    11e4:	ff 1f       	adc	r31, r31
    11e6:	ee 0f       	add	r30, r30
    11e8:	ff 1f       	adc	r31, r31
    11ea:	ee 0f       	add	r30, r30
    11ec:	ff 1f       	adc	r31, r31
    11ee:	8e 0f       	add	r24, r30
    11f0:	9f 1f       	adc	r25, r31
    11f2:	fc 01       	movw	r30, r24
    11f4:	ef 5c       	subi	r30, 0xCF	; 207
    11f6:	f7 4f       	sbci	r31, 0xF7	; 247
    11f8:	01 80       	ldd	r0, Z+1	; 0x01
    11fa:	f2 81       	ldd	r31, Z+2	; 0x02
    11fc:	e0 2d       	mov	r30, r0
    11fe:	86 81       	ldd	r24, Z+6	; 0x06
    1200:	97 81       	ldd	r25, Z+7	; 0x07
    1202:	90 93 3b 08 	sts	0x083B, r25	; 0x80083b <pxCurrentTCB+0x1>
    1206:	80 93 3a 08 	sts	0x083A, r24	; 0x80083a <pxCurrentTCB>
    120a:	08 95       	ret

0000120c <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    120c:	cf 93       	push	r28
    120e:	df 93       	push	r29
    1210:	eb 01       	movw	r28, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    1212:	60 91 3a 08 	lds	r22, 0x083A	; 0x80083a <pxCurrentTCB>
    1216:	70 91 3b 08 	lds	r23, 0x083B	; 0x80083b <pxCurrentTCB+0x1>
    121a:	64 5f       	subi	r22, 0xF4	; 244
    121c:	7f 4f       	sbci	r23, 0xFF	; 255
    121e:	a3 d8       	rcall	.-3770   	; 0x366 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1220:	80 91 3a 08 	lds	r24, 0x083A	; 0x80083a <pxCurrentTCB>
    1224:	90 91 3b 08 	lds	r25, 0x083B	; 0x80083b <pxCurrentTCB+0x1>
    1228:	02 96       	adiw	r24, 0x02	; 2
    122a:	d8 d8       	rcall	.-3664   	; 0x3dc <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    122c:	80 91 0f 08 	lds	r24, 0x080F	; 0x80080f <xTickCount>
    1230:	90 91 10 08 	lds	r25, 0x0810	; 0x800810 <xTickCount+0x1>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    1234:	8c 0f       	add	r24, r28
    1236:	9d 1f       	adc	r25, r29
    1238:	a7 dc       	rcall	.-1714   	; 0xb88 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    123a:	df 91       	pop	r29
    123c:	cf 91       	pop	r28
    123e:	08 95       	ret

00001240 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    1240:	0f 93       	push	r16
    1242:	1f 93       	push	r17
    1244:	cf 93       	push	r28
    1246:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1248:	dc 01       	movw	r26, r24
    124a:	15 96       	adiw	r26, 0x05	; 5
    124c:	ed 91       	ld	r30, X+
    124e:	fc 91       	ld	r31, X
    1250:	16 97       	sbiw	r26, 0x06	; 6
    1252:	c6 81       	ldd	r28, Z+6	; 0x06
    1254:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    1256:	8e 01       	movw	r16, r28
    1258:	04 5f       	subi	r16, 0xF4	; 244
    125a:	1f 4f       	sbci	r17, 0xFF	; 255
    125c:	c8 01       	movw	r24, r16
    125e:	be d8       	rcall	.-3716   	; 0x3dc <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1260:	80 91 0b 08 	lds	r24, 0x080B	; 0x80080b <uxSchedulerSuspended>
    1264:	81 11       	cpse	r24, r1
    1266:	1a c0       	rjmp	.+52     	; 0x129c <xTaskRemoveFromEventList+0x5c>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    1268:	0a 50       	subi	r16, 0x0A	; 10
    126a:	11 09       	sbc	r17, r1
    126c:	c8 01       	movw	r24, r16
    126e:	b6 d8       	rcall	.-3732   	; 0x3dc <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    1270:	8e 89       	ldd	r24, Y+22	; 0x16
    1272:	90 91 0d 08 	lds	r25, 0x080D	; 0x80080d <uxTopReadyPriority>
    1276:	98 17       	cp	r25, r24
    1278:	10 f4       	brcc	.+4      	; 0x127e <xTaskRemoveFromEventList+0x3e>
    127a:	80 93 0d 08 	sts	0x080D, r24	; 0x80080d <uxTopReadyPriority>
    127e:	90 e0       	ldi	r25, 0x00	; 0
    1280:	9c 01       	movw	r18, r24
    1282:	22 0f       	add	r18, r18
    1284:	33 1f       	adc	r19, r19
    1286:	22 0f       	add	r18, r18
    1288:	33 1f       	adc	r19, r19
    128a:	22 0f       	add	r18, r18
    128c:	33 1f       	adc	r19, r19
    128e:	82 0f       	add	r24, r18
    1290:	93 1f       	adc	r25, r19
    1292:	b8 01       	movw	r22, r16
    1294:	8f 5c       	subi	r24, 0xCF	; 207
    1296:	97 4f       	sbci	r25, 0xF7	; 247
    1298:	3f d8       	rcall	.-3970   	; 0x318 <vListInsertEnd>
    129a:	04 c0       	rjmp	.+8      	; 0x12a4 <xTaskRemoveFromEventList+0x64>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    129c:	b8 01       	movw	r22, r16
    129e:	82 e1       	ldi	r24, 0x12	; 18
    12a0:	98 e0       	ldi	r25, 0x08	; 8
    12a2:	3a d8       	rcall	.-3980   	; 0x318 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    12a4:	e0 91 3a 08 	lds	r30, 0x083A	; 0x80083a <pxCurrentTCB>
    12a8:	f0 91 3b 08 	lds	r31, 0x083B	; 0x80083b <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    12ac:	81 e0       	ldi	r24, 0x01	; 1
    12ae:	2e 89       	ldd	r18, Y+22	; 0x16
    12b0:	96 89       	ldd	r25, Z+22	; 0x16
    12b2:	29 17       	cp	r18, r25
    12b4:	08 f4       	brcc	.+2      	; 0x12b8 <xTaskRemoveFromEventList+0x78>
    12b6:	80 e0       	ldi	r24, 0x00	; 0
}
    12b8:	df 91       	pop	r29
    12ba:	cf 91       	pop	r28
    12bc:	1f 91       	pop	r17
    12be:	0f 91       	pop	r16
    12c0:	08 95       	ret

000012c2 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    12c2:	20 91 08 08 	lds	r18, 0x0808	; 0x800808 <xNumOfOverflows>
    12c6:	fc 01       	movw	r30, r24
    12c8:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    12ca:	20 91 0f 08 	lds	r18, 0x080F	; 0x80080f <xTickCount>
    12ce:	30 91 10 08 	lds	r19, 0x0810	; 0x800810 <xTickCount+0x1>
    12d2:	32 83       	std	Z+2, r19	; 0x02
    12d4:	21 83       	std	Z+1, r18	; 0x01
    12d6:	08 95       	ret

000012d8 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    12d8:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    12da:	0f b6       	in	r0, 0x3f	; 63
    12dc:	f8 94       	cli
    12de:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    12e0:	80 91 08 08 	lds	r24, 0x0808	; 0x800808 <xNumOfOverflows>
    12e4:	90 81       	ld	r25, Z
    12e6:	98 17       	cp	r25, r24
    12e8:	49 f0       	breq	.+18     	; 0x12fc <xTaskCheckForTimeOut+0x24>
    12ea:	80 91 0f 08 	lds	r24, 0x080F	; 0x80080f <xTickCount>
    12ee:	90 91 10 08 	lds	r25, 0x0810	; 0x800810 <xTickCount+0x1>
    12f2:	21 81       	ldd	r18, Z+1	; 0x01
    12f4:	32 81       	ldd	r19, Z+2	; 0x02
    12f6:	82 17       	cp	r24, r18
    12f8:	93 07       	cpc	r25, r19
    12fa:	f0 f4       	brcc	.+60     	; 0x1338 <xTaskCheckForTimeOut+0x60>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    12fc:	80 91 0f 08 	lds	r24, 0x080F	; 0x80080f <xTickCount>
    1300:	90 91 10 08 	lds	r25, 0x0810	; 0x800810 <xTickCount+0x1>
    1304:	41 81       	ldd	r20, Z+1	; 0x01
    1306:	52 81       	ldd	r21, Z+2	; 0x02
    1308:	db 01       	movw	r26, r22
    130a:	2d 91       	ld	r18, X+
    130c:	3c 91       	ld	r19, X
    130e:	11 97       	sbiw	r26, 0x01	; 1
    1310:	84 1b       	sub	r24, r20
    1312:	95 0b       	sbc	r25, r21
    1314:	82 17       	cp	r24, r18
    1316:	93 07       	cpc	r25, r19
    1318:	88 f4       	brcc	.+34     	; 0x133c <xTaskCheckForTimeOut+0x64>
    131a:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    131c:	e0 91 0f 08 	lds	r30, 0x080F	; 0x80080f <xTickCount>
    1320:	f0 91 10 08 	lds	r31, 0x0810	; 0x800810 <xTickCount+0x1>
    1324:	bf 01       	movw	r22, r30
    1326:	64 1b       	sub	r22, r20
    1328:	75 0b       	sbc	r23, r21
    132a:	26 1b       	sub	r18, r22
    132c:	37 0b       	sbc	r19, r23
    132e:	2d 93       	st	X+, r18
    1330:	3c 93       	st	X, r19
			vTaskSetTimeOutState( pxTimeOut );
    1332:	c7 df       	rcall	.-114    	; 0x12c2 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    1334:	80 e0       	ldi	r24, 0x00	; 0
    1336:	03 c0       	rjmp	.+6      	; 0x133e <xTaskCheckForTimeOut+0x66>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    1338:	81 e0       	ldi	r24, 0x01	; 1
    133a:	01 c0       	rjmp	.+2      	; 0x133e <xTaskCheckForTimeOut+0x66>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    133c:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    133e:	0f 90       	pop	r0
    1340:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    1342:	08 95       	ret

00001344 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    1344:	81 e0       	ldi	r24, 0x01	; 1
    1346:	80 93 09 08 	sts	0x0809, r24	; 0x800809 <xMissedYield>
    134a:	08 95       	ret

0000134c <__udivmodsi4>:
    134c:	a1 e2       	ldi	r26, 0x21	; 33
    134e:	1a 2e       	mov	r1, r26
    1350:	aa 1b       	sub	r26, r26
    1352:	bb 1b       	sub	r27, r27
    1354:	fd 01       	movw	r30, r26
    1356:	0d c0       	rjmp	.+26     	; 0x1372 <__udivmodsi4_ep>

00001358 <__udivmodsi4_loop>:
    1358:	aa 1f       	adc	r26, r26
    135a:	bb 1f       	adc	r27, r27
    135c:	ee 1f       	adc	r30, r30
    135e:	ff 1f       	adc	r31, r31
    1360:	a2 17       	cp	r26, r18
    1362:	b3 07       	cpc	r27, r19
    1364:	e4 07       	cpc	r30, r20
    1366:	f5 07       	cpc	r31, r21
    1368:	20 f0       	brcs	.+8      	; 0x1372 <__udivmodsi4_ep>
    136a:	a2 1b       	sub	r26, r18
    136c:	b3 0b       	sbc	r27, r19
    136e:	e4 0b       	sbc	r30, r20
    1370:	f5 0b       	sbc	r31, r21

00001372 <__udivmodsi4_ep>:
    1372:	66 1f       	adc	r22, r22
    1374:	77 1f       	adc	r23, r23
    1376:	88 1f       	adc	r24, r24
    1378:	99 1f       	adc	r25, r25
    137a:	1a 94       	dec	r1
    137c:	69 f7       	brne	.-38     	; 0x1358 <__udivmodsi4_loop>
    137e:	60 95       	com	r22
    1380:	70 95       	com	r23
    1382:	80 95       	com	r24
    1384:	90 95       	com	r25
    1386:	9b 01       	movw	r18, r22
    1388:	ac 01       	movw	r20, r24
    138a:	bd 01       	movw	r22, r26
    138c:	cf 01       	movw	r24, r30
    138e:	08 95       	ret

00001390 <memcpy>:
    1390:	fb 01       	movw	r30, r22
    1392:	dc 01       	movw	r26, r24
    1394:	02 c0       	rjmp	.+4      	; 0x139a <memcpy+0xa>
    1396:	01 90       	ld	r0, Z+
    1398:	0d 92       	st	X+, r0
    139a:	41 50       	subi	r20, 0x01	; 1
    139c:	50 40       	sbci	r21, 0x00	; 0
    139e:	d8 f7       	brcc	.-10     	; 0x1396 <memcpy+0x6>
    13a0:	08 95       	ret

000013a2 <memset>:
    13a2:	dc 01       	movw	r26, r24
    13a4:	01 c0       	rjmp	.+2      	; 0x13a8 <memset+0x6>
    13a6:	6d 93       	st	X+, r22
    13a8:	41 50       	subi	r20, 0x01	; 1
    13aa:	50 40       	sbci	r21, 0x00	; 0
    13ac:	e0 f7       	brcc	.-8      	; 0x13a6 <memset+0x4>
    13ae:	08 95       	ret

000013b0 <strncpy>:
    13b0:	fb 01       	movw	r30, r22
    13b2:	dc 01       	movw	r26, r24
    13b4:	41 50       	subi	r20, 0x01	; 1
    13b6:	50 40       	sbci	r21, 0x00	; 0
    13b8:	48 f0       	brcs	.+18     	; 0x13cc <strncpy+0x1c>
    13ba:	01 90       	ld	r0, Z+
    13bc:	0d 92       	st	X+, r0
    13be:	00 20       	and	r0, r0
    13c0:	c9 f7       	brne	.-14     	; 0x13b4 <strncpy+0x4>
    13c2:	01 c0       	rjmp	.+2      	; 0x13c6 <strncpy+0x16>
    13c4:	1d 92       	st	X+, r1
    13c6:	41 50       	subi	r20, 0x01	; 1
    13c8:	50 40       	sbci	r21, 0x00	; 0
    13ca:	e0 f7       	brcc	.-8      	; 0x13c4 <strncpy+0x14>
    13cc:	08 95       	ret

000013ce <_exit>:
    13ce:	f8 94       	cli

000013d0 <__stop_program>:
    13d0:	ff cf       	rjmp	.-2      	; 0x13d0 <__stop_program>
