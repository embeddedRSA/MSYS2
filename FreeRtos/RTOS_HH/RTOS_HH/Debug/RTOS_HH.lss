
RTOS_HH.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000022  00800200  000013f2  00001486  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000013f2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000615  00800222  00800222  000014a8  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000014a8  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000014d8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000002a8  00000000  00000000  00001518  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000375d  00000000  00000000  000017c0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000015fb  00000000  00000000  00004f1d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000017c1  00000000  00000000  00006518  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000006b8  00000000  00000000  00007cdc  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001142  00000000  00000000  00008394  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001fa0  00000000  00000000  000094d6  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000270  00000000  00000000  0000b476  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	71 c0       	rjmp	.+226    	; 0xe4 <__ctors_end>
       2:	00 00       	nop
       4:	8f c0       	rjmp	.+286    	; 0x124 <__bad_interrupt>
       6:	00 00       	nop
       8:	8d c0       	rjmp	.+282    	; 0x124 <__bad_interrupt>
       a:	00 00       	nop
       c:	8b c0       	rjmp	.+278    	; 0x124 <__bad_interrupt>
       e:	00 00       	nop
      10:	89 c0       	rjmp	.+274    	; 0x124 <__bad_interrupt>
      12:	00 00       	nop
      14:	87 c0       	rjmp	.+270    	; 0x124 <__bad_interrupt>
      16:	00 00       	nop
      18:	85 c0       	rjmp	.+266    	; 0x124 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	83 c0       	rjmp	.+262    	; 0x124 <__bad_interrupt>
      1e:	00 00       	nop
      20:	81 c0       	rjmp	.+258    	; 0x124 <__bad_interrupt>
      22:	00 00       	nop
      24:	7f c0       	rjmp	.+254    	; 0x124 <__bad_interrupt>
      26:	00 00       	nop
      28:	7d c0       	rjmp	.+250    	; 0x124 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	7b c0       	rjmp	.+246    	; 0x124 <__bad_interrupt>
      2e:	00 00       	nop
      30:	79 c0       	rjmp	.+242    	; 0x124 <__bad_interrupt>
      32:	00 00       	nop
      34:	77 c0       	rjmp	.+238    	; 0x124 <__bad_interrupt>
      36:	00 00       	nop
      38:	75 c0       	rjmp	.+234    	; 0x124 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	73 c0       	rjmp	.+230    	; 0x124 <__bad_interrupt>
      3e:	00 00       	nop
      40:	71 c0       	rjmp	.+226    	; 0x124 <__bad_interrupt>
      42:	00 00       	nop
      44:	6f c0       	rjmp	.+222    	; 0x124 <__bad_interrupt>
      46:	00 00       	nop
      48:	6d c0       	rjmp	.+218    	; 0x124 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	6b c0       	rjmp	.+214    	; 0x124 <__bad_interrupt>
      4e:	00 00       	nop
      50:	69 c0       	rjmp	.+210    	; 0x124 <__bad_interrupt>
      52:	00 00       	nop
      54:	67 c0       	rjmp	.+206    	; 0x124 <__bad_interrupt>
      56:	00 00       	nop
      58:	65 c0       	rjmp	.+202    	; 0x124 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	63 c0       	rjmp	.+198    	; 0x124 <__bad_interrupt>
      5e:	00 00       	nop
      60:	61 c0       	rjmp	.+194    	; 0x124 <__bad_interrupt>
      62:	00 00       	nop
      64:	5f c0       	rjmp	.+190    	; 0x124 <__bad_interrupt>
      66:	00 00       	nop
      68:	5d c0       	rjmp	.+186    	; 0x124 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	5b c0       	rjmp	.+182    	; 0x124 <__bad_interrupt>
      6e:	00 00       	nop
      70:	59 c0       	rjmp	.+178    	; 0x124 <__bad_interrupt>
      72:	00 00       	nop
      74:	57 c0       	rjmp	.+174    	; 0x124 <__bad_interrupt>
      76:	00 00       	nop
      78:	55 c0       	rjmp	.+170    	; 0x124 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	53 c0       	rjmp	.+166    	; 0x124 <__bad_interrupt>
      7e:	00 00       	nop
      80:	51 c0       	rjmp	.+162    	; 0x124 <__bad_interrupt>
      82:	00 00       	nop
      84:	4f c0       	rjmp	.+158    	; 0x124 <__bad_interrupt>
      86:	00 00       	nop
      88:	4d c0       	rjmp	.+154    	; 0x124 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	4b c0       	rjmp	.+150    	; 0x124 <__bad_interrupt>
      8e:	00 00       	nop
      90:	49 c0       	rjmp	.+146    	; 0x124 <__bad_interrupt>
      92:	00 00       	nop
      94:	47 c0       	rjmp	.+142    	; 0x124 <__bad_interrupt>
      96:	00 00       	nop
      98:	45 c0       	rjmp	.+138    	; 0x124 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	43 c0       	rjmp	.+134    	; 0x124 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	41 c0       	rjmp	.+130    	; 0x124 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	3f c0       	rjmp	.+126    	; 0x124 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	3d c0       	rjmp	.+122    	; 0x124 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	3b c0       	rjmp	.+118    	; 0x124 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	39 c0       	rjmp	.+114    	; 0x124 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	37 c0       	rjmp	.+110    	; 0x124 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	35 c0       	rjmp	.+106    	; 0x124 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	58 c3       	rjmp	.+1712   	; 0x76e <__vector_47>
      be:	00 00       	nop
      c0:	31 c0       	rjmp	.+98     	; 0x124 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	2f c0       	rjmp	.+94     	; 0x124 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	2d c0       	rjmp	.+90     	; 0x124 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	2b c0       	rjmp	.+86     	; 0x124 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	29 c0       	rjmp	.+82     	; 0x124 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	27 c0       	rjmp	.+78     	; 0x124 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	25 c0       	rjmp	.+74     	; 0x124 <__bad_interrupt>
      da:	00 00       	nop
      dc:	23 c0       	rjmp	.+70     	; 0x124 <__bad_interrupt>
      de:	00 00       	nop
      e0:	21 c0       	rjmp	.+66     	; 0x124 <__bad_interrupt>
	...

000000e4 <__ctors_end>:
      e4:	11 24       	eor	r1, r1
      e6:	1f be       	out	0x3f, r1	; 63
      e8:	cf ef       	ldi	r28, 0xFF	; 255
      ea:	d1 e2       	ldi	r29, 0x21	; 33
      ec:	de bf       	out	0x3e, r29	; 62
      ee:	cd bf       	out	0x3d, r28	; 61
      f0:	00 e0       	ldi	r16, 0x00	; 0
      f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
      f4:	12 e0       	ldi	r17, 0x02	; 2
      f6:	a0 e0       	ldi	r26, 0x00	; 0
      f8:	b2 e0       	ldi	r27, 0x02	; 2
      fa:	e2 ef       	ldi	r30, 0xF2	; 242
      fc:	f3 e1       	ldi	r31, 0x13	; 19
      fe:	00 e0       	ldi	r16, 0x00	; 0
     100:	0b bf       	out	0x3b, r16	; 59
     102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
     104:	07 90       	elpm	r0, Z+
     106:	0d 92       	st	X+, r0
     108:	a2 32       	cpi	r26, 0x22	; 34
     10a:	b1 07       	cpc	r27, r17
     10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>

0000010e <__do_clear_bss>:
     10e:	28 e0       	ldi	r18, 0x08	; 8
     110:	a2 e2       	ldi	r26, 0x22	; 34
     112:	b2 e0       	ldi	r27, 0x02	; 2
     114:	01 c0       	rjmp	.+2      	; 0x118 <.do_clear_bss_start>

00000116 <.do_clear_bss_loop>:
     116:	1d 92       	st	X+, r1

00000118 <.do_clear_bss_start>:
     118:	a7 33       	cpi	r26, 0x37	; 55
     11a:	b2 07       	cpc	r27, r18
     11c:	e1 f7       	brne	.-8      	; 0x116 <.do_clear_bss_loop>
     11e:	d4 d0       	rcall	.+424    	; 0x2c8 <main>
     120:	0c 94 f7 09 	jmp	0x13ee	; 0x13ee <_exit>

00000124 <__bad_interrupt>:
     124:	6d cf       	rjmp	.-294    	; 0x0 <__vectors>

00000126 <initLEDport>:
}

void writeAllLEDs(unsigned char pattern)
{
  // Hent parameteren og skriv til lysdioderne
  PORTB = pattern;   
     126:	8f ef       	ldi	r24, 0xFF	; 255
     128:	84 b9       	out	0x04, r24	; 4
     12a:	15 b8       	out	0x05, r1	; 5
     12c:	08 95       	ret

0000012e <turnOnLED>:
void turnOnLED(unsigned char led_nr)
{
// Lokal variabel
unsigned char mask;
  // Vi skal kun lave noget, hvis led_nr < 8
  if (led_nr <= MAX_LED_NR)
     12e:	88 30       	cpi	r24, 0x08	; 8
     130:	60 f4       	brcc	.+24     	; 0x14a <turnOnLED+0x1c>
  {
    // Dan maske på basis af parameteren (led_nr)
    mask = 0b00000001 << led_nr;
    // Tænd den aktuelle lysdiode (de andre ændres ikke)
    PORTB = PINB | mask;
     132:	43 b1       	in	r20, 0x03	; 3
     134:	21 e0       	ldi	r18, 0x01	; 1
     136:	30 e0       	ldi	r19, 0x00	; 0
     138:	b9 01       	movw	r22, r18
     13a:	02 c0       	rjmp	.+4      	; 0x140 <turnOnLED+0x12>
     13c:	66 0f       	add	r22, r22
     13e:	77 1f       	adc	r23, r23
     140:	8a 95       	dec	r24
     142:	e2 f7       	brpl	.-8      	; 0x13c <turnOnLED+0xe>
     144:	cb 01       	movw	r24, r22
     146:	84 2b       	or	r24, r20
     148:	85 b9       	out	0x05, r24	; 5
     14a:	08 95       	ret

0000014c <turnOffLED>:
void turnOffLED(unsigned char led_nr)
{
  // Lokal variabel
  unsigned char mask;
  // Vi skal kun lave noget, hvis led_nr < 8
  if (led_nr <= MAX_LED_NR)
     14c:	88 30       	cpi	r24, 0x08	; 8
     14e:	68 f4       	brcc	.+26     	; 0x16a <turnOffLED+0x1e>
  {
	// Dan (inverteret) maske på basis af parameteren (led_nr)
    mask = ~(0b00000001 << led_nr);
    // Sluk den aktuelle lysdiode (de andre ændres ikke)
    PORTB = PINB & mask;
     150:	43 b1       	in	r20, 0x03	; 3
     152:	21 e0       	ldi	r18, 0x01	; 1
     154:	30 e0       	ldi	r19, 0x00	; 0
     156:	b9 01       	movw	r22, r18
     158:	02 c0       	rjmp	.+4      	; 0x15e <turnOffLED+0x12>
     15a:	66 0f       	add	r22, r22
     15c:	77 1f       	adc	r23, r23
     15e:	8a 95       	dec	r24
     160:	e2 f7       	brpl	.-8      	; 0x15a <turnOffLED+0xe>
     162:	cb 01       	movw	r24, r22
     164:	80 95       	com	r24
     166:	84 23       	and	r24, r20
     168:	85 b9       	out	0x05, r24	; 5
     16a:	08 95       	ret

0000016c <toggleLED>:
void toggleLED(unsigned char led_nr)
{
  // Lokal variabel
  unsigned char mask;
  // Vi skal kun lave noget, hvis led_nr < 8
  if (led_nr <= MAX_LED_NR)
     16c:	88 30       	cpi	r24, 0x08	; 8
     16e:	60 f4       	brcc	.+24     	; 0x188 <toggleLED+0x1c>
  {
    // Dan maske på basis af parameteren (led_nr)
    mask = 0b00000001 << led_nr;
    // Toggle den aktuelle lysdiode (de andre ændres ikke)
    PORTB = PINB ^ mask;
     170:	43 b1       	in	r20, 0x03	; 3
     172:	21 e0       	ldi	r18, 0x01	; 1
     174:	30 e0       	ldi	r19, 0x00	; 0
     176:	b9 01       	movw	r22, r18
     178:	02 c0       	rjmp	.+4      	; 0x17e <toggleLED+0x12>
     17a:	66 0f       	add	r22, r22
     17c:	77 1f       	adc	r23, r23
     17e:	8a 95       	dec	r24
     180:	e2 f7       	brpl	.-8      	; 0x17a <toggleLED+0xe>
     182:	cb 01       	movw	r24, r22
     184:	84 27       	eor	r24, r20
     186:	85 b9       	out	0x05, r24	; 5
     188:	08 95       	ret

0000018a <initSwitchPort>:

// Læser alle switches samtidigt
unsigned char switchStatus()
{
  return (~PINA);
}
     18a:	11 b8       	out	0x01, r1	; 1
     18c:	08 95       	ret

0000018e <switchOn>:
// Returnerer TRUE, hvis switchen med nummeret
// "switch_nr" er aktiveret - ellers returneres FALSE
unsigned char switchOn(unsigned char switch_nr)
{
unsigned char mask;
  if (switch_nr <= MAX_SWITCH_NR)
     18e:	88 30       	cpi	r24, 0x08	; 8
     190:	70 f4       	brcc	.+28     	; 0x1ae <switchOn+0x20>
  {
    mask = 0b00000001 << switch_nr;
    return (~PINA & mask);
     192:	90 b1       	in	r25, 0x00	; 0
     194:	49 2f       	mov	r20, r25
     196:	40 95       	com	r20
     198:	21 e0       	ldi	r18, 0x01	; 1
     19a:	30 e0       	ldi	r19, 0x00	; 0
     19c:	b9 01       	movw	r22, r18
     19e:	02 c0       	rjmp	.+4      	; 0x1a4 <switchOn+0x16>
     1a0:	66 0f       	add	r22, r22
     1a2:	77 1f       	adc	r23, r23
     1a4:	8a 95       	dec	r24
     1a6:	e2 f7       	brpl	.-8      	; 0x1a0 <switchOn+0x12>
     1a8:	cb 01       	movw	r24, r22
     1aa:	84 23       	and	r24, r20
     1ac:	08 95       	ret
  }
  else
    return 0;
     1ae:	80 e0       	ldi	r24, 0x00	; 0
     1b0:	08 95       	ret

000001b2 <vLEDFlashTask1>:

xSemaphoreHandle xSemaphore1 = NULL;


void vLEDFlashTask1( void *pvParameters )
{
     1b2:	cf 93       	push	r28
     1b4:	df 93       	push	r29
     1b6:	1f 92       	push	r1
     1b8:	1f 92       	push	r1
     1ba:	cd b7       	in	r28, 0x3d	; 61
     1bc:	de b7       	in	r29, 0x3e	; 62
portTickType xLastWakeTime;
xLastWakeTime=xTaskGetTickCount();
     1be:	5b d6       	rcall	.+3254   	; 0xe76 <xTaskGetTickCount>
     1c0:	9a 83       	std	Y+2, r25	; 0x02
     1c2:	89 83       	std	Y+1, r24	; 0x01
  while(1)
  {
    toggleLED(0);
     1c4:	80 e0       	ldi	r24, 0x00	; 0
     1c6:	d2 df       	rcall	.-92     	; 0x16c <toggleLED>
    vTaskDelayUntil(&xLastWakeTime,1000);
     1c8:	68 ee       	ldi	r22, 0xE8	; 232
     1ca:	73 e0       	ldi	r23, 0x03	; 3
     1cc:	ce 01       	movw	r24, r28
     1ce:	01 96       	adiw	r24, 0x01	; 1
     1d0:	9e d7       	rcall	.+3900   	; 0x110e <vTaskDelayUntil>
     1d2:	f8 cf       	rjmp	.-16     	; 0x1c4 <vLEDFlashTask1+0x12>

000001d4 <vLEDFlashTask2>:
  }
}

void vLEDFlashTask2( void *pvParameters )
{
     1d4:	cf 93       	push	r28
     1d6:	df 93       	push	r29
     1d8:	1f 92       	push	r1
     1da:	1f 92       	push	r1
     1dc:	cd b7       	in	r28, 0x3d	; 61
     1de:	de b7       	in	r29, 0x3e	; 62
portTickType xLastWakeTime;
xLastWakeTime=xTaskGetTickCount();
     1e0:	4a d6       	rcall	.+3220   	; 0xe76 <xTaskGetTickCount>
     1e2:	9a 83       	std	Y+2, r25	; 0x02
     1e4:	89 83       	std	Y+1, r24	; 0x01
  while(1)
  {
    toggleLED(1);
     1e6:	81 e0       	ldi	r24, 0x01	; 1
     1e8:	c1 df       	rcall	.-126    	; 0x16c <toggleLED>
    vTaskDelayUntil(&xLastWakeTime,500);
     1ea:	64 ef       	ldi	r22, 0xF4	; 244
     1ec:	71 e0       	ldi	r23, 0x01	; 1
     1ee:	ce 01       	movw	r24, r28
     1f0:	01 96       	adiw	r24, 0x01	; 1
     1f2:	8d d7       	rcall	.+3866   	; 0x110e <vTaskDelayUntil>
     1f4:	f8 cf       	rjmp	.-16     	; 0x1e6 <vLEDFlashTask2+0x12>

000001f6 <vLEDToggle>:
void vLEDToggle( void *pvParameters )
{
	
	while(1)
	{
		if (switchOn(2))
     1f6:	82 e0       	ldi	r24, 0x02	; 2
     1f8:	90 e0       	ldi	r25, 0x00	; 0
     1fa:	c9 df       	rcall	.-110    	; 0x18e <switchOn>
     1fc:	89 2b       	or	r24, r25
     1fe:	19 f0       	breq	.+6      	; 0x206 <vLEDToggle+0x10>
		{
			turnOnLED(2);
     200:	82 e0       	ldi	r24, 0x02	; 2
     202:	95 df       	rcall	.-214    	; 0x12e <turnOnLED>
     204:	f8 cf       	rjmp	.-16     	; 0x1f6 <vLEDToggle>
		}
		else
		{
			turnOffLED(2);
     206:	82 e0       	ldi	r24, 0x02	; 2
     208:	a1 df       	rcall	.-190    	; 0x14c <turnOffLED>
     20a:	f5 cf       	rjmp	.-22     	; 0x1f6 <vLEDToggle>

0000020c <vGiveTakeSwitch>:
     20c:	20 e0       	ldi	r18, 0x00	; 0

void vGiveTakeSwitch( void *pvParameters )
{


xSemaphoreTake(xSemaphore1, 0);
     20e:	40 e0       	ldi	r20, 0x00	; 0
     210:	50 e0       	ldi	r21, 0x00	; 0
     212:	60 e0       	ldi	r22, 0x00	; 0
     214:	70 e0       	ldi	r23, 0x00	; 0
     216:	80 91 22 02 	lds	r24, 0x0222	; 0x800222 <__data_end>
     21a:	90 91 23 02 	lds	r25, 0x0223	; 0x800223 <__data_end+0x1>
     21e:	43 d4       	rcall	.+2182   	; 0xaa6 <xQueueGenericReceive>
while(1)
	{
		if (switchOn(7))
     220:	87 e0       	ldi	r24, 0x07	; 7
     222:	90 e0       	ldi	r25, 0x00	; 0
     224:	b4 df       	rcall	.-152    	; 0x18e <switchOn>
     226:	89 2b       	or	r24, r25
     228:	d9 f3       	breq	.-10     	; 0x220 <vGiveTakeSwitch+0x14>
		{
			xSemaphoreGive(xSemaphore1);
     22a:	20 e0       	ldi	r18, 0x00	; 0
     22c:	40 e0       	ldi	r20, 0x00	; 0
     22e:	50 e0       	ldi	r21, 0x00	; 0
     230:	60 e0       	ldi	r22, 0x00	; 0
     232:	70 e0       	ldi	r23, 0x00	; 0
     234:	80 91 22 02 	lds	r24, 0x0222	; 0x800222 <__data_end>
     238:	90 91 23 02 	lds	r25, 0x0223	; 0x800223 <__data_end+0x1>
     23c:	a8 d3       	rcall	.+1872   	; 0x98e <xQueueGenericSend>
			while (pdTRUE!=xSemaphoreTake(xSemaphore1, 0))
     23e:	20 e0       	ldi	r18, 0x00	; 0
     240:	40 e0       	ldi	r20, 0x00	; 0
     242:	50 e0       	ldi	r21, 0x00	; 0
     244:	60 e0       	ldi	r22, 0x00	; 0
     246:	70 e0       	ldi	r23, 0x00	; 0
     248:	80 91 22 02 	lds	r24, 0x0222	; 0x800222 <__data_end>
     24c:	90 91 23 02 	lds	r25, 0x0223	; 0x800223 <__data_end+0x1>
     250:	2a d4       	rcall	.+2132   	; 0xaa6 <xQueueGenericReceive>
     252:	81 30       	cpi	r24, 0x01	; 1
     254:	a1 f7       	brne	.-24     	; 0x23e <vGiveTakeSwitch+0x32>
     256:	e4 cf       	rjmp	.-56     	; 0x220 <vGiveTakeSwitch+0x14>

00000258 <vGiveTakeLED>:
	}

}

void vGiveTakeLED( void *pvParameters )
{
     258:	cf 93       	push	r28
     25a:	df 93       	push	r29
     25c:	1f 92       	push	r1
     25e:	1f 92       	push	r1
     260:	cd b7       	in	r28, 0x3d	; 61
     262:	de b7       	in	r29, 0x3e	; 62
	
	portTickType xLastWakeTime;
	xLastWakeTime=xTaskGetTickCount();
     264:	08 d6       	rcall	.+3088   	; 0xe76 <xTaskGetTickCount>
     266:	9a 83       	std	Y+2, r25	; 0x02
     268:	89 83       	std	Y+1, r24	; 0x01
	
	vTaskDelayUntil(&xLastWakeTime,50);
     26a:	62 e3       	ldi	r22, 0x32	; 50
     26c:	70 e0       	ldi	r23, 0x00	; 0
     26e:	ce 01       	movw	r24, r28
     270:	01 96       	adiw	r24, 0x01	; 1
     272:	4d d7       	rcall	.+3738   	; 0x110e <vTaskDelayUntil>
	int i = 0;
	while(1)
	{
		if (pdTRUE==xSemaphoreTake(xSemaphore1, 0))
     274:	20 e0       	ldi	r18, 0x00	; 0
     276:	40 e0       	ldi	r20, 0x00	; 0
     278:	50 e0       	ldi	r21, 0x00	; 0
     27a:	60 e0       	ldi	r22, 0x00	; 0
     27c:	70 e0       	ldi	r23, 0x00	; 0
     27e:	80 91 22 02 	lds	r24, 0x0222	; 0x800222 <__data_end>
     282:	90 91 23 02 	lds	r25, 0x0223	; 0x800223 <__data_end+0x1>
     286:	0f d4       	rcall	.+2078   	; 0xaa6 <xQueueGenericReceive>
     288:	81 30       	cpi	r24, 0x01	; 1
     28a:	a1 f7       	brne	.-24     	; 0x274 <vGiveTakeLED+0x1c>
     28c:	04 e1       	ldi	r16, 0x14	; 20
		{
		for (i=0; i<20; i++)
		{
			    turnOnLED(7);
     28e:	10 e0       	ldi	r17, 0x00	; 0
     290:	87 e0       	ldi	r24, 0x07	; 7
     292:	4d df       	rcall	.-358    	; 0x12e <turnOnLED>
			    vTaskDelayUntil(&xLastWakeTime,100);;
     294:	64 e6       	ldi	r22, 0x64	; 100
     296:	70 e0       	ldi	r23, 0x00	; 0
     298:	ce 01       	movw	r24, r28
     29a:	01 96       	adiw	r24, 0x01	; 1
				turnOffLED(7);
     29c:	38 d7       	rcall	.+3696   	; 0x110e <vTaskDelayUntil>
     29e:	87 e0       	ldi	r24, 0x07	; 7
				vTaskDelayUntil(&xLastWakeTime,100);;
     2a0:	55 df       	rcall	.-342    	; 0x14c <turnOffLED>
     2a2:	64 e6       	ldi	r22, 0x64	; 100
     2a4:	70 e0       	ldi	r23, 0x00	; 0
     2a6:	ce 01       	movw	r24, r28
     2a8:	01 96       	adiw	r24, 0x01	; 1
     2aa:	31 d7       	rcall	.+3682   	; 0x110e <vTaskDelayUntil>
     2ac:	01 50       	subi	r16, 0x01	; 1
     2ae:	11 09       	sbc	r17, r1
	int i = 0;
	while(1)
	{
		if (pdTRUE==xSemaphoreTake(xSemaphore1, 0))
		{
		for (i=0; i<20; i++)
     2b0:	79 f7       	brne	.-34     	; 0x290 <vGiveTakeLED+0x38>
			    turnOnLED(7);
			    vTaskDelayUntil(&xLastWakeTime,100);;
				turnOffLED(7);
				vTaskDelayUntil(&xLastWakeTime,100);;
		}
		xSemaphoreGive(xSemaphore1);
     2b2:	20 e0       	ldi	r18, 0x00	; 0
     2b4:	40 e0       	ldi	r20, 0x00	; 0
     2b6:	50 e0       	ldi	r21, 0x00	; 0
     2b8:	60 e0       	ldi	r22, 0x00	; 0
     2ba:	70 e0       	ldi	r23, 0x00	; 0
     2bc:	80 91 22 02 	lds	r24, 0x0222	; 0x800222 <__data_end>
     2c0:	90 91 23 02 	lds	r25, 0x0223	; 0x800223 <__data_end+0x1>
     2c4:	64 d3       	rcall	.+1736   	; 0x98e <xQueueGenericSend>
     2c6:	d6 cf       	rjmp	.-84     	; 0x274 <vGiveTakeLED+0x1c>

000002c8 <main>:



int main(void)
{
  initSwitchPort();
     2c8:	60 df       	rcall	.-320    	; 0x18a <initSwitchPort>
  initLEDport();
     2ca:	2d df       	rcall	.-422    	; 0x126 <initLEDport>
     2cc:	43 e0       	ldi	r20, 0x03	; 3
  
  vSemaphoreCreateBinary(xSemaphore1);
     2ce:	60 e0       	ldi	r22, 0x00	; 0
     2d0:	81 e0       	ldi	r24, 0x01	; 1
     2d2:	12 d3       	rcall	.+1572   	; 0x8f8 <xQueueGenericCreate>
     2d4:	90 93 23 02 	sts	0x0223, r25	; 0x800223 <__data_end+0x1>
     2d8:	80 93 22 02 	sts	0x0222, r24	; 0x800222 <__data_end>
     2dc:	00 97       	sbiw	r24, 0x00	; 0
     2de:	31 f0       	breq	.+12     	; 0x2ec <main+0x24>
     2e0:	20 e0       	ldi	r18, 0x00	; 0
     2e2:	40 e0       	ldi	r20, 0x00	; 0
     2e4:	50 e0       	ldi	r21, 0x00	; 0
     2e6:	60 e0       	ldi	r22, 0x00	; 0
     2e8:	70 e0       	ldi	r23, 0x00	; 0
     2ea:	51 d3       	rcall	.+1698   	; 0x98e <xQueueGenericSend>
     2ec:	a1 2c       	mov	r10, r1
  
  xTaskCreate( vLEDFlashTask1, ( signed char * ) "LED1", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
     2ee:	b1 2c       	mov	r11, r1
     2f0:	c1 2c       	mov	r12, r1
     2f2:	d1 2c       	mov	r13, r1
     2f4:	e1 2c       	mov	r14, r1
     2f6:	f1 2c       	mov	r15, r1
     2f8:	00 e0       	ldi	r16, 0x00	; 0
     2fa:	20 e0       	ldi	r18, 0x00	; 0
     2fc:	30 e0       	ldi	r19, 0x00	; 0
     2fe:	45 e5       	ldi	r20, 0x55	; 85
     300:	50 e0       	ldi	r21, 0x00	; 0
     302:	62 e0       	ldi	r22, 0x02	; 2
     304:	72 e0       	ldi	r23, 0x02	; 2
     306:	89 ed       	ldi	r24, 0xD9	; 217
     308:	90 e0       	ldi	r25, 0x00	; 0
     30a:	a5 d4       	rcall	.+2378   	; 0xc56 <xTaskGenericCreate>
     30c:	20 e0       	ldi	r18, 0x00	; 0
  xTaskCreate( vLEDFlashTask2, ( signed char * ) "LED2", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
     30e:	30 e0       	ldi	r19, 0x00	; 0
     310:	45 e5       	ldi	r20, 0x55	; 85
     312:	50 e0       	ldi	r21, 0x00	; 0
     314:	67 e0       	ldi	r22, 0x07	; 7
     316:	72 e0       	ldi	r23, 0x02	; 2
     318:	8a ee       	ldi	r24, 0xEA	; 234
     31a:	90 e0       	ldi	r25, 0x00	; 0
     31c:	9c d4       	rcall	.+2360   	; 0xc56 <xTaskGenericCreate>
     31e:	20 e0       	ldi	r18, 0x00	; 0
  xTaskCreate( vLEDToggle, ( signed char * ) "LED3", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
     320:	30 e0       	ldi	r19, 0x00	; 0
     322:	45 e5       	ldi	r20, 0x55	; 85
     324:	50 e0       	ldi	r21, 0x00	; 0
     326:	6c e0       	ldi	r22, 0x0C	; 12
     328:	72 e0       	ldi	r23, 0x02	; 2
     32a:	8b ef       	ldi	r24, 0xFB	; 251
     32c:	90 e0       	ldi	r25, 0x00	; 0
     32e:	93 d4       	rcall	.+2342   	; 0xc56 <xTaskGenericCreate>
     330:	20 e0       	ldi	r18, 0x00	; 0
	  
  xTaskCreate( vGiveTakeSwitch, ( signed char * ) "LED7", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );	
     332:	30 e0       	ldi	r19, 0x00	; 0
     334:	45 e5       	ldi	r20, 0x55	; 85
     336:	50 e0       	ldi	r21, 0x00	; 0
     338:	61 e1       	ldi	r22, 0x11	; 17
     33a:	72 e0       	ldi	r23, 0x02	; 2
     33c:	86 e0       	ldi	r24, 0x06	; 6
     33e:	91 e0       	ldi	r25, 0x01	; 1
     340:	8a d4       	rcall	.+2324   	; 0xc56 <xTaskGenericCreate>
     342:	20 e0       	ldi	r18, 0x00	; 0
  xTaskCreate( vGiveTakeLED, ( signed char * ) "Switch", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
     344:	30 e0       	ldi	r19, 0x00	; 0
     346:	45 e5       	ldi	r20, 0x55	; 85
     348:	50 e0       	ldi	r21, 0x00	; 0
     34a:	66 e1       	ldi	r22, 0x16	; 22
     34c:	72 e0       	ldi	r23, 0x02	; 2
     34e:	8c e2       	ldi	r24, 0x2C	; 44
     350:	91 e0       	ldi	r25, 0x01	; 1
     352:	81 d4       	rcall	.+2306   	; 0xc56 <xTaskGenericCreate>
  
  vTaskStartScheduler();
     354:	61 d5       	rcall	.+2754   	; 0xe18 <vTaskStartScheduler>
     356:	ff cf       	rjmp	.-2      	; 0x356 <main+0x8e>

00000358 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     358:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     35a:	03 96       	adiw	r24, 0x03	; 3
     35c:	92 83       	std	Z+2, r25	; 0x02
     35e:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     360:	2f ef       	ldi	r18, 0xFF	; 255
     362:	3f ef       	ldi	r19, 0xFF	; 255
     364:	34 83       	std	Z+4, r19	; 0x04
     366:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     368:	96 83       	std	Z+6, r25	; 0x06
     36a:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     36c:	90 87       	std	Z+8, r25	; 0x08
     36e:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     370:	10 82       	st	Z, r1
     372:	08 95       	ret

00000374 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     374:	fc 01       	movw	r30, r24
     376:	11 86       	std	Z+9, r1	; 0x09
     378:	10 86       	std	Z+8, r1	; 0x08
     37a:	08 95       	ret

0000037c <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     37c:	cf 93       	push	r28
     37e:	df 93       	push	r29
     380:	fc 01       	movw	r30, r24
     382:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     384:	21 81       	ldd	r18, Z+1	; 0x01
     386:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     388:	e9 01       	movw	r28, r18
     38a:	8a 81       	ldd	r24, Y+2	; 0x02
     38c:	9b 81       	ldd	r25, Y+3	; 0x03
     38e:	13 96       	adiw	r26, 0x03	; 3
     390:	9c 93       	st	X, r25
     392:	8e 93       	st	-X, r24
     394:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
     396:	81 81       	ldd	r24, Z+1	; 0x01
     398:	92 81       	ldd	r25, Z+2	; 0x02
     39a:	15 96       	adiw	r26, 0x05	; 5
     39c:	9c 93       	st	X, r25
     39e:	8e 93       	st	-X, r24
     3a0:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     3a2:	8a 81       	ldd	r24, Y+2	; 0x02
     3a4:	9b 81       	ldd	r25, Y+3	; 0x03
     3a6:	ec 01       	movw	r28, r24
     3a8:	7d 83       	std	Y+5, r23	; 0x05
     3aa:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     3ac:	e9 01       	movw	r28, r18
     3ae:	7b 83       	std	Y+3, r23	; 0x03
     3b0:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     3b2:	72 83       	std	Z+2, r23	; 0x02
     3b4:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     3b6:	19 96       	adiw	r26, 0x09	; 9
     3b8:	fc 93       	st	X, r31
     3ba:	ee 93       	st	-X, r30
     3bc:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
     3be:	80 81       	ld	r24, Z
     3c0:	8f 5f       	subi	r24, 0xFF	; 255
     3c2:	80 83       	st	Z, r24
}
     3c4:	df 91       	pop	r29
     3c6:	cf 91       	pop	r28
     3c8:	08 95       	ret

000003ca <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     3ca:	cf 93       	push	r28
     3cc:	df 93       	push	r29
     3ce:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     3d0:	48 81       	ld	r20, Y
     3d2:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     3d4:	4f 3f       	cpi	r20, 0xFF	; 255
     3d6:	2f ef       	ldi	r18, 0xFF	; 255
     3d8:	52 07       	cpc	r21, r18
     3da:	31 f4       	brne	.+12     	; 0x3e8 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     3dc:	dc 01       	movw	r26, r24
     3de:	17 96       	adiw	r26, 0x07	; 7
     3e0:	ed 91       	ld	r30, X+
     3e2:	fc 91       	ld	r31, X
     3e4:	18 97       	sbiw	r26, 0x08	; 8
     3e6:	17 c0       	rjmp	.+46     	; 0x416 <__LOCK_REGION_LENGTH__+0x16>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     3e8:	fc 01       	movw	r30, r24
     3ea:	33 96       	adiw	r30, 0x03	; 3
     3ec:	dc 01       	movw	r26, r24
     3ee:	15 96       	adiw	r26, 0x05	; 5
     3f0:	2d 91       	ld	r18, X+
     3f2:	3c 91       	ld	r19, X
     3f4:	16 97       	sbiw	r26, 0x06	; 6
     3f6:	d9 01       	movw	r26, r18
     3f8:	2d 91       	ld	r18, X+
     3fa:	3c 91       	ld	r19, X
     3fc:	42 17       	cp	r20, r18
     3fe:	53 07       	cpc	r21, r19
     400:	50 f0       	brcs	.+20     	; 0x416 <__LOCK_REGION_LENGTH__+0x16>
     402:	02 80       	ldd	r0, Z+2	; 0x02
     404:	f3 81       	ldd	r31, Z+3	; 0x03
     406:	e0 2d       	mov	r30, r0
     408:	a2 81       	ldd	r26, Z+2	; 0x02
     40a:	b3 81       	ldd	r27, Z+3	; 0x03
     40c:	2d 91       	ld	r18, X+
     40e:	3c 91       	ld	r19, X
     410:	42 17       	cp	r20, r18
     412:	53 07       	cpc	r21, r19
     414:	b0 f7       	brcc	.-20     	; 0x402 <__LOCK_REGION_LENGTH__+0x2>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     416:	a2 81       	ldd	r26, Z+2	; 0x02
     418:	b3 81       	ldd	r27, Z+3	; 0x03
     41a:	bb 83       	std	Y+3, r27	; 0x03
     41c:	aa 83       	std	Y+2, r26	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     41e:	15 96       	adiw	r26, 0x05	; 5
     420:	dc 93       	st	X, r29
     422:	ce 93       	st	-X, r28
     424:	14 97       	sbiw	r26, 0x04	; 4
	pxNewListItem->pxPrevious = pxIterator;
     426:	fd 83       	std	Y+5, r31	; 0x05
     428:	ec 83       	std	Y+4, r30	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     42a:	d3 83       	std	Z+3, r29	; 0x03
     42c:	c2 83       	std	Z+2, r28	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     42e:	99 87       	std	Y+9, r25	; 0x09
     430:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     432:	fc 01       	movw	r30, r24
     434:	20 81       	ld	r18, Z
     436:	2f 5f       	subi	r18, 0xFF	; 255
     438:	20 83       	st	Z, r18
}
     43a:	df 91       	pop	r29
     43c:	cf 91       	pop	r28
     43e:	08 95       	ret

00000440 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     440:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     442:	a2 81       	ldd	r26, Z+2	; 0x02
     444:	b3 81       	ldd	r27, Z+3	; 0x03
     446:	84 81       	ldd	r24, Z+4	; 0x04
     448:	95 81       	ldd	r25, Z+5	; 0x05
     44a:	15 96       	adiw	r26, 0x05	; 5
     44c:	9c 93       	st	X, r25
     44e:	8e 93       	st	-X, r24
     450:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     452:	a4 81       	ldd	r26, Z+4	; 0x04
     454:	b5 81       	ldd	r27, Z+5	; 0x05
     456:	82 81       	ldd	r24, Z+2	; 0x02
     458:	93 81       	ldd	r25, Z+3	; 0x03
     45a:	13 96       	adiw	r26, 0x03	; 3
     45c:	9c 93       	st	X, r25
     45e:	8e 93       	st	-X, r24
     460:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     462:	a0 85       	ldd	r26, Z+8	; 0x08
     464:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     466:	11 96       	adiw	r26, 0x01	; 1
     468:	8d 91       	ld	r24, X+
     46a:	9c 91       	ld	r25, X
     46c:	12 97       	sbiw	r26, 0x02	; 2
     46e:	e8 17       	cp	r30, r24
     470:	f9 07       	cpc	r31, r25
     472:	31 f4       	brne	.+12     	; 0x480 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     474:	84 81       	ldd	r24, Z+4	; 0x04
     476:	95 81       	ldd	r25, Z+5	; 0x05
     478:	12 96       	adiw	r26, 0x02	; 2
     47a:	9c 93       	st	X, r25
     47c:	8e 93       	st	-X, r24
     47e:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
     480:	11 86       	std	Z+9, r1	; 0x09
     482:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     484:	8c 91       	ld	r24, X
     486:	81 50       	subi	r24, 0x01	; 1
     488:	8c 93       	st	X, r24
     48a:	08 95       	ret

0000048c <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     48c:	31 e1       	ldi	r19, 0x11	; 17
     48e:	fc 01       	movw	r30, r24
     490:	30 83       	st	Z, r19
     492:	31 97       	sbiw	r30, 0x01	; 1
     494:	22 e2       	ldi	r18, 0x22	; 34
     496:	20 83       	st	Z, r18
     498:	31 97       	sbiw	r30, 0x01	; 1
     49a:	a3 e3       	ldi	r26, 0x33	; 51
     49c:	a0 83       	st	Z, r26
     49e:	31 97       	sbiw	r30, 0x01	; 1
     4a0:	60 83       	st	Z, r22
     4a2:	31 97       	sbiw	r30, 0x01	; 1
     4a4:	70 83       	st	Z, r23
     4a6:	31 97       	sbiw	r30, 0x01	; 1
     4a8:	10 82       	st	Z, r1
     4aa:	31 97       	sbiw	r30, 0x01	; 1
     4ac:	10 82       	st	Z, r1
     4ae:	31 97       	sbiw	r30, 0x01	; 1
     4b0:	60 e8       	ldi	r22, 0x80	; 128
     4b2:	60 83       	st	Z, r22
     4b4:	31 97       	sbiw	r30, 0x01	; 1
     4b6:	10 82       	st	Z, r1
     4b8:	31 97       	sbiw	r30, 0x01	; 1
     4ba:	10 82       	st	Z, r1
     4bc:	31 97       	sbiw	r30, 0x01	; 1
     4be:	10 82       	st	Z, r1
     4c0:	31 97       	sbiw	r30, 0x01	; 1
     4c2:	62 e0       	ldi	r22, 0x02	; 2
     4c4:	60 83       	st	Z, r22
     4c6:	31 97       	sbiw	r30, 0x01	; 1
     4c8:	63 e0       	ldi	r22, 0x03	; 3
     4ca:	60 83       	st	Z, r22
     4cc:	31 97       	sbiw	r30, 0x01	; 1
     4ce:	64 e0       	ldi	r22, 0x04	; 4
     4d0:	60 83       	st	Z, r22
     4d2:	31 97       	sbiw	r30, 0x01	; 1
     4d4:	65 e0       	ldi	r22, 0x05	; 5
     4d6:	60 83       	st	Z, r22
     4d8:	31 97       	sbiw	r30, 0x01	; 1
     4da:	66 e0       	ldi	r22, 0x06	; 6
     4dc:	60 83       	st	Z, r22
     4de:	31 97       	sbiw	r30, 0x01	; 1
     4e0:	67 e0       	ldi	r22, 0x07	; 7
     4e2:	60 83       	st	Z, r22
     4e4:	31 97       	sbiw	r30, 0x01	; 1
     4e6:	68 e0       	ldi	r22, 0x08	; 8
     4e8:	60 83       	st	Z, r22
     4ea:	31 97       	sbiw	r30, 0x01	; 1
     4ec:	69 e0       	ldi	r22, 0x09	; 9
     4ee:	60 83       	st	Z, r22
     4f0:	31 97       	sbiw	r30, 0x01	; 1
     4f2:	60 e1       	ldi	r22, 0x10	; 16
     4f4:	60 83       	st	Z, r22
     4f6:	31 97       	sbiw	r30, 0x01	; 1
     4f8:	30 83       	st	Z, r19
     4fa:	31 97       	sbiw	r30, 0x01	; 1
     4fc:	32 e1       	ldi	r19, 0x12	; 18
     4fe:	30 83       	st	Z, r19
     500:	31 97       	sbiw	r30, 0x01	; 1
     502:	33 e1       	ldi	r19, 0x13	; 19
     504:	30 83       	st	Z, r19
     506:	31 97       	sbiw	r30, 0x01	; 1
     508:	34 e1       	ldi	r19, 0x14	; 20
     50a:	30 83       	st	Z, r19
     50c:	31 97       	sbiw	r30, 0x01	; 1
     50e:	35 e1       	ldi	r19, 0x15	; 21
     510:	30 83       	st	Z, r19
     512:	31 97       	sbiw	r30, 0x01	; 1
     514:	36 e1       	ldi	r19, 0x16	; 22
     516:	30 83       	st	Z, r19
     518:	31 97       	sbiw	r30, 0x01	; 1
     51a:	37 e1       	ldi	r19, 0x17	; 23
     51c:	30 83       	st	Z, r19
     51e:	31 97       	sbiw	r30, 0x01	; 1
     520:	38 e1       	ldi	r19, 0x18	; 24
     522:	30 83       	st	Z, r19
     524:	31 97       	sbiw	r30, 0x01	; 1
     526:	39 e1       	ldi	r19, 0x19	; 25
     528:	30 83       	st	Z, r19
     52a:	31 97       	sbiw	r30, 0x01	; 1
     52c:	30 e2       	ldi	r19, 0x20	; 32
     52e:	30 83       	st	Z, r19
     530:	31 97       	sbiw	r30, 0x01	; 1
     532:	31 e2       	ldi	r19, 0x21	; 33
     534:	30 83       	st	Z, r19
     536:	31 97       	sbiw	r30, 0x01	; 1
     538:	20 83       	st	Z, r18
     53a:	31 97       	sbiw	r30, 0x01	; 1
     53c:	23 e2       	ldi	r18, 0x23	; 35
     53e:	20 83       	st	Z, r18
     540:	31 97       	sbiw	r30, 0x01	; 1
     542:	40 83       	st	Z, r20
     544:	31 97       	sbiw	r30, 0x01	; 1
     546:	50 83       	st	Z, r21
     548:	31 97       	sbiw	r30, 0x01	; 1
     54a:	26 e2       	ldi	r18, 0x26	; 38
     54c:	20 83       	st	Z, r18
     54e:	31 97       	sbiw	r30, 0x01	; 1
     550:	27 e2       	ldi	r18, 0x27	; 39
     552:	20 83       	st	Z, r18
     554:	31 97       	sbiw	r30, 0x01	; 1
     556:	28 e2       	ldi	r18, 0x28	; 40
     558:	20 83       	st	Z, r18
     55a:	31 97       	sbiw	r30, 0x01	; 1
     55c:	29 e2       	ldi	r18, 0x29	; 41
     55e:	20 83       	st	Z, r18
     560:	31 97       	sbiw	r30, 0x01	; 1
     562:	20 e3       	ldi	r18, 0x30	; 48
     564:	20 83       	st	Z, r18
     566:	31 97       	sbiw	r30, 0x01	; 1
     568:	21 e3       	ldi	r18, 0x31	; 49
     56a:	20 83       	st	Z, r18
     56c:	89 97       	sbiw	r24, 0x29	; 41
     56e:	08 95       	ret

00000570 <xPortStartScheduler>:
     570:	10 92 29 01 	sts	0x0129, r1	; 0x800129 <__TEXT_REGION_LENGTH__+0x7c0129>
     574:	89 ef       	ldi	r24, 0xF9	; 249
     576:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <__TEXT_REGION_LENGTH__+0x7c0128>
     57a:	8b e0       	ldi	r24, 0x0B	; 11
     57c:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <__TEXT_REGION_LENGTH__+0x7c0121>
     580:	e3 e7       	ldi	r30, 0x73	; 115
     582:	f0 e0       	ldi	r31, 0x00	; 0
     584:	80 81       	ld	r24, Z
     586:	82 60       	ori	r24, 0x02	; 2
     588:	80 83       	st	Z, r24
     58a:	a0 91 35 08 	lds	r26, 0x0835	; 0x800835 <pxCurrentTCB>
     58e:	b0 91 36 08 	lds	r27, 0x0836	; 0x800836 <pxCurrentTCB+0x1>
     592:	cd 91       	ld	r28, X+
     594:	cd bf       	out	0x3d, r28	; 61
     596:	dd 91       	ld	r29, X+
     598:	de bf       	out	0x3e, r29	; 62
     59a:	ff 91       	pop	r31
     59c:	ef 91       	pop	r30
     59e:	df 91       	pop	r29
     5a0:	cf 91       	pop	r28
     5a2:	bf 91       	pop	r27
     5a4:	af 91       	pop	r26
     5a6:	9f 91       	pop	r25
     5a8:	8f 91       	pop	r24
     5aa:	7f 91       	pop	r23
     5ac:	6f 91       	pop	r22
     5ae:	5f 91       	pop	r21
     5b0:	4f 91       	pop	r20
     5b2:	3f 91       	pop	r19
     5b4:	2f 91       	pop	r18
     5b6:	1f 91       	pop	r17
     5b8:	0f 91       	pop	r16
     5ba:	ff 90       	pop	r15
     5bc:	ef 90       	pop	r14
     5be:	df 90       	pop	r13
     5c0:	cf 90       	pop	r12
     5c2:	bf 90       	pop	r11
     5c4:	af 90       	pop	r10
     5c6:	9f 90       	pop	r9
     5c8:	8f 90       	pop	r8
     5ca:	7f 90       	pop	r7
     5cc:	6f 90       	pop	r6
     5ce:	5f 90       	pop	r5
     5d0:	4f 90       	pop	r4
     5d2:	3f 90       	pop	r3
     5d4:	2f 90       	pop	r2
     5d6:	1f 90       	pop	r1
     5d8:	0f 90       	pop	r0
     5da:	0c be       	out	0x3c, r0	; 60
     5dc:	0f 90       	pop	r0
     5de:	0b be       	out	0x3b, r0	; 59
     5e0:	0f 90       	pop	r0
     5e2:	0f be       	out	0x3f, r0	; 63
     5e4:	0f 90       	pop	r0
     5e6:	08 95       	ret
     5e8:	81 e0       	ldi	r24, 0x01	; 1
     5ea:	08 95       	ret

000005ec <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     5ec:	0f 92       	push	r0
     5ee:	0f b6       	in	r0, 0x3f	; 63
     5f0:	f8 94       	cli
     5f2:	0f 92       	push	r0
     5f4:	0b b6       	in	r0, 0x3b	; 59
     5f6:	0f 92       	push	r0
     5f8:	0c b6       	in	r0, 0x3c	; 60
     5fa:	0f 92       	push	r0
     5fc:	1f 92       	push	r1
     5fe:	11 24       	eor	r1, r1
     600:	2f 92       	push	r2
     602:	3f 92       	push	r3
     604:	4f 92       	push	r4
     606:	5f 92       	push	r5
     608:	6f 92       	push	r6
     60a:	7f 92       	push	r7
     60c:	8f 92       	push	r8
     60e:	9f 92       	push	r9
     610:	af 92       	push	r10
     612:	bf 92       	push	r11
     614:	cf 92       	push	r12
     616:	df 92       	push	r13
     618:	ef 92       	push	r14
     61a:	ff 92       	push	r15
     61c:	0f 93       	push	r16
     61e:	1f 93       	push	r17
     620:	2f 93       	push	r18
     622:	3f 93       	push	r19
     624:	4f 93       	push	r20
     626:	5f 93       	push	r21
     628:	6f 93       	push	r22
     62a:	7f 93       	push	r23
     62c:	8f 93       	push	r24
     62e:	9f 93       	push	r25
     630:	af 93       	push	r26
     632:	bf 93       	push	r27
     634:	cf 93       	push	r28
     636:	df 93       	push	r29
     638:	ef 93       	push	r30
     63a:	ff 93       	push	r31
     63c:	a0 91 35 08 	lds	r26, 0x0835	; 0x800835 <pxCurrentTCB>
     640:	b0 91 36 08 	lds	r27, 0x0836	; 0x800836 <pxCurrentTCB+0x1>
     644:	0d b6       	in	r0, 0x3d	; 61
     646:	0d 92       	st	X+, r0
     648:	0e b6       	in	r0, 0x3e	; 62
     64a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     64c:	a5 d5       	rcall	.+2890   	; 0x1198 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     64e:	a0 91 35 08 	lds	r26, 0x0835	; 0x800835 <pxCurrentTCB>
     652:	b0 91 36 08 	lds	r27, 0x0836	; 0x800836 <pxCurrentTCB+0x1>
     656:	cd 91       	ld	r28, X+
     658:	cd bf       	out	0x3d, r28	; 61
     65a:	dd 91       	ld	r29, X+
     65c:	de bf       	out	0x3e, r29	; 62
     65e:	ff 91       	pop	r31
     660:	ef 91       	pop	r30
     662:	df 91       	pop	r29
     664:	cf 91       	pop	r28
     666:	bf 91       	pop	r27
     668:	af 91       	pop	r26
     66a:	9f 91       	pop	r25
     66c:	8f 91       	pop	r24
     66e:	7f 91       	pop	r23
     670:	6f 91       	pop	r22
     672:	5f 91       	pop	r21
     674:	4f 91       	pop	r20
     676:	3f 91       	pop	r19
     678:	2f 91       	pop	r18
     67a:	1f 91       	pop	r17
     67c:	0f 91       	pop	r16
     67e:	ff 90       	pop	r15
     680:	ef 90       	pop	r14
     682:	df 90       	pop	r13
     684:	cf 90       	pop	r12
     686:	bf 90       	pop	r11
     688:	af 90       	pop	r10
     68a:	9f 90       	pop	r9
     68c:	8f 90       	pop	r8
     68e:	7f 90       	pop	r7
     690:	6f 90       	pop	r6
     692:	5f 90       	pop	r5
     694:	4f 90       	pop	r4
     696:	3f 90       	pop	r3
     698:	2f 90       	pop	r2
     69a:	1f 90       	pop	r1
     69c:	0f 90       	pop	r0
     69e:	0c be       	out	0x3c, r0	; 60
     6a0:	0f 90       	pop	r0
     6a2:	0b be       	out	0x3b, r0	; 59
     6a4:	0f 90       	pop	r0
     6a6:	0f be       	out	0x3f, r0	; 63
     6a8:	0f 90       	pop	r0

	asm volatile ( "ret" );
     6aa:	08 95       	ret

000006ac <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     6ac:	0f 92       	push	r0
     6ae:	0f b6       	in	r0, 0x3f	; 63
     6b0:	f8 94       	cli
     6b2:	0f 92       	push	r0
     6b4:	0b b6       	in	r0, 0x3b	; 59
     6b6:	0f 92       	push	r0
     6b8:	0c b6       	in	r0, 0x3c	; 60
     6ba:	0f 92       	push	r0
     6bc:	1f 92       	push	r1
     6be:	11 24       	eor	r1, r1
     6c0:	2f 92       	push	r2
     6c2:	3f 92       	push	r3
     6c4:	4f 92       	push	r4
     6c6:	5f 92       	push	r5
     6c8:	6f 92       	push	r6
     6ca:	7f 92       	push	r7
     6cc:	8f 92       	push	r8
     6ce:	9f 92       	push	r9
     6d0:	af 92       	push	r10
     6d2:	bf 92       	push	r11
     6d4:	cf 92       	push	r12
     6d6:	df 92       	push	r13
     6d8:	ef 92       	push	r14
     6da:	ff 92       	push	r15
     6dc:	0f 93       	push	r16
     6de:	1f 93       	push	r17
     6e0:	2f 93       	push	r18
     6e2:	3f 93       	push	r19
     6e4:	4f 93       	push	r20
     6e6:	5f 93       	push	r21
     6e8:	6f 93       	push	r22
     6ea:	7f 93       	push	r23
     6ec:	8f 93       	push	r24
     6ee:	9f 93       	push	r25
     6f0:	af 93       	push	r26
     6f2:	bf 93       	push	r27
     6f4:	cf 93       	push	r28
     6f6:	df 93       	push	r29
     6f8:	ef 93       	push	r30
     6fa:	ff 93       	push	r31
     6fc:	a0 91 35 08 	lds	r26, 0x0835	; 0x800835 <pxCurrentTCB>
     700:	b0 91 36 08 	lds	r27, 0x0836	; 0x800836 <pxCurrentTCB+0x1>
     704:	0d b6       	in	r0, 0x3d	; 61
     706:	0d 92       	st	X+, r0
     708:	0e b6       	in	r0, 0x3e	; 62
     70a:	0d 92       	st	X+, r0
	vTaskIncrementTick();
     70c:	be d3       	rcall	.+1916   	; 0xe8a <vTaskIncrementTick>
	vTaskSwitchContext();
     70e:	44 d5       	rcall	.+2696   	; 0x1198 <vTaskSwitchContext>
     710:	a0 91 35 08 	lds	r26, 0x0835	; 0x800835 <pxCurrentTCB>
	portRESTORE_CONTEXT();
     714:	b0 91 36 08 	lds	r27, 0x0836	; 0x800836 <pxCurrentTCB+0x1>
     718:	cd 91       	ld	r28, X+
     71a:	cd bf       	out	0x3d, r28	; 61
     71c:	dd 91       	ld	r29, X+
     71e:	de bf       	out	0x3e, r29	; 62
     720:	ff 91       	pop	r31
     722:	ef 91       	pop	r30
     724:	df 91       	pop	r29
     726:	cf 91       	pop	r28
     728:	bf 91       	pop	r27
     72a:	af 91       	pop	r26
     72c:	9f 91       	pop	r25
     72e:	8f 91       	pop	r24
     730:	7f 91       	pop	r23
     732:	6f 91       	pop	r22
     734:	5f 91       	pop	r21
     736:	4f 91       	pop	r20
     738:	3f 91       	pop	r19
     73a:	2f 91       	pop	r18
     73c:	1f 91       	pop	r17
     73e:	0f 91       	pop	r16
     740:	ff 90       	pop	r15
     742:	ef 90       	pop	r14
     744:	df 90       	pop	r13
     746:	cf 90       	pop	r12
     748:	bf 90       	pop	r11
     74a:	af 90       	pop	r10
     74c:	9f 90       	pop	r9
     74e:	8f 90       	pop	r8
     750:	7f 90       	pop	r7
     752:	6f 90       	pop	r6
     754:	5f 90       	pop	r5
     756:	4f 90       	pop	r4
     758:	3f 90       	pop	r3
     75a:	2f 90       	pop	r2
     75c:	1f 90       	pop	r1
     75e:	0f 90       	pop	r0
     760:	0c be       	out	0x3c, r0	; 60
     762:	0f 90       	pop	r0
     764:	0b be       	out	0x3b, r0	; 59
     766:	0f 90       	pop	r0
     768:	0f be       	out	0x3f, r0	; 63
     76a:	0f 90       	pop	r0
     76c:	08 95       	ret

0000076e <__vector_47>:
	asm volatile ( "ret" );
     76e:	9e df       	rcall	.-196    	; 0x6ac <vPortYieldFromTick>
//	void SIG_OUTPUT_COMPARE1A( void )
	void TIMER5_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER5_COMPA_vect( void )
	{
		vPortYieldFromTick();
		asm volatile ( "reti" );
     770:	18 95       	reti

00000772 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     772:	cf 93       	push	r28
     774:	df 93       	push	r29
     776:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     778:	78 d3       	rcall	.+1776   	; 0xe6a <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     77a:	20 91 24 02 	lds	r18, 0x0224	; 0x800224 <xNextFreeByte>
     77e:	30 91 25 02 	lds	r19, 0x0225	; 0x800225 <xNextFreeByte+0x1>
     782:	c9 01       	movw	r24, r18
     784:	8c 0f       	add	r24, r28
     786:	9d 1f       	adc	r25, r29
     788:	8c 3d       	cpi	r24, 0xDC	; 220
     78a:	45 e0       	ldi	r20, 0x05	; 5
     78c:	94 07       	cpc	r25, r20
     78e:	58 f4       	brcc	.+22     	; 0x7a6 <pvPortMalloc+0x34>
     790:	28 17       	cp	r18, r24
     792:	39 07       	cpc	r19, r25
     794:	58 f4       	brcc	.+22     	; 0x7ac <pvPortMalloc+0x3a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     796:	e9 01       	movw	r28, r18
     798:	ca 5d       	subi	r28, 0xDA	; 218
     79a:	dd 4f       	sbci	r29, 0xFD	; 253
			xNextFreeByte += xWantedSize;			
     79c:	90 93 25 02 	sts	0x0225, r25	; 0x800225 <xNextFreeByte+0x1>
     7a0:	80 93 24 02 	sts	0x0224, r24	; 0x800224 <xNextFreeByte>
     7a4:	05 c0       	rjmp	.+10     	; 0x7b0 <pvPortMalloc+0x3e>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
     7a6:	c0 e0       	ldi	r28, 0x00	; 0
     7a8:	d0 e0       	ldi	r29, 0x00	; 0
     7aa:	02 c0       	rjmp	.+4      	; 0x7b0 <pvPortMalloc+0x3e>
     7ac:	c0 e0       	ldi	r28, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
     7ae:	d0 e0       	ldi	r29, 0x00	; 0
     7b0:	2d d4       	rcall	.+2138   	; 0x100c <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
     7b2:	ce 01       	movw	r24, r28
     7b4:	df 91       	pop	r29
     7b6:	cf 91       	pop	r28
     7b8:	08 95       	ret

000007ba <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     7ba:	08 95       	ret

000007bc <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     7bc:	cf 93       	push	r28
     7be:	df 93       	push	r29
     7c0:	ec 01       	movw	r28, r24
     7c2:	8c 8d       	ldd	r24, Y+28	; 0x1c
     7c4:	88 23       	and	r24, r24
     7c6:	99 f1       	breq	.+102    	; 0x82e <prvCopyDataToQueue+0x72>
     7c8:	41 11       	cpse	r20, r1
     7ca:	16 c0       	rjmp	.+44     	; 0x7f8 <prvCopyDataToQueue+0x3c>
     7cc:	48 2f       	mov	r20, r24
     7ce:	50 e0       	ldi	r21, 0x00	; 0
     7d0:	8c 81       	ldd	r24, Y+4	; 0x04
     7d2:	9d 81       	ldd	r25, Y+5	; 0x05
     7d4:	ed d5       	rcall	.+3034   	; 0x13b0 <memcpy>
     7d6:	2c 8d       	ldd	r18, Y+28	; 0x1c
     7d8:	8c 81       	ldd	r24, Y+4	; 0x04
     7da:	9d 81       	ldd	r25, Y+5	; 0x05
     7dc:	82 0f       	add	r24, r18
     7de:	91 1d       	adc	r25, r1
     7e0:	9d 83       	std	Y+5, r25	; 0x05
     7e2:	8c 83       	std	Y+4, r24	; 0x04
     7e4:	2a 81       	ldd	r18, Y+2	; 0x02
     7e6:	3b 81       	ldd	r19, Y+3	; 0x03
     7e8:	82 17       	cp	r24, r18
     7ea:	93 07       	cpc	r25, r19
     7ec:	00 f1       	brcs	.+64     	; 0x82e <prvCopyDataToQueue+0x72>
     7ee:	88 81       	ld	r24, Y
     7f0:	99 81       	ldd	r25, Y+1	; 0x01
     7f2:	9d 83       	std	Y+5, r25	; 0x05
     7f4:	8c 83       	std	Y+4, r24	; 0x04
     7f6:	1b c0       	rjmp	.+54     	; 0x82e <prvCopyDataToQueue+0x72>
     7f8:	48 2f       	mov	r20, r24
     7fa:	50 e0       	ldi	r21, 0x00	; 0
     7fc:	8e 81       	ldd	r24, Y+6	; 0x06
     7fe:	9f 81       	ldd	r25, Y+7	; 0x07
     800:	d7 d5       	rcall	.+2990   	; 0x13b0 <memcpy>
     802:	8c 8d       	ldd	r24, Y+28	; 0x1c
     804:	90 e0       	ldi	r25, 0x00	; 0
     806:	91 95       	neg	r25
     808:	81 95       	neg	r24
     80a:	91 09       	sbc	r25, r1
     80c:	2e 81       	ldd	r18, Y+6	; 0x06
     80e:	3f 81       	ldd	r19, Y+7	; 0x07
     810:	28 0f       	add	r18, r24
     812:	39 1f       	adc	r19, r25
     814:	3f 83       	std	Y+7, r19	; 0x07
     816:	2e 83       	std	Y+6, r18	; 0x06
     818:	48 81       	ld	r20, Y
     81a:	59 81       	ldd	r21, Y+1	; 0x01
     81c:	24 17       	cp	r18, r20
     81e:	35 07       	cpc	r19, r21
     820:	30 f4       	brcc	.+12     	; 0x82e <prvCopyDataToQueue+0x72>
     822:	2a 81       	ldd	r18, Y+2	; 0x02
     824:	3b 81       	ldd	r19, Y+3	; 0x03
     826:	82 0f       	add	r24, r18
     828:	93 1f       	adc	r25, r19
     82a:	9f 83       	std	Y+7, r25	; 0x07
     82c:	8e 83       	std	Y+6, r24	; 0x06
     82e:	8a 8d       	ldd	r24, Y+26	; 0x1a
     830:	8f 5f       	subi	r24, 0xFF	; 255
     832:	8a 8f       	std	Y+26, r24	; 0x1a
     834:	df 91       	pop	r29
     836:	cf 91       	pop	r28
     838:	08 95       	ret

0000083a <prvCopyDataFromQueue>:
     83a:	fc 01       	movw	r30, r24
     83c:	80 81       	ld	r24, Z
     83e:	91 81       	ldd	r25, Z+1	; 0x01
     840:	00 97       	sbiw	r24, 0x00	; 0
     842:	99 f0       	breq	.+38     	; 0x86a <prvCopyDataFromQueue+0x30>
     844:	44 8d       	ldd	r20, Z+28	; 0x1c
     846:	50 e0       	ldi	r21, 0x00	; 0
     848:	26 81       	ldd	r18, Z+6	; 0x06
     84a:	37 81       	ldd	r19, Z+7	; 0x07
     84c:	24 0f       	add	r18, r20
     84e:	35 1f       	adc	r19, r21
     850:	37 83       	std	Z+7, r19	; 0x07
     852:	26 83       	std	Z+6, r18	; 0x06
     854:	a2 81       	ldd	r26, Z+2	; 0x02
     856:	b3 81       	ldd	r27, Z+3	; 0x03
     858:	2a 17       	cp	r18, r26
     85a:	3b 07       	cpc	r19, r27
     85c:	10 f0       	brcs	.+4      	; 0x862 <prvCopyDataFromQueue+0x28>
     85e:	97 83       	std	Z+7, r25	; 0x07
     860:	86 83       	std	Z+6, r24	; 0x06
     862:	cb 01       	movw	r24, r22
     864:	66 81       	ldd	r22, Z+6	; 0x06
     866:	77 81       	ldd	r23, Z+7	; 0x07
     868:	a3 c5       	rjmp	.+2886   	; 0x13b0 <memcpy>
     86a:	08 95       	ret

0000086c <prvUnlockQueue>:
     86c:	0f 93       	push	r16
     86e:	1f 93       	push	r17
     870:	cf 93       	push	r28
     872:	df 93       	push	r29
     874:	ec 01       	movw	r28, r24
     876:	0f b6       	in	r0, 0x3f	; 63
     878:	f8 94       	cli
     87a:	0f 92       	push	r0
     87c:	8e 8d       	ldd	r24, Y+30	; 0x1e
     87e:	18 16       	cp	r1, r24
     880:	a4 f4       	brge	.+40     	; 0x8aa <prvUnlockQueue+0x3e>
     882:	89 89       	ldd	r24, Y+17	; 0x11
     884:	81 11       	cpse	r24, r1
     886:	05 c0       	rjmp	.+10     	; 0x892 <prvUnlockQueue+0x26>
     888:	10 c0       	rjmp	.+32     	; 0x8aa <prvUnlockQueue+0x3e>
     88a:	89 89       	ldd	r24, Y+17	; 0x11
     88c:	81 11       	cpse	r24, r1
     88e:	04 c0       	rjmp	.+8      	; 0x898 <prvUnlockQueue+0x2c>
     890:	0c c0       	rjmp	.+24     	; 0x8aa <prvUnlockQueue+0x3e>
     892:	8e 01       	movw	r16, r28
     894:	0f 5e       	subi	r16, 0xEF	; 239
     896:	1f 4f       	sbci	r17, 0xFF	; 255
     898:	c8 01       	movw	r24, r16
     89a:	04 d5       	rcall	.+2568   	; 0x12a4 <xTaskRemoveFromEventList>
     89c:	81 11       	cpse	r24, r1
     89e:	84 d5       	rcall	.+2824   	; 0x13a8 <vTaskMissedYield>
     8a0:	8e 8d       	ldd	r24, Y+30	; 0x1e
     8a2:	81 50       	subi	r24, 0x01	; 1
     8a4:	8e 8f       	std	Y+30, r24	; 0x1e
     8a6:	18 16       	cp	r1, r24
     8a8:	84 f3       	brlt	.-32     	; 0x88a <prvUnlockQueue+0x1e>
     8aa:	8f ef       	ldi	r24, 0xFF	; 255
     8ac:	8e 8f       	std	Y+30, r24	; 0x1e
     8ae:	0f 90       	pop	r0
     8b0:	0f be       	out	0x3f, r0	; 63
     8b2:	0f b6       	in	r0, 0x3f	; 63
     8b4:	f8 94       	cli
     8b6:	0f 92       	push	r0
     8b8:	8d 8d       	ldd	r24, Y+29	; 0x1d
     8ba:	18 16       	cp	r1, r24
     8bc:	a4 f4       	brge	.+40     	; 0x8e6 <prvUnlockQueue+0x7a>
     8be:	88 85       	ldd	r24, Y+8	; 0x08
     8c0:	81 11       	cpse	r24, r1
     8c2:	05 c0       	rjmp	.+10     	; 0x8ce <prvUnlockQueue+0x62>
     8c4:	10 c0       	rjmp	.+32     	; 0x8e6 <prvUnlockQueue+0x7a>
     8c6:	88 85       	ldd	r24, Y+8	; 0x08
     8c8:	81 11       	cpse	r24, r1
     8ca:	04 c0       	rjmp	.+8      	; 0x8d4 <prvUnlockQueue+0x68>
     8cc:	0c c0       	rjmp	.+24     	; 0x8e6 <prvUnlockQueue+0x7a>
     8ce:	8e 01       	movw	r16, r28
     8d0:	08 5f       	subi	r16, 0xF8	; 248
     8d2:	1f 4f       	sbci	r17, 0xFF	; 255
     8d4:	c8 01       	movw	r24, r16
     8d6:	e6 d4       	rcall	.+2508   	; 0x12a4 <xTaskRemoveFromEventList>
     8d8:	81 11       	cpse	r24, r1
     8da:	66 d5       	rcall	.+2764   	; 0x13a8 <vTaskMissedYield>
     8dc:	8d 8d       	ldd	r24, Y+29	; 0x1d
     8de:	81 50       	subi	r24, 0x01	; 1
     8e0:	8d 8f       	std	Y+29, r24	; 0x1d
     8e2:	18 16       	cp	r1, r24
     8e4:	84 f3       	brlt	.-32     	; 0x8c6 <prvUnlockQueue+0x5a>
     8e6:	8f ef       	ldi	r24, 0xFF	; 255
     8e8:	8d 8f       	std	Y+29, r24	; 0x1d
     8ea:	0f 90       	pop	r0
     8ec:	0f be       	out	0x3f, r0	; 63
     8ee:	df 91       	pop	r29
     8f0:	cf 91       	pop	r28
     8f2:	1f 91       	pop	r17
     8f4:	0f 91       	pop	r16
     8f6:	08 95       	ret

000008f8 <xQueueGenericCreate>:
     8f8:	cf 92       	push	r12
     8fa:	df 92       	push	r13
     8fc:	ef 92       	push	r14
     8fe:	ff 92       	push	r15
     900:	0f 93       	push	r16
     902:	1f 93       	push	r17
     904:	cf 93       	push	r28
     906:	df 93       	push	r29
     908:	88 23       	and	r24, r24
     90a:	a9 f1       	breq	.+106    	; 0x976 <xQueueGenericCreate+0x7e>
     90c:	e6 2e       	mov	r14, r22
     90e:	f8 2e       	mov	r15, r24
     910:	8f e1       	ldi	r24, 0x1F	; 31
     912:	90 e0       	ldi	r25, 0x00	; 0
     914:	2e df       	rcall	.-420    	; 0x772 <pvPortMalloc>
     916:	ec 01       	movw	r28, r24
     918:	89 2b       	or	r24, r25
     91a:	79 f1       	breq	.+94     	; 0x97a <xQueueGenericCreate+0x82>
     91c:	ce 2c       	mov	r12, r14
     91e:	d1 2c       	mov	r13, r1
     920:	fc 9c       	mul	r15, r12
     922:	80 01       	movw	r16, r0
     924:	fd 9c       	mul	r15, r13
     926:	10 0d       	add	r17, r0
     928:	11 24       	eor	r1, r1
     92a:	c8 01       	movw	r24, r16
     92c:	01 96       	adiw	r24, 0x01	; 1
     92e:	21 df       	rcall	.-446    	; 0x772 <pvPortMalloc>
     930:	99 83       	std	Y+1, r25	; 0x01
     932:	88 83       	st	Y, r24
     934:	00 97       	sbiw	r24, 0x00	; 0
     936:	d1 f0       	breq	.+52     	; 0x96c <xQueueGenericCreate+0x74>
     938:	9c 01       	movw	r18, r24
     93a:	20 0f       	add	r18, r16
     93c:	31 1f       	adc	r19, r17
     93e:	3b 83       	std	Y+3, r19	; 0x03
     940:	2a 83       	std	Y+2, r18	; 0x02
     942:	1a 8e       	std	Y+26, r1	; 0x1a
     944:	9d 83       	std	Y+5, r25	; 0x05
     946:	8c 83       	std	Y+4, r24	; 0x04
     948:	0c 19       	sub	r16, r12
     94a:	1d 09       	sbc	r17, r13
     94c:	08 0f       	add	r16, r24
     94e:	19 1f       	adc	r17, r25
     950:	1f 83       	std	Y+7, r17	; 0x07
     952:	0e 83       	std	Y+6, r16	; 0x06
     954:	fb 8e       	std	Y+27, r15	; 0x1b
     956:	ec 8e       	std	Y+28, r14	; 0x1c
     958:	8f ef       	ldi	r24, 0xFF	; 255
     95a:	8d 8f       	std	Y+29, r24	; 0x1d
     95c:	8e 8f       	std	Y+30, r24	; 0x1e
     95e:	ce 01       	movw	r24, r28
     960:	08 96       	adiw	r24, 0x08	; 8
     962:	fa dc       	rcall	.-1548   	; 0x358 <vListInitialise>
     964:	ce 01       	movw	r24, r28
     966:	41 96       	adiw	r24, 0x11	; 17
     968:	f7 dc       	rcall	.-1554   	; 0x358 <vListInitialise>
     96a:	07 c0       	rjmp	.+14     	; 0x97a <xQueueGenericCreate+0x82>
     96c:	ce 01       	movw	r24, r28
     96e:	25 df       	rcall	.-438    	; 0x7ba <vPortFree>
     970:	c0 e0       	ldi	r28, 0x00	; 0
     972:	d0 e0       	ldi	r29, 0x00	; 0
     974:	02 c0       	rjmp	.+4      	; 0x97a <xQueueGenericCreate+0x82>
     976:	c0 e0       	ldi	r28, 0x00	; 0
     978:	d0 e0       	ldi	r29, 0x00	; 0
     97a:	ce 01       	movw	r24, r28
     97c:	df 91       	pop	r29
     97e:	cf 91       	pop	r28
     980:	1f 91       	pop	r17
     982:	0f 91       	pop	r16
     984:	ff 90       	pop	r15
     986:	ef 90       	pop	r14
     988:	df 90       	pop	r13
     98a:	cf 90       	pop	r12
     98c:	08 95       	ret

0000098e <xQueueGenericSend>:
     98e:	9f 92       	push	r9
     990:	af 92       	push	r10
     992:	bf 92       	push	r11
     994:	cf 92       	push	r12
     996:	df 92       	push	r13
     998:	ef 92       	push	r14
     99a:	ff 92       	push	r15
     99c:	0f 93       	push	r16
     99e:	1f 93       	push	r17
     9a0:	cf 93       	push	r28
     9a2:	df 93       	push	r29
     9a4:	00 d0       	rcall	.+0      	; 0x9a6 <xQueueGenericSend+0x18>
     9a6:	1f 92       	push	r1
     9a8:	1f 92       	push	r1
     9aa:	cd b7       	in	r28, 0x3d	; 61
     9ac:	de b7       	in	r29, 0x3e	; 62
     9ae:	8c 01       	movw	r16, r24
     9b0:	6b 01       	movw	r12, r22
     9b2:	5d 83       	std	Y+5, r21	; 0x05
     9b4:	4c 83       	std	Y+4, r20	; 0x04
     9b6:	92 2e       	mov	r9, r18
     9b8:	b1 2c       	mov	r11, r1
     9ba:	aa 24       	eor	r10, r10
     9bc:	a3 94       	inc	r10
     9be:	7c 01       	movw	r14, r24
     9c0:	88 e0       	ldi	r24, 0x08	; 8
     9c2:	e8 0e       	add	r14, r24
     9c4:	f1 1c       	adc	r15, r1
     9c6:	0f b6       	in	r0, 0x3f	; 63
     9c8:	f8 94       	cli
     9ca:	0f 92       	push	r0
     9cc:	f8 01       	movw	r30, r16
     9ce:	92 8d       	ldd	r25, Z+26	; 0x1a
     9d0:	83 8d       	ldd	r24, Z+27	; 0x1b
     9d2:	98 17       	cp	r25, r24
     9d4:	90 f4       	brcc	.+36     	; 0x9fa <xQueueGenericSend+0x6c>
     9d6:	49 2d       	mov	r20, r9
     9d8:	b6 01       	movw	r22, r12
     9da:	c8 01       	movw	r24, r16
     9dc:	ef de       	rcall	.-546    	; 0x7bc <prvCopyDataToQueue>
     9de:	f8 01       	movw	r30, r16
     9e0:	81 89       	ldd	r24, Z+17	; 0x11
     9e2:	88 23       	and	r24, r24
     9e4:	31 f0       	breq	.+12     	; 0x9f2 <xQueueGenericSend+0x64>
     9e6:	c8 01       	movw	r24, r16
     9e8:	41 96       	adiw	r24, 0x11	; 17
     9ea:	5c d4       	rcall	.+2232   	; 0x12a4 <xTaskRemoveFromEventList>
     9ec:	81 30       	cpi	r24, 0x01	; 1
     9ee:	09 f4       	brne	.+2      	; 0x9f2 <xQueueGenericSend+0x64>
     9f0:	fd dd       	rcall	.-1030   	; 0x5ec <vPortYield>
     9f2:	0f 90       	pop	r0
     9f4:	0f be       	out	0x3f, r0	; 63
     9f6:	81 e0       	ldi	r24, 0x01	; 1
     9f8:	45 c0       	rjmp	.+138    	; 0xa84 <xQueueGenericSend+0xf6>
     9fa:	8c 81       	ldd	r24, Y+4	; 0x04
     9fc:	9d 81       	ldd	r25, Y+5	; 0x05
     9fe:	89 2b       	or	r24, r25
     a00:	21 f4       	brne	.+8      	; 0xa0a <xQueueGenericSend+0x7c>
     a02:	0f 90       	pop	r0
     a04:	0f be       	out	0x3f, r0	; 63
     a06:	80 e0       	ldi	r24, 0x00	; 0
     a08:	3d c0       	rjmp	.+122    	; 0xa84 <xQueueGenericSend+0xf6>
     a0a:	b1 10       	cpse	r11, r1
     a0c:	04 c0       	rjmp	.+8      	; 0xa16 <xQueueGenericSend+0x88>
     a0e:	ce 01       	movw	r24, r28
     a10:	01 96       	adiw	r24, 0x01	; 1
     a12:	89 d4       	rcall	.+2322   	; 0x1326 <vTaskSetTimeOutState>
     a14:	ba 2c       	mov	r11, r10
     a16:	0f 90       	pop	r0
     a18:	0f be       	out	0x3f, r0	; 63
     a1a:	27 d2       	rcall	.+1102   	; 0xe6a <vTaskSuspendAll>
     a1c:	0f b6       	in	r0, 0x3f	; 63
     a1e:	f8 94       	cli
     a20:	0f 92       	push	r0
     a22:	f8 01       	movw	r30, r16
     a24:	85 8d       	ldd	r24, Z+29	; 0x1d
     a26:	8f 3f       	cpi	r24, 0xFF	; 255
     a28:	09 f4       	brne	.+2      	; 0xa2c <xQueueGenericSend+0x9e>
     a2a:	15 8e       	std	Z+29, r1	; 0x1d
     a2c:	f8 01       	movw	r30, r16
     a2e:	86 8d       	ldd	r24, Z+30	; 0x1e
     a30:	8f 3f       	cpi	r24, 0xFF	; 255
     a32:	09 f4       	brne	.+2      	; 0xa36 <xQueueGenericSend+0xa8>
     a34:	16 8e       	std	Z+30, r1	; 0x1e
     a36:	0f 90       	pop	r0
     a38:	0f be       	out	0x3f, r0	; 63
     a3a:	be 01       	movw	r22, r28
     a3c:	6c 5f       	subi	r22, 0xFC	; 252
     a3e:	7f 4f       	sbci	r23, 0xFF	; 255
     a40:	ce 01       	movw	r24, r28
     a42:	01 96       	adiw	r24, 0x01	; 1
     a44:	7b d4       	rcall	.+2294   	; 0x133c <xTaskCheckForTimeOut>
     a46:	81 11       	cpse	r24, r1
     a48:	19 c0       	rjmp	.+50     	; 0xa7c <xQueueGenericSend+0xee>
     a4a:	0f b6       	in	r0, 0x3f	; 63
     a4c:	f8 94       	cli
     a4e:	0f 92       	push	r0
     a50:	f8 01       	movw	r30, r16
     a52:	92 8d       	ldd	r25, Z+26	; 0x1a
     a54:	0f 90       	pop	r0
     a56:	0f be       	out	0x3f, r0	; 63
     a58:	83 8d       	ldd	r24, Z+27	; 0x1b
     a5a:	98 13       	cpse	r25, r24
     a5c:	0b c0       	rjmp	.+22     	; 0xa74 <xQueueGenericSend+0xe6>
     a5e:	6c 81       	ldd	r22, Y+4	; 0x04
     a60:	7d 81       	ldd	r23, Y+5	; 0x05
     a62:	c7 01       	movw	r24, r14
     a64:	05 d4       	rcall	.+2058   	; 0x1270 <vTaskPlaceOnEventList>
     a66:	c8 01       	movw	r24, r16
     a68:	01 df       	rcall	.-510    	; 0x86c <prvUnlockQueue>
     a6a:	d0 d2       	rcall	.+1440   	; 0x100c <xTaskResumeAll>
     a6c:	81 11       	cpse	r24, r1
     a6e:	ab cf       	rjmp	.-170    	; 0x9c6 <xQueueGenericSend+0x38>
     a70:	bd dd       	rcall	.-1158   	; 0x5ec <vPortYield>
     a72:	a9 cf       	rjmp	.-174    	; 0x9c6 <xQueueGenericSend+0x38>
     a74:	c8 01       	movw	r24, r16
     a76:	fa de       	rcall	.-524    	; 0x86c <prvUnlockQueue>
     a78:	c9 d2       	rcall	.+1426   	; 0x100c <xTaskResumeAll>
     a7a:	a5 cf       	rjmp	.-182    	; 0x9c6 <xQueueGenericSend+0x38>
     a7c:	c8 01       	movw	r24, r16
     a7e:	f6 de       	rcall	.-532    	; 0x86c <prvUnlockQueue>
     a80:	c5 d2       	rcall	.+1418   	; 0x100c <xTaskResumeAll>
     a82:	80 e0       	ldi	r24, 0x00	; 0
     a84:	0f 90       	pop	r0
     a86:	0f 90       	pop	r0
     a88:	0f 90       	pop	r0
     a8a:	0f 90       	pop	r0
     a8c:	0f 90       	pop	r0
     a8e:	df 91       	pop	r29
     a90:	cf 91       	pop	r28
     a92:	1f 91       	pop	r17
     a94:	0f 91       	pop	r16
     a96:	ff 90       	pop	r15
     a98:	ef 90       	pop	r14
     a9a:	df 90       	pop	r13
     a9c:	cf 90       	pop	r12
     a9e:	bf 90       	pop	r11
     aa0:	af 90       	pop	r10
     aa2:	9f 90       	pop	r9
     aa4:	08 95       	ret

00000aa6 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
     aa6:	9f 92       	push	r9
     aa8:	af 92       	push	r10
     aaa:	bf 92       	push	r11
     aac:	cf 92       	push	r12
     aae:	df 92       	push	r13
     ab0:	ef 92       	push	r14
     ab2:	ff 92       	push	r15
     ab4:	0f 93       	push	r16
     ab6:	1f 93       	push	r17
     ab8:	cf 93       	push	r28
     aba:	df 93       	push	r29
     abc:	00 d0       	rcall	.+0      	; 0xabe <xQueueGenericReceive+0x18>
     abe:	1f 92       	push	r1
     ac0:	1f 92       	push	r1
     ac2:	cd b7       	in	r28, 0x3d	; 61
     ac4:	de b7       	in	r29, 0x3e	; 62
     ac6:	8c 01       	movw	r16, r24
     ac8:	6b 01       	movw	r12, r22
     aca:	5d 83       	std	Y+5, r21	; 0x05
     acc:	4c 83       	std	Y+4, r20	; 0x04
     ace:	92 2e       	mov	r9, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
     ad0:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     ad2:	aa 24       	eor	r10, r10
     ad4:	a3 94       	inc	r10
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     ad6:	7c 01       	movw	r14, r24
     ad8:	81 e1       	ldi	r24, 0x11	; 17
     ada:	e8 0e       	add	r14, r24
     adc:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     ade:	0f b6       	in	r0, 0x3f	; 63
     ae0:	f8 94       	cli
     ae2:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
     ae4:	f8 01       	movw	r30, r16
     ae6:	82 8d       	ldd	r24, Z+26	; 0x1a
     ae8:	88 23       	and	r24, r24
     aea:	21 f1       	breq	.+72     	; 0xb34 <xQueueGenericReceive+0x8e>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
     aec:	e6 80       	ldd	r14, Z+6	; 0x06
     aee:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     af0:	b6 01       	movw	r22, r12
     af2:	c8 01       	movw	r24, r16
     af4:	a2 de       	rcall	.-700    	; 0x83a <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     af6:	91 10       	cpse	r9, r1
     af8:	0e c0       	rjmp	.+28     	; 0xb16 <xQueueGenericReceive+0x70>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
     afa:	f8 01       	movw	r30, r16
     afc:	82 8d       	ldd	r24, Z+26	; 0x1a
     afe:	81 50       	subi	r24, 0x01	; 1
     b00:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     b02:	80 85       	ldd	r24, Z+8	; 0x08
     b04:	88 23       	and	r24, r24
     b06:	91 f0       	breq	.+36     	; 0xb2c <xQueueGenericReceive+0x86>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     b08:	c8 01       	movw	r24, r16
     b0a:	08 96       	adiw	r24, 0x08	; 8
     b0c:	cb d3       	rcall	.+1942   	; 0x12a4 <xTaskRemoveFromEventList>
     b0e:	81 30       	cpi	r24, 0x01	; 1
						{
							portYIELD_WITHIN_API();
     b10:	69 f4       	brne	.+26     	; 0xb2c <xQueueGenericReceive+0x86>
     b12:	6c dd       	rcall	.-1320   	; 0x5ec <vPortYield>
     b14:	0b c0       	rjmp	.+22     	; 0xb2c <xQueueGenericReceive+0x86>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
     b16:	f8 01       	movw	r30, r16
     b18:	f7 82       	std	Z+7, r15	; 0x07
     b1a:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     b1c:	81 89       	ldd	r24, Z+17	; 0x11
     b1e:	88 23       	and	r24, r24
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     b20:	29 f0       	breq	.+10     	; 0xb2c <xQueueGenericReceive+0x86>
     b22:	c8 01       	movw	r24, r16
     b24:	41 96       	adiw	r24, 0x11	; 17
     b26:	be d3       	rcall	.+1916   	; 0x12a4 <xTaskRemoveFromEventList>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
     b28:	81 11       	cpse	r24, r1
     b2a:	60 dd       	rcall	.-1344   	; 0x5ec <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
     b2c:	0f 90       	pop	r0
     b2e:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     b30:	81 e0       	ldi	r24, 0x01	; 1
     b32:	44 c0       	rjmp	.+136    	; 0xbbc <xQueueGenericReceive+0x116>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
     b34:	8c 81       	ldd	r24, Y+4	; 0x04
     b36:	9d 81       	ldd	r25, Y+5	; 0x05
     b38:	89 2b       	or	r24, r25
     b3a:	21 f4       	brne	.+8      	; 0xb44 <xQueueGenericReceive+0x9e>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     b3c:	0f 90       	pop	r0
     b3e:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     b40:	80 e0       	ldi	r24, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
     b42:	3c c0       	rjmp	.+120    	; 0xbbc <xQueueGenericReceive+0x116>
     b44:	b1 10       	cpse	r11, r1
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     b46:	04 c0       	rjmp	.+8      	; 0xb50 <xQueueGenericReceive+0xaa>
     b48:	ce 01       	movw	r24, r28
     b4a:	01 96       	adiw	r24, 0x01	; 1
					xEntryTimeSet = pdTRUE;
     b4c:	ec d3       	rcall	.+2008   	; 0x1326 <vTaskSetTimeOutState>
				}
			}
		}
		taskEXIT_CRITICAL();
     b4e:	ba 2c       	mov	r11, r10
     b50:	0f 90       	pop	r0

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     b52:	0f be       	out	0x3f, r0	; 63
     b54:	8a d1       	rcall	.+788    	; 0xe6a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     b56:	0f b6       	in	r0, 0x3f	; 63
     b58:	f8 94       	cli
     b5a:	0f 92       	push	r0
     b5c:	f8 01       	movw	r30, r16
     b5e:	85 8d       	ldd	r24, Z+29	; 0x1d
     b60:	8f 3f       	cpi	r24, 0xFF	; 255
     b62:	09 f4       	brne	.+2      	; 0xb66 <xQueueGenericReceive+0xc0>
     b64:	15 8e       	std	Z+29, r1	; 0x1d
     b66:	f8 01       	movw	r30, r16
     b68:	86 8d       	ldd	r24, Z+30	; 0x1e
     b6a:	8f 3f       	cpi	r24, 0xFF	; 255
     b6c:	09 f4       	brne	.+2      	; 0xb70 <xQueueGenericReceive+0xca>
     b6e:	16 8e       	std	Z+30, r1	; 0x1e
     b70:	0f 90       	pop	r0

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     b72:	0f be       	out	0x3f, r0	; 63
     b74:	be 01       	movw	r22, r28
     b76:	6c 5f       	subi	r22, 0xFC	; 252
     b78:	7f 4f       	sbci	r23, 0xFF	; 255
     b7a:	ce 01       	movw	r24, r28
     b7c:	01 96       	adiw	r24, 0x01	; 1
     b7e:	de d3       	rcall	.+1980   	; 0x133c <xTaskCheckForTimeOut>
     b80:	81 11       	cpse	r24, r1
     b82:	18 c0       	rjmp	.+48     	; 0xbb4 <xQueueGenericReceive+0x10e>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
     b84:	0f b6       	in	r0, 0x3f	; 63
     b86:	f8 94       	cli
     b88:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
     b8a:	f8 01       	movw	r30, r16
	taskEXIT_CRITICAL();
     b8c:	82 8d       	ldd	r24, Z+26	; 0x1a
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     b8e:	0f 90       	pop	r0
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     b90:	0f be       	out	0x3f, r0	; 63
     b92:	81 11       	cpse	r24, r1
     b94:	0b c0       	rjmp	.+22     	; 0xbac <xQueueGenericReceive+0x106>
     b96:	6c 81       	ldd	r22, Y+4	; 0x04
				prvUnlockQueue( pxQueue );
     b98:	7d 81       	ldd	r23, Y+5	; 0x05
     b9a:	c7 01       	movw	r24, r14
				if( xTaskResumeAll() == pdFALSE )
     b9c:	69 d3       	rcall	.+1746   	; 0x1270 <vTaskPlaceOnEventList>
     b9e:	c8 01       	movw	r24, r16
				{
					portYIELD_WITHIN_API();
     ba0:	65 de       	rcall	.-822    	; 0x86c <prvUnlockQueue>
     ba2:	34 d2       	rcall	.+1128   	; 0x100c <xTaskResumeAll>
     ba4:	81 11       	cpse	r24, r1
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     ba6:	9b cf       	rjmp	.-202    	; 0xade <xQueueGenericReceive+0x38>
     ba8:	21 dd       	rcall	.-1470   	; 0x5ec <vPortYield>
     baa:	99 cf       	rjmp	.-206    	; 0xade <xQueueGenericReceive+0x38>
				( void ) xTaskResumeAll();
     bac:	c8 01       	movw	r24, r16
     bae:	5e de       	rcall	.-836    	; 0x86c <prvUnlockQueue>
     bb0:	2d d2       	rcall	.+1114   	; 0x100c <xTaskResumeAll>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     bb2:	95 cf       	rjmp	.-214    	; 0xade <xQueueGenericReceive+0x38>
     bb4:	c8 01       	movw	r24, r16
     bb6:	5a de       	rcall	.-844    	; 0x86c <prvUnlockQueue>
			( void ) xTaskResumeAll();
     bb8:	29 d2       	rcall	.+1106   	; 0x100c <xTaskResumeAll>
     bba:	80 e0       	ldi	r24, 0x00	; 0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
     bbc:	0f 90       	pop	r0
		}
	}
}
     bbe:	0f 90       	pop	r0
     bc0:	0f 90       	pop	r0
     bc2:	0f 90       	pop	r0
     bc4:	0f 90       	pop	r0
     bc6:	df 91       	pop	r29
     bc8:	cf 91       	pop	r28
     bca:	1f 91       	pop	r17
     bcc:	0f 91       	pop	r16
     bce:	ff 90       	pop	r15
     bd0:	ef 90       	pop	r14
     bd2:	df 90       	pop	r13
     bd4:	cf 90       	pop	r12
     bd6:	bf 90       	pop	r11
     bd8:	af 90       	pop	r10
     bda:	9f 90       	pop	r9
     bdc:	08 95       	ret

00000bde <prvIdleTask>:
     bde:	cc e2       	ldi	r28, 0x2C	; 44
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
     be0:	d8 e0       	ldi	r29, 0x08	; 8
     be2:	88 81       	ld	r24, Y
     be4:	82 30       	cpi	r24, 0x02	; 2
     be6:	e8 f3       	brcs	.-6      	; 0xbe2 <prvIdleTask+0x4>
     be8:	01 dd       	rcall	.-1534   	; 0x5ec <vPortYield>
     bea:	fb cf       	rjmp	.-10     	; 0xbe2 <prvIdleTask+0x4>

00000bec <prvAddCurrentTaskToDelayedList>:
     bec:	cf 93       	push	r28
     bee:	df 93       	push	r29
     bf0:	ec 01       	movw	r28, r24
     bf2:	e0 91 35 08 	lds	r30, 0x0835	; 0x800835 <pxCurrentTCB>
     bf6:	f0 91 36 08 	lds	r31, 0x0836	; 0x800836 <pxCurrentTCB+0x1>
     bfa:	93 83       	std	Z+3, r25	; 0x03
     bfc:	82 83       	std	Z+2, r24	; 0x02
     bfe:	80 91 0a 08 	lds	r24, 0x080A	; 0x80080a <xTickCount>
     c02:	90 91 0b 08 	lds	r25, 0x080B	; 0x80080b <xTickCount+0x1>
     c06:	c8 17       	cp	r28, r24
     c08:	d9 07       	cpc	r29, r25
     c0a:	60 f4       	brcc	.+24     	; 0xc24 <prvAddCurrentTaskToDelayedList+0x38>
     c0c:	60 91 35 08 	lds	r22, 0x0835	; 0x800835 <pxCurrentTCB>
     c10:	70 91 36 08 	lds	r23, 0x0836	; 0x800836 <pxCurrentTCB+0x1>
     c14:	80 91 16 08 	lds	r24, 0x0816	; 0x800816 <pxOverflowDelayedTaskList>
     c18:	90 91 17 08 	lds	r25, 0x0817	; 0x800817 <pxOverflowDelayedTaskList+0x1>
     c1c:	6e 5f       	subi	r22, 0xFE	; 254
     c1e:	7f 4f       	sbci	r23, 0xFF	; 255
     c20:	d4 db       	rcall	.-2136   	; 0x3ca <vListInsert>
     c22:	16 c0       	rjmp	.+44     	; 0xc50 <prvAddCurrentTaskToDelayedList+0x64>
     c24:	60 91 35 08 	lds	r22, 0x0835	; 0x800835 <pxCurrentTCB>
     c28:	70 91 36 08 	lds	r23, 0x0836	; 0x800836 <pxCurrentTCB+0x1>
     c2c:	80 91 18 08 	lds	r24, 0x0818	; 0x800818 <pxDelayedTaskList>
     c30:	90 91 19 08 	lds	r25, 0x0819	; 0x800819 <pxDelayedTaskList+0x1>
     c34:	6e 5f       	subi	r22, 0xFE	; 254
     c36:	7f 4f       	sbci	r23, 0xFF	; 255
     c38:	c8 db       	rcall	.-2160   	; 0x3ca <vListInsert>
     c3a:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <__DATA_REGION_ORIGIN__>
     c3e:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
     c42:	c8 17       	cp	r28, r24
     c44:	d9 07       	cpc	r29, r25
     c46:	20 f4       	brcc	.+8      	; 0xc50 <prvAddCurrentTaskToDelayedList+0x64>
     c48:	d0 93 01 02 	sts	0x0201, r29	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
     c4c:	c0 93 00 02 	sts	0x0200, r28	; 0x800200 <__DATA_REGION_ORIGIN__>
     c50:	df 91       	pop	r29
     c52:	cf 91       	pop	r28
     c54:	08 95       	ret

00000c56 <xTaskGenericCreate>:
     c56:	4f 92       	push	r4
     c58:	5f 92       	push	r5
     c5a:	6f 92       	push	r6
     c5c:	7f 92       	push	r7
     c5e:	8f 92       	push	r8
     c60:	9f 92       	push	r9
     c62:	af 92       	push	r10
     c64:	bf 92       	push	r11
     c66:	cf 92       	push	r12
     c68:	df 92       	push	r13
     c6a:	ef 92       	push	r14
     c6c:	ff 92       	push	r15
     c6e:	0f 93       	push	r16
     c70:	cf 93       	push	r28
     c72:	df 93       	push	r29
     c74:	5c 01       	movw	r10, r24
     c76:	4b 01       	movw	r8, r22
     c78:	3a 01       	movw	r6, r20
     c7a:	29 01       	movw	r4, r18
     c7c:	81 e2       	ldi	r24, 0x21	; 33
     c7e:	90 e0       	ldi	r25, 0x00	; 0
     c80:	78 dd       	rcall	.-1296   	; 0x772 <pvPortMalloc>
     c82:	ec 01       	movw	r28, r24
     c84:	89 2b       	or	r24, r25
     c86:	09 f4       	brne	.+2      	; 0xc8a <xTaskGenericCreate+0x34>
     c88:	9c c0       	rjmp	.+312    	; 0xdc2 <xTaskGenericCreate+0x16c>
     c8a:	c1 14       	cp	r12, r1
     c8c:	d1 04       	cpc	r13, r1
     c8e:	09 f0       	breq	.+2      	; 0xc92 <xTaskGenericCreate+0x3c>
     c90:	94 c0       	rjmp	.+296    	; 0xdba <xTaskGenericCreate+0x164>
     c92:	c3 01       	movw	r24, r6
     c94:	6e dd       	rcall	.-1316   	; 0x772 <pvPortMalloc>
     c96:	98 8f       	std	Y+24, r25	; 0x18
     c98:	8f 8b       	std	Y+23, r24	; 0x17
     c9a:	00 97       	sbiw	r24, 0x00	; 0
     c9c:	19 f4       	brne	.+6      	; 0xca4 <xTaskGenericCreate+0x4e>
     c9e:	ce 01       	movw	r24, r28
     ca0:	8c dd       	rcall	.-1256   	; 0x7ba <vPortFree>
     ca2:	8f c0       	rjmp	.+286    	; 0xdc2 <xTaskGenericCreate+0x16c>
     ca4:	a3 01       	movw	r20, r6
     ca6:	65 ea       	ldi	r22, 0xA5	; 165
     ca8:	70 e0       	ldi	r23, 0x00	; 0
     caa:	8b d3       	rcall	.+1814   	; 0x13c2 <memset>
     cac:	93 01       	movw	r18, r6
     cae:	21 50       	subi	r18, 0x01	; 1
     cb0:	31 09       	sbc	r19, r1
     cb2:	8f 89       	ldd	r24, Y+23	; 0x17
     cb4:	98 8d       	ldd	r25, Y+24	; 0x18
     cb6:	3c 01       	movw	r6, r24
     cb8:	62 0e       	add	r6, r18
     cba:	73 1e       	adc	r7, r19
     cbc:	48 e0       	ldi	r20, 0x08	; 8
     cbe:	50 e0       	ldi	r21, 0x00	; 0
     cc0:	b4 01       	movw	r22, r8
     cc2:	ce 01       	movw	r24, r28
     cc4:	49 96       	adiw	r24, 0x19	; 25
     cc6:	84 d3       	rcall	.+1800   	; 0x13d0 <strncpy>
     cc8:	18 a2       	std	Y+32, r1	; 0x20
     cca:	1e 8a       	std	Y+22, r1	; 0x16
     ccc:	6e 01       	movw	r12, r28
     cce:	82 e0       	ldi	r24, 0x02	; 2
     cd0:	c8 0e       	add	r12, r24
     cd2:	d1 1c       	adc	r13, r1
     cd4:	c6 01       	movw	r24, r12
     cd6:	4e db       	rcall	.-2404   	; 0x374 <vListInitialiseItem>
     cd8:	ce 01       	movw	r24, r28
     cda:	0c 96       	adiw	r24, 0x0c	; 12
     cdc:	4b db       	rcall	.-2410   	; 0x374 <vListInitialiseItem>
     cde:	d9 87       	std	Y+9, r29	; 0x09
     ce0:	c8 87       	std	Y+8, r28	; 0x08
     ce2:	81 e0       	ldi	r24, 0x01	; 1
     ce4:	90 e0       	ldi	r25, 0x00	; 0
     ce6:	9d 87       	std	Y+13, r25	; 0x0d
     ce8:	8c 87       	std	Y+12, r24	; 0x0c
     cea:	db 8b       	std	Y+19, r29	; 0x13
     cec:	ca 8b       	std	Y+18, r28	; 0x12
     cee:	a2 01       	movw	r20, r4
     cf0:	b5 01       	movw	r22, r10
     cf2:	c3 01       	movw	r24, r6
     cf4:	cb db       	rcall	.-2154   	; 0x48c <pxPortInitialiseStack>
     cf6:	99 83       	std	Y+1, r25	; 0x01
     cf8:	88 83       	st	Y, r24
     cfa:	e1 14       	cp	r14, r1
     cfc:	f1 04       	cpc	r15, r1
     cfe:	19 f0       	breq	.+6      	; 0xd06 <xTaskGenericCreate+0xb0>
     d00:	f7 01       	movw	r30, r14
     d02:	d1 83       	std	Z+1, r29	; 0x01
     d04:	c0 83       	st	Z, r28
     d06:	0f b6       	in	r0, 0x3f	; 63
     d08:	f8 94       	cli
     d0a:	0f 92       	push	r0
     d0c:	80 91 0c 08 	lds	r24, 0x080C	; 0x80080c <uxCurrentNumberOfTasks>
     d10:	8f 5f       	subi	r24, 0xFF	; 255
     d12:	80 93 0c 08 	sts	0x080C, r24	; 0x80080c <uxCurrentNumberOfTasks>
     d16:	80 91 35 08 	lds	r24, 0x0835	; 0x800835 <pxCurrentTCB>
     d1a:	90 91 36 08 	lds	r25, 0x0836	; 0x800836 <pxCurrentTCB+0x1>
     d1e:	89 2b       	or	r24, r25
     d20:	49 f4       	brne	.+18     	; 0xd34 <xTaskGenericCreate+0xde>
     d22:	d0 93 36 08 	sts	0x0836, r29	; 0x800836 <pxCurrentTCB+0x1>
     d26:	c0 93 35 08 	sts	0x0835, r28	; 0x800835 <pxCurrentTCB>
     d2a:	80 91 0c 08 	lds	r24, 0x080C	; 0x80080c <uxCurrentNumberOfTasks>
     d2e:	81 30       	cpi	r24, 0x01	; 1
     d30:	81 f4       	brne	.+32     	; 0xd52 <xTaskGenericCreate+0xfc>
     d32:	49 c0       	rjmp	.+146    	; 0xdc6 <xTaskGenericCreate+0x170>
     d34:	80 91 07 08 	lds	r24, 0x0807	; 0x800807 <xSchedulerRunning>
     d38:	81 11       	cpse	r24, r1
     d3a:	0b c0       	rjmp	.+22     	; 0xd52 <xTaskGenericCreate+0xfc>
     d3c:	e0 91 35 08 	lds	r30, 0x0835	; 0x800835 <pxCurrentTCB>
     d40:	f0 91 36 08 	lds	r31, 0x0836	; 0x800836 <pxCurrentTCB+0x1>
     d44:	86 89       	ldd	r24, Z+22	; 0x16
     d46:	08 17       	cp	r16, r24
     d48:	20 f0       	brcs	.+8      	; 0xd52 <xTaskGenericCreate+0xfc>
     d4a:	d0 93 36 08 	sts	0x0836, r29	; 0x800836 <pxCurrentTCB+0x1>
     d4e:	c0 93 35 08 	sts	0x0835, r28	; 0x800835 <pxCurrentTCB>
     d52:	8e 89       	ldd	r24, Y+22	; 0x16
     d54:	90 91 09 08 	lds	r25, 0x0809	; 0x800809 <uxTopUsedPriority>
     d58:	98 17       	cp	r25, r24
     d5a:	10 f4       	brcc	.+4      	; 0xd60 <xTaskGenericCreate+0x10a>
     d5c:	80 93 09 08 	sts	0x0809, r24	; 0x800809 <uxTopUsedPriority>
     d60:	90 91 02 08 	lds	r25, 0x0802	; 0x800802 <uxTCBNumber>
     d64:	9f 5f       	subi	r25, 0xFF	; 255
     d66:	90 93 02 08 	sts	0x0802, r25	; 0x800802 <uxTCBNumber>
     d6a:	90 91 08 08 	lds	r25, 0x0808	; 0x800808 <uxTopReadyPriority>
     d6e:	98 17       	cp	r25, r24
     d70:	10 f4       	brcc	.+4      	; 0xd76 <xTaskGenericCreate+0x120>
     d72:	80 93 08 08 	sts	0x0808, r24	; 0x800808 <uxTopReadyPriority>
     d76:	90 e0       	ldi	r25, 0x00	; 0
     d78:	9c 01       	movw	r18, r24
     d7a:	22 0f       	add	r18, r18
     d7c:	33 1f       	adc	r19, r19
     d7e:	22 0f       	add	r18, r18
     d80:	33 1f       	adc	r19, r19
     d82:	22 0f       	add	r18, r18
     d84:	33 1f       	adc	r19, r19
     d86:	82 0f       	add	r24, r18
     d88:	93 1f       	adc	r25, r19
     d8a:	b6 01       	movw	r22, r12
     d8c:	84 5d       	subi	r24, 0xD4	; 212
     d8e:	97 4f       	sbci	r25, 0xF7	; 247
     d90:	f5 da       	rcall	.-2582   	; 0x37c <vListInsertEnd>
     d92:	0f 90       	pop	r0
     d94:	0f be       	out	0x3f, r0	; 63
     d96:	80 91 07 08 	lds	r24, 0x0807	; 0x800807 <xSchedulerRunning>
     d9a:	88 23       	and	r24, r24
     d9c:	51 f0       	breq	.+20     	; 0xdb2 <xTaskGenericCreate+0x15c>
     d9e:	e0 91 35 08 	lds	r30, 0x0835	; 0x800835 <pxCurrentTCB>
     da2:	f0 91 36 08 	lds	r31, 0x0836	; 0x800836 <pxCurrentTCB+0x1>
     da6:	86 89       	ldd	r24, Z+22	; 0x16
     da8:	80 17       	cp	r24, r16
     daa:	28 f4       	brcc	.+10     	; 0xdb6 <xTaskGenericCreate+0x160>
     dac:	1f dc       	rcall	.-1986   	; 0x5ec <vPortYield>
     dae:	81 e0       	ldi	r24, 0x01	; 1
     db0:	23 c0       	rjmp	.+70     	; 0xdf8 <xTaskGenericCreate+0x1a2>
     db2:	81 e0       	ldi	r24, 0x01	; 1
     db4:	21 c0       	rjmp	.+66     	; 0xdf8 <xTaskGenericCreate+0x1a2>
     db6:	81 e0       	ldi	r24, 0x01	; 1
     db8:	1f c0       	rjmp	.+62     	; 0xdf8 <xTaskGenericCreate+0x1a2>
     dba:	d8 8e       	std	Y+24, r13	; 0x18
     dbc:	cf 8a       	std	Y+23, r12	; 0x17
     dbe:	c6 01       	movw	r24, r12
     dc0:	71 cf       	rjmp	.-286    	; 0xca4 <xTaskGenericCreate+0x4e>
     dc2:	8f ef       	ldi	r24, 0xFF	; 255
     dc4:	19 c0       	rjmp	.+50     	; 0xdf8 <xTaskGenericCreate+0x1a2>
     dc6:	8c e2       	ldi	r24, 0x2C	; 44
     dc8:	98 e0       	ldi	r25, 0x08	; 8
     dca:	c6 da       	rcall	.-2676   	; 0x358 <vListInitialise>
     dcc:	83 e2       	ldi	r24, 0x23	; 35
     dce:	98 e0       	ldi	r25, 0x08	; 8
     dd0:	c3 da       	rcall	.-2682   	; 0x358 <vListInitialise>
     dd2:	8a e1       	ldi	r24, 0x1A	; 26
     dd4:	98 e0       	ldi	r25, 0x08	; 8
     dd6:	c0 da       	rcall	.-2688   	; 0x358 <vListInitialise>
     dd8:	8d e0       	ldi	r24, 0x0D	; 13
     dda:	98 e0       	ldi	r25, 0x08	; 8
     ddc:	bd da       	rcall	.-2694   	; 0x358 <vListInitialise>
     dde:	83 e2       	ldi	r24, 0x23	; 35
     de0:	98 e0       	ldi	r25, 0x08	; 8
     de2:	90 93 19 08 	sts	0x0819, r25	; 0x800819 <pxDelayedTaskList+0x1>
     de6:	80 93 18 08 	sts	0x0818, r24	; 0x800818 <pxDelayedTaskList>
     dea:	8a e1       	ldi	r24, 0x1A	; 26
     dec:	98 e0       	ldi	r25, 0x08	; 8
     dee:	90 93 17 08 	sts	0x0817, r25	; 0x800817 <pxOverflowDelayedTaskList+0x1>
     df2:	80 93 16 08 	sts	0x0816, r24	; 0x800816 <pxOverflowDelayedTaskList>
     df6:	ad cf       	rjmp	.-166    	; 0xd52 <xTaskGenericCreate+0xfc>
     df8:	df 91       	pop	r29
     dfa:	cf 91       	pop	r28
     dfc:	0f 91       	pop	r16
     dfe:	ff 90       	pop	r15
     e00:	ef 90       	pop	r14
     e02:	df 90       	pop	r13
     e04:	cf 90       	pop	r12
     e06:	bf 90       	pop	r11
     e08:	af 90       	pop	r10
     e0a:	9f 90       	pop	r9
     e0c:	8f 90       	pop	r8
     e0e:	7f 90       	pop	r7
     e10:	6f 90       	pop	r6
     e12:	5f 90       	pop	r5
     e14:	4f 90       	pop	r4
     e16:	08 95       	ret

00000e18 <vTaskStartScheduler>:
     e18:	af 92       	push	r10
     e1a:	bf 92       	push	r11
     e1c:	cf 92       	push	r12
     e1e:	df 92       	push	r13
     e20:	ef 92       	push	r14
     e22:	ff 92       	push	r15
     e24:	0f 93       	push	r16
     e26:	a1 2c       	mov	r10, r1
     e28:	b1 2c       	mov	r11, r1
     e2a:	c1 2c       	mov	r12, r1
     e2c:	d1 2c       	mov	r13, r1
     e2e:	e1 2c       	mov	r14, r1
     e30:	f1 2c       	mov	r15, r1
     e32:	00 e0       	ldi	r16, 0x00	; 0
     e34:	20 e0       	ldi	r18, 0x00	; 0
     e36:	30 e0       	ldi	r19, 0x00	; 0
     e38:	45 e5       	ldi	r20, 0x55	; 85
     e3a:	50 e0       	ldi	r21, 0x00	; 0
     e3c:	6d e1       	ldi	r22, 0x1D	; 29
     e3e:	72 e0       	ldi	r23, 0x02	; 2
     e40:	8f ee       	ldi	r24, 0xEF	; 239
     e42:	95 e0       	ldi	r25, 0x05	; 5
     e44:	08 df       	rcall	.-496    	; 0xc56 <xTaskGenericCreate>
     e46:	81 30       	cpi	r24, 0x01	; 1
     e48:	41 f4       	brne	.+16     	; 0xe5a <vTaskStartScheduler+0x42>
     e4a:	f8 94       	cli
     e4c:	80 93 07 08 	sts	0x0807, r24	; 0x800807 <xSchedulerRunning>
     e50:	10 92 0b 08 	sts	0x080B, r1	; 0x80080b <xTickCount+0x1>
     e54:	10 92 0a 08 	sts	0x080A, r1	; 0x80080a <xTickCount>
     e58:	8b db       	rcall	.-2282   	; 0x570 <xPortStartScheduler>
     e5a:	0f 91       	pop	r16
     e5c:	ff 90       	pop	r15
     e5e:	ef 90       	pop	r14
     e60:	df 90       	pop	r13
     e62:	cf 90       	pop	r12
     e64:	bf 90       	pop	r11
     e66:	af 90       	pop	r10
     e68:	08 95       	ret

00000e6a <vTaskSuspendAll>:
     e6a:	80 91 06 08 	lds	r24, 0x0806	; 0x800806 <uxSchedulerSuspended>
     e6e:	8f 5f       	subi	r24, 0xFF	; 255
     e70:	80 93 06 08 	sts	0x0806, r24	; 0x800806 <uxSchedulerSuspended>
     e74:	08 95       	ret

00000e76 <xTaskGetTickCount>:
     e76:	0f b6       	in	r0, 0x3f	; 63
     e78:	f8 94       	cli
     e7a:	0f 92       	push	r0
     e7c:	80 91 0a 08 	lds	r24, 0x080A	; 0x80080a <xTickCount>
     e80:	90 91 0b 08 	lds	r25, 0x080B	; 0x80080b <xTickCount+0x1>
     e84:	0f 90       	pop	r0
     e86:	0f be       	out	0x3f, r0	; 63
     e88:	08 95       	ret

00000e8a <vTaskIncrementTick>:
     e8a:	0f 93       	push	r16
     e8c:	1f 93       	push	r17
     e8e:	cf 93       	push	r28
     e90:	df 93       	push	r29
     e92:	80 91 06 08 	lds	r24, 0x0806	; 0x800806 <uxSchedulerSuspended>
     e96:	81 11       	cpse	r24, r1
     e98:	af c0       	rjmp	.+350    	; 0xff8 <vTaskIncrementTick+0x16e>
     e9a:	80 91 0a 08 	lds	r24, 0x080A	; 0x80080a <xTickCount>
     e9e:	90 91 0b 08 	lds	r25, 0x080B	; 0x80080b <xTickCount+0x1>
     ea2:	01 96       	adiw	r24, 0x01	; 1
     ea4:	90 93 0b 08 	sts	0x080B, r25	; 0x80080b <xTickCount+0x1>
     ea8:	80 93 0a 08 	sts	0x080A, r24	; 0x80080a <xTickCount>
     eac:	80 91 0a 08 	lds	r24, 0x080A	; 0x80080a <xTickCount>
     eb0:	90 91 0b 08 	lds	r25, 0x080B	; 0x80080b <xTickCount+0x1>
     eb4:	89 2b       	or	r24, r25
     eb6:	99 f5       	brne	.+102    	; 0xf1e <vTaskIncrementTick+0x94>
     eb8:	80 91 18 08 	lds	r24, 0x0818	; 0x800818 <pxDelayedTaskList>
     ebc:	90 91 19 08 	lds	r25, 0x0819	; 0x800819 <pxDelayedTaskList+0x1>
     ec0:	20 91 16 08 	lds	r18, 0x0816	; 0x800816 <pxOverflowDelayedTaskList>
     ec4:	30 91 17 08 	lds	r19, 0x0817	; 0x800817 <pxOverflowDelayedTaskList+0x1>
     ec8:	30 93 19 08 	sts	0x0819, r19	; 0x800819 <pxDelayedTaskList+0x1>
     ecc:	20 93 18 08 	sts	0x0818, r18	; 0x800818 <pxDelayedTaskList>
     ed0:	90 93 17 08 	sts	0x0817, r25	; 0x800817 <pxOverflowDelayedTaskList+0x1>
     ed4:	80 93 16 08 	sts	0x0816, r24	; 0x800816 <pxOverflowDelayedTaskList>
     ed8:	80 91 03 08 	lds	r24, 0x0803	; 0x800803 <xNumOfOverflows>
     edc:	8f 5f       	subi	r24, 0xFF	; 255
     ede:	80 93 03 08 	sts	0x0803, r24	; 0x800803 <xNumOfOverflows>
     ee2:	e0 91 18 08 	lds	r30, 0x0818	; 0x800818 <pxDelayedTaskList>
     ee6:	f0 91 19 08 	lds	r31, 0x0819	; 0x800819 <pxDelayedTaskList+0x1>
     eea:	80 81       	ld	r24, Z
     eec:	81 11       	cpse	r24, r1
     eee:	07 c0       	rjmp	.+14     	; 0xefe <vTaskIncrementTick+0x74>
     ef0:	8f ef       	ldi	r24, 0xFF	; 255
     ef2:	9f ef       	ldi	r25, 0xFF	; 255
     ef4:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
     ef8:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <__DATA_REGION_ORIGIN__>
     efc:	10 c0       	rjmp	.+32     	; 0xf1e <vTaskIncrementTick+0x94>
     efe:	e0 91 18 08 	lds	r30, 0x0818	; 0x800818 <pxDelayedTaskList>
     f02:	f0 91 19 08 	lds	r31, 0x0819	; 0x800819 <pxDelayedTaskList+0x1>
     f06:	05 80       	ldd	r0, Z+5	; 0x05
     f08:	f6 81       	ldd	r31, Z+6	; 0x06
     f0a:	e0 2d       	mov	r30, r0
     f0c:	06 80       	ldd	r0, Z+6	; 0x06
     f0e:	f7 81       	ldd	r31, Z+7	; 0x07
     f10:	e0 2d       	mov	r30, r0
     f12:	82 81       	ldd	r24, Z+2	; 0x02
     f14:	93 81       	ldd	r25, Z+3	; 0x03
     f16:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
     f1a:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <__DATA_REGION_ORIGIN__>
     f1e:	20 91 0a 08 	lds	r18, 0x080A	; 0x80080a <xTickCount>
     f22:	30 91 0b 08 	lds	r19, 0x080B	; 0x80080b <xTickCount+0x1>
     f26:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <__DATA_REGION_ORIGIN__>
     f2a:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
     f2e:	28 17       	cp	r18, r24
     f30:	39 07       	cpc	r19, r25
     f32:	08 f4       	brcc	.+2      	; 0xf36 <vTaskIncrementTick+0xac>
     f34:	66 c0       	rjmp	.+204    	; 0x1002 <__EEPROM_REGION_LENGTH__+0x2>
     f36:	e0 91 18 08 	lds	r30, 0x0818	; 0x800818 <pxDelayedTaskList>
     f3a:	f0 91 19 08 	lds	r31, 0x0819	; 0x800819 <pxDelayedTaskList+0x1>
     f3e:	80 81       	ld	r24, Z
     f40:	88 23       	and	r24, r24
     f42:	99 f0       	breq	.+38     	; 0xf6a <vTaskIncrementTick+0xe0>
     f44:	e0 91 18 08 	lds	r30, 0x0818	; 0x800818 <pxDelayedTaskList>
     f48:	f0 91 19 08 	lds	r31, 0x0819	; 0x800819 <pxDelayedTaskList+0x1>
     f4c:	05 80       	ldd	r0, Z+5	; 0x05
     f4e:	f6 81       	ldd	r31, Z+6	; 0x06
     f50:	e0 2d       	mov	r30, r0
     f52:	c6 81       	ldd	r28, Z+6	; 0x06
     f54:	d7 81       	ldd	r29, Z+7	; 0x07
     f56:	8a 81       	ldd	r24, Y+2	; 0x02
     f58:	9b 81       	ldd	r25, Y+3	; 0x03
     f5a:	20 91 0a 08 	lds	r18, 0x080A	; 0x80080a <xTickCount>
     f5e:	30 91 0b 08 	lds	r19, 0x080B	; 0x80080b <xTickCount+0x1>
     f62:	28 17       	cp	r18, r24
     f64:	39 07       	cpc	r19, r25
     f66:	f8 f4       	brcc	.+62     	; 0xfa6 <vTaskIncrementTick+0x11c>
     f68:	19 c0       	rjmp	.+50     	; 0xf9c <vTaskIncrementTick+0x112>
     f6a:	8f ef       	ldi	r24, 0xFF	; 255
     f6c:	9f ef       	ldi	r25, 0xFF	; 255
     f6e:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
     f72:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <__DATA_REGION_ORIGIN__>
     f76:	45 c0       	rjmp	.+138    	; 0x1002 <__EEPROM_REGION_LENGTH__+0x2>
     f78:	e0 91 18 08 	lds	r30, 0x0818	; 0x800818 <pxDelayedTaskList>
     f7c:	f0 91 19 08 	lds	r31, 0x0819	; 0x800819 <pxDelayedTaskList+0x1>
     f80:	05 80       	ldd	r0, Z+5	; 0x05
     f82:	f6 81       	ldd	r31, Z+6	; 0x06
     f84:	e0 2d       	mov	r30, r0
     f86:	c6 81       	ldd	r28, Z+6	; 0x06
     f88:	d7 81       	ldd	r29, Z+7	; 0x07
     f8a:	8a 81       	ldd	r24, Y+2	; 0x02
     f8c:	9b 81       	ldd	r25, Y+3	; 0x03
     f8e:	20 91 0a 08 	lds	r18, 0x080A	; 0x80080a <xTickCount>
     f92:	30 91 0b 08 	lds	r19, 0x080B	; 0x80080b <xTickCount+0x1>
     f96:	28 17       	cp	r18, r24
     f98:	39 07       	cpc	r19, r25
     f9a:	28 f4       	brcc	.+10     	; 0xfa6 <vTaskIncrementTick+0x11c>
     f9c:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <__DATA_REGION_ORIGIN__+0x1>
     fa0:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <__DATA_REGION_ORIGIN__>
     fa4:	2e c0       	rjmp	.+92     	; 0x1002 <__EEPROM_REGION_LENGTH__+0x2>
     fa6:	8e 01       	movw	r16, r28
     fa8:	0e 5f       	subi	r16, 0xFE	; 254
     faa:	1f 4f       	sbci	r17, 0xFF	; 255
     fac:	c8 01       	movw	r24, r16
     fae:	48 da       	rcall	.-2928   	; 0x440 <vListRemove>
     fb0:	8c 89       	ldd	r24, Y+20	; 0x14
     fb2:	9d 89       	ldd	r25, Y+21	; 0x15
     fb4:	89 2b       	or	r24, r25
     fb6:	19 f0       	breq	.+6      	; 0xfbe <vTaskIncrementTick+0x134>
     fb8:	ce 01       	movw	r24, r28
     fba:	0c 96       	adiw	r24, 0x0c	; 12
     fbc:	41 da       	rcall	.-2942   	; 0x440 <vListRemove>
     fbe:	8e 89       	ldd	r24, Y+22	; 0x16
     fc0:	90 91 08 08 	lds	r25, 0x0808	; 0x800808 <uxTopReadyPriority>
     fc4:	98 17       	cp	r25, r24
     fc6:	10 f4       	brcc	.+4      	; 0xfcc <vTaskIncrementTick+0x142>
     fc8:	80 93 08 08 	sts	0x0808, r24	; 0x800808 <uxTopReadyPriority>
     fcc:	90 e0       	ldi	r25, 0x00	; 0
     fce:	9c 01       	movw	r18, r24
     fd0:	22 0f       	add	r18, r18
     fd2:	33 1f       	adc	r19, r19
     fd4:	22 0f       	add	r18, r18
     fd6:	33 1f       	adc	r19, r19
     fd8:	22 0f       	add	r18, r18
     fda:	33 1f       	adc	r19, r19
     fdc:	82 0f       	add	r24, r18
     fde:	93 1f       	adc	r25, r19
     fe0:	b8 01       	movw	r22, r16
     fe2:	84 5d       	subi	r24, 0xD4	; 212
     fe4:	97 4f       	sbci	r25, 0xF7	; 247
     fe6:	ca d9       	rcall	.-3180   	; 0x37c <vListInsertEnd>
     fe8:	e0 91 18 08 	lds	r30, 0x0818	; 0x800818 <pxDelayedTaskList>
     fec:	f0 91 19 08 	lds	r31, 0x0819	; 0x800819 <pxDelayedTaskList+0x1>
     ff0:	80 81       	ld	r24, Z
     ff2:	81 11       	cpse	r24, r1
     ff4:	c1 cf       	rjmp	.-126    	; 0xf78 <vTaskIncrementTick+0xee>
     ff6:	b9 cf       	rjmp	.-142    	; 0xf6a <vTaskIncrementTick+0xe0>
     ff8:	80 91 05 08 	lds	r24, 0x0805	; 0x800805 <uxMissedTicks>
     ffc:	8f 5f       	subi	r24, 0xFF	; 255
     ffe:	80 93 05 08 	sts	0x0805, r24	; 0x800805 <uxMissedTicks>
    1002:	df 91       	pop	r29
    1004:	cf 91       	pop	r28
    1006:	1f 91       	pop	r17
    1008:	0f 91       	pop	r16
    100a:	08 95       	ret

0000100c <xTaskResumeAll>:
    100c:	cf 92       	push	r12
    100e:	df 92       	push	r13
    1010:	ef 92       	push	r14
    1012:	ff 92       	push	r15
    1014:	0f 93       	push	r16
    1016:	1f 93       	push	r17
    1018:	cf 93       	push	r28
    101a:	df 93       	push	r29
    101c:	0f b6       	in	r0, 0x3f	; 63
    101e:	f8 94       	cli
    1020:	0f 92       	push	r0
    1022:	80 91 06 08 	lds	r24, 0x0806	; 0x800806 <uxSchedulerSuspended>
    1026:	81 50       	subi	r24, 0x01	; 1
    1028:	80 93 06 08 	sts	0x0806, r24	; 0x800806 <uxSchedulerSuspended>
    102c:	80 91 06 08 	lds	r24, 0x0806	; 0x800806 <uxSchedulerSuspended>
    1030:	81 11       	cpse	r24, r1
    1032:	5f c0       	rjmp	.+190    	; 0x10f2 <xTaskResumeAll+0xe6>
    1034:	80 91 0c 08 	lds	r24, 0x080C	; 0x80080c <uxCurrentNumberOfTasks>
    1038:	81 11       	cpse	r24, r1
    103a:	2f c0       	rjmp	.+94     	; 0x109a <xTaskResumeAll+0x8e>
    103c:	5d c0       	rjmp	.+186    	; 0x10f8 <xTaskResumeAll+0xec>
    103e:	d7 01       	movw	r26, r14
    1040:	15 96       	adiw	r26, 0x05	; 5
    1042:	ed 91       	ld	r30, X+
    1044:	fc 91       	ld	r31, X
    1046:	16 97       	sbiw	r26, 0x06	; 6
    1048:	c6 81       	ldd	r28, Z+6	; 0x06
    104a:	d7 81       	ldd	r29, Z+7	; 0x07
    104c:	ce 01       	movw	r24, r28
    104e:	0c 96       	adiw	r24, 0x0c	; 12
    1050:	f7 d9       	rcall	.-3090   	; 0x440 <vListRemove>
    1052:	8e 01       	movw	r16, r28
    1054:	0e 5f       	subi	r16, 0xFE	; 254
    1056:	1f 4f       	sbci	r17, 0xFF	; 255
    1058:	c8 01       	movw	r24, r16
    105a:	f2 d9       	rcall	.-3100   	; 0x440 <vListRemove>
    105c:	8e 89       	ldd	r24, Y+22	; 0x16
    105e:	90 91 08 08 	lds	r25, 0x0808	; 0x800808 <uxTopReadyPriority>
    1062:	98 17       	cp	r25, r24
    1064:	10 f4       	brcc	.+4      	; 0x106a <xTaskResumeAll+0x5e>
    1066:	80 93 08 08 	sts	0x0808, r24	; 0x800808 <uxTopReadyPriority>
    106a:	90 e0       	ldi	r25, 0x00	; 0
    106c:	9c 01       	movw	r18, r24
    106e:	22 0f       	add	r18, r18
    1070:	33 1f       	adc	r19, r19
    1072:	22 0f       	add	r18, r18
    1074:	33 1f       	adc	r19, r19
    1076:	22 0f       	add	r18, r18
    1078:	33 1f       	adc	r19, r19
    107a:	82 0f       	add	r24, r18
    107c:	93 1f       	adc	r25, r19
    107e:	b8 01       	movw	r22, r16
    1080:	84 5d       	subi	r24, 0xD4	; 212
    1082:	97 4f       	sbci	r25, 0xF7	; 247
    1084:	7b d9       	rcall	.-3338   	; 0x37c <vListInsertEnd>
    1086:	e0 91 35 08 	lds	r30, 0x0835	; 0x800835 <pxCurrentTCB>
    108a:	f0 91 36 08 	lds	r31, 0x0836	; 0x800836 <pxCurrentTCB+0x1>
    108e:	9e 89       	ldd	r25, Y+22	; 0x16
    1090:	86 89       	ldd	r24, Z+22	; 0x16
    1092:	98 17       	cp	r25, r24
    1094:	58 f0       	brcs	.+22     	; 0x10ac <xTaskResumeAll+0xa0>
    1096:	dc 2c       	mov	r13, r12
    1098:	09 c0       	rjmp	.+18     	; 0x10ac <xTaskResumeAll+0xa0>
    109a:	d1 2c       	mov	r13, r1
    109c:	0f 2e       	mov	r0, r31
    109e:	fd e0       	ldi	r31, 0x0D	; 13
    10a0:	ef 2e       	mov	r14, r31
    10a2:	f8 e0       	ldi	r31, 0x08	; 8
    10a4:	ff 2e       	mov	r15, r31
    10a6:	f0 2d       	mov	r31, r0
    10a8:	cc 24       	eor	r12, r12
    10aa:	c3 94       	inc	r12
    10ac:	f7 01       	movw	r30, r14
    10ae:	80 81       	ld	r24, Z
    10b0:	81 11       	cpse	r24, r1
    10b2:	c5 cf       	rjmp	.-118    	; 0x103e <xTaskResumeAll+0x32>
    10b4:	80 91 05 08 	lds	r24, 0x0805	; 0x800805 <uxMissedTicks>
    10b8:	88 23       	and	r24, r24
    10ba:	79 f0       	breq	.+30     	; 0x10da <xTaskResumeAll+0xce>
    10bc:	80 91 05 08 	lds	r24, 0x0805	; 0x800805 <uxMissedTicks>
    10c0:	88 23       	and	r24, r24
    10c2:	91 f0       	breq	.+36     	; 0x10e8 <xTaskResumeAll+0xdc>
    10c4:	e2 de       	rcall	.-572    	; 0xe8a <vTaskIncrementTick>
    10c6:	80 91 05 08 	lds	r24, 0x0805	; 0x800805 <uxMissedTicks>
    10ca:	81 50       	subi	r24, 0x01	; 1
    10cc:	80 93 05 08 	sts	0x0805, r24	; 0x800805 <uxMissedTicks>
    10d0:	80 91 05 08 	lds	r24, 0x0805	; 0x800805 <uxMissedTicks>
    10d4:	81 11       	cpse	r24, r1
    10d6:	f6 cf       	rjmp	.-20     	; 0x10c4 <xTaskResumeAll+0xb8>
    10d8:	07 c0       	rjmp	.+14     	; 0x10e8 <xTaskResumeAll+0xdc>
    10da:	f1 e0       	ldi	r31, 0x01	; 1
    10dc:	df 16       	cp	r13, r31
    10de:	21 f0       	breq	.+8      	; 0x10e8 <xTaskResumeAll+0xdc>
    10e0:	80 91 04 08 	lds	r24, 0x0804	; 0x800804 <xMissedYield>
    10e4:	81 30       	cpi	r24, 0x01	; 1
    10e6:	39 f4       	brne	.+14     	; 0x10f6 <xTaskResumeAll+0xea>
    10e8:	10 92 04 08 	sts	0x0804, r1	; 0x800804 <xMissedYield>
    10ec:	7f da       	rcall	.-2818   	; 0x5ec <vPortYield>
    10ee:	81 e0       	ldi	r24, 0x01	; 1
    10f0:	03 c0       	rjmp	.+6      	; 0x10f8 <xTaskResumeAll+0xec>
    10f2:	80 e0       	ldi	r24, 0x00	; 0
    10f4:	01 c0       	rjmp	.+2      	; 0x10f8 <xTaskResumeAll+0xec>
    10f6:	80 e0       	ldi	r24, 0x00	; 0
    10f8:	0f 90       	pop	r0
    10fa:	0f be       	out	0x3f, r0	; 63
    10fc:	df 91       	pop	r29
    10fe:	cf 91       	pop	r28
    1100:	1f 91       	pop	r17
    1102:	0f 91       	pop	r16
    1104:	ff 90       	pop	r15
    1106:	ef 90       	pop	r14
    1108:	df 90       	pop	r13
    110a:	cf 90       	pop	r12
    110c:	08 95       	ret

0000110e <vTaskDelayUntil>:
    110e:	0f 93       	push	r16
    1110:	1f 93       	push	r17
    1112:	cf 93       	push	r28
    1114:	df 93       	push	r29
    1116:	8c 01       	movw	r16, r24
    1118:	eb 01       	movw	r28, r22
    111a:	a7 de       	rcall	.-690    	; 0xe6a <vTaskSuspendAll>
    111c:	f8 01       	movw	r30, r16
    111e:	80 81       	ld	r24, Z
    1120:	91 81       	ldd	r25, Z+1	; 0x01
    1122:	c8 0f       	add	r28, r24
    1124:	d9 1f       	adc	r29, r25
    1126:	20 91 0a 08 	lds	r18, 0x080A	; 0x80080a <xTickCount>
    112a:	30 91 0b 08 	lds	r19, 0x080B	; 0x80080b <xTickCount+0x1>
    112e:	28 17       	cp	r18, r24
    1130:	39 07       	cpc	r19, r25
    1132:	68 f4       	brcc	.+26     	; 0x114e <vTaskDelayUntil+0x40>
    1134:	c8 17       	cp	r28, r24
    1136:	d9 07       	cpc	r29, r25
    1138:	30 f5       	brcc	.+76     	; 0x1186 <vTaskDelayUntil+0x78>
    113a:	80 91 0a 08 	lds	r24, 0x080A	; 0x80080a <xTickCount>
    113e:	90 91 0b 08 	lds	r25, 0x080B	; 0x80080b <xTickCount+0x1>
    1142:	d1 83       	std	Z+1, r29	; 0x01
    1144:	c0 83       	st	Z, r28
    1146:	8c 17       	cp	r24, r28
    1148:	9d 07       	cpc	r25, r29
    114a:	a0 f4       	brcc	.+40     	; 0x1174 <vTaskDelayUntil+0x66>
    114c:	0b c0       	rjmp	.+22     	; 0x1164 <vTaskDelayUntil+0x56>
    114e:	c8 17       	cp	r28, r24
    1150:	d9 07       	cpc	r29, r25
    1152:	a8 f0       	brcs	.+42     	; 0x117e <vTaskDelayUntil+0x70>
    1154:	80 91 0a 08 	lds	r24, 0x080A	; 0x80080a <xTickCount>
    1158:	90 91 0b 08 	lds	r25, 0x080B	; 0x80080b <xTickCount+0x1>
    115c:	8c 17       	cp	r24, r28
    115e:	9d 07       	cpc	r25, r29
    1160:	70 f0       	brcs	.+28     	; 0x117e <vTaskDelayUntil+0x70>
    1162:	11 c0       	rjmp	.+34     	; 0x1186 <vTaskDelayUntil+0x78>
    1164:	80 91 35 08 	lds	r24, 0x0835	; 0x800835 <pxCurrentTCB>
    1168:	90 91 36 08 	lds	r25, 0x0836	; 0x800836 <pxCurrentTCB+0x1>
    116c:	02 96       	adiw	r24, 0x02	; 2
    116e:	68 d9       	rcall	.-3376   	; 0x440 <vListRemove>
    1170:	ce 01       	movw	r24, r28
    1172:	3c dd       	rcall	.-1416   	; 0xbec <prvAddCurrentTaskToDelayedList>
    1174:	4b df       	rcall	.-362    	; 0x100c <xTaskResumeAll>
    1176:	81 11       	cpse	r24, r1
    1178:	0a c0       	rjmp	.+20     	; 0x118e <vTaskDelayUntil+0x80>
    117a:	38 da       	rcall	.-2960   	; 0x5ec <vPortYield>
    117c:	08 c0       	rjmp	.+16     	; 0x118e <vTaskDelayUntil+0x80>
    117e:	f8 01       	movw	r30, r16
    1180:	d1 83       	std	Z+1, r29	; 0x01
    1182:	c0 83       	st	Z, r28
    1184:	ef cf       	rjmp	.-34     	; 0x1164 <vTaskDelayUntil+0x56>
    1186:	f8 01       	movw	r30, r16
    1188:	d1 83       	std	Z+1, r29	; 0x01
    118a:	c0 83       	st	Z, r28
    118c:	f3 cf       	rjmp	.-26     	; 0x1174 <vTaskDelayUntil+0x66>
    118e:	df 91       	pop	r29
    1190:	cf 91       	pop	r28
    1192:	1f 91       	pop	r17
    1194:	0f 91       	pop	r16
    1196:	08 95       	ret

00001198 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    1198:	80 91 06 08 	lds	r24, 0x0806	; 0x800806 <uxSchedulerSuspended>
    119c:	81 11       	cpse	r24, r1
    119e:	13 c0       	rjmp	.+38     	; 0x11c6 <vTaskSwitchContext+0x2e>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    11a0:	80 91 08 08 	lds	r24, 0x0808	; 0x800808 <uxTopReadyPriority>
    11a4:	90 e0       	ldi	r25, 0x00	; 0
    11a6:	fc 01       	movw	r30, r24
    11a8:	ee 0f       	add	r30, r30
    11aa:	ff 1f       	adc	r31, r31
    11ac:	ee 0f       	add	r30, r30
    11ae:	ff 1f       	adc	r31, r31
    11b0:	ee 0f       	add	r30, r30
    11b2:	ff 1f       	adc	r31, r31
    11b4:	8e 0f       	add	r24, r30
    11b6:	9f 1f       	adc	r25, r31
    11b8:	fc 01       	movw	r30, r24
    11ba:	e4 5d       	subi	r30, 0xD4	; 212
    11bc:	f7 4f       	sbci	r31, 0xF7	; 247
    11be:	80 81       	ld	r24, Z
    11c0:	88 23       	and	r24, r24
    11c2:	29 f0       	breq	.+10     	; 0x11ce <vTaskSwitchContext+0x36>
    11c4:	1b c0       	rjmp	.+54     	; 0x11fc <vTaskSwitchContext+0x64>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    11c6:	81 e0       	ldi	r24, 0x01	; 1
    11c8:	80 93 04 08 	sts	0x0804, r24	; 0x800804 <xMissedYield>
    11cc:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    11ce:	80 91 08 08 	lds	r24, 0x0808	; 0x800808 <uxTopReadyPriority>
    11d2:	81 50       	subi	r24, 0x01	; 1
    11d4:	80 93 08 08 	sts	0x0808, r24	; 0x800808 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    11d8:	80 91 08 08 	lds	r24, 0x0808	; 0x800808 <uxTopReadyPriority>
    11dc:	90 e0       	ldi	r25, 0x00	; 0
    11de:	fc 01       	movw	r30, r24
    11e0:	ee 0f       	add	r30, r30
    11e2:	ff 1f       	adc	r31, r31
    11e4:	ee 0f       	add	r30, r30
    11e6:	ff 1f       	adc	r31, r31
    11e8:	ee 0f       	add	r30, r30
    11ea:	ff 1f       	adc	r31, r31
    11ec:	8e 0f       	add	r24, r30
    11ee:	9f 1f       	adc	r25, r31
    11f0:	fc 01       	movw	r30, r24
    11f2:	e4 5d       	subi	r30, 0xD4	; 212
    11f4:	f7 4f       	sbci	r31, 0xF7	; 247
    11f6:	80 81       	ld	r24, Z
    11f8:	88 23       	and	r24, r24
    11fa:	49 f3       	breq	.-46     	; 0x11ce <vTaskSwitchContext+0x36>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    11fc:	80 91 08 08 	lds	r24, 0x0808	; 0x800808 <uxTopReadyPriority>
    1200:	90 e0       	ldi	r25, 0x00	; 0
    1202:	9c 01       	movw	r18, r24
    1204:	22 0f       	add	r18, r18
    1206:	33 1f       	adc	r19, r19
    1208:	22 0f       	add	r18, r18
    120a:	33 1f       	adc	r19, r19
    120c:	22 0f       	add	r18, r18
    120e:	33 1f       	adc	r19, r19
    1210:	28 0f       	add	r18, r24
    1212:	39 1f       	adc	r19, r25
    1214:	d9 01       	movw	r26, r18
    1216:	a4 5d       	subi	r26, 0xD4	; 212
    1218:	b7 4f       	sbci	r27, 0xF7	; 247
    121a:	11 96       	adiw	r26, 0x01	; 1
    121c:	ed 91       	ld	r30, X+
    121e:	fc 91       	ld	r31, X
    1220:	12 97       	sbiw	r26, 0x02	; 2
    1222:	02 80       	ldd	r0, Z+2	; 0x02
    1224:	f3 81       	ldd	r31, Z+3	; 0x03
    1226:	e0 2d       	mov	r30, r0
    1228:	12 96       	adiw	r26, 0x02	; 2
    122a:	fc 93       	st	X, r31
    122c:	ee 93       	st	-X, r30
    122e:	11 97       	sbiw	r26, 0x01	; 1
    1230:	21 5d       	subi	r18, 0xD1	; 209
    1232:	37 4f       	sbci	r19, 0xF7	; 247
    1234:	e2 17       	cp	r30, r18
    1236:	f3 07       	cpc	r31, r19
    1238:	29 f4       	brne	.+10     	; 0x1244 <vTaskSwitchContext+0xac>
    123a:	22 81       	ldd	r18, Z+2	; 0x02
    123c:	33 81       	ldd	r19, Z+3	; 0x03
    123e:	fd 01       	movw	r30, r26
    1240:	32 83       	std	Z+2, r19	; 0x02
    1242:	21 83       	std	Z+1, r18	; 0x01
    1244:	fc 01       	movw	r30, r24
    1246:	ee 0f       	add	r30, r30
    1248:	ff 1f       	adc	r31, r31
    124a:	ee 0f       	add	r30, r30
    124c:	ff 1f       	adc	r31, r31
    124e:	ee 0f       	add	r30, r30
    1250:	ff 1f       	adc	r31, r31
    1252:	8e 0f       	add	r24, r30
    1254:	9f 1f       	adc	r25, r31
    1256:	fc 01       	movw	r30, r24
    1258:	e4 5d       	subi	r30, 0xD4	; 212
    125a:	f7 4f       	sbci	r31, 0xF7	; 247
    125c:	01 80       	ldd	r0, Z+1	; 0x01
    125e:	f2 81       	ldd	r31, Z+2	; 0x02
    1260:	e0 2d       	mov	r30, r0
    1262:	86 81       	ldd	r24, Z+6	; 0x06
    1264:	97 81       	ldd	r25, Z+7	; 0x07
    1266:	90 93 36 08 	sts	0x0836, r25	; 0x800836 <pxCurrentTCB+0x1>
    126a:	80 93 35 08 	sts	0x0835, r24	; 0x800835 <pxCurrentTCB>
    126e:	08 95       	ret

00001270 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    1270:	cf 93       	push	r28
    1272:	df 93       	push	r29
    1274:	eb 01       	movw	r28, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    1276:	60 91 35 08 	lds	r22, 0x0835	; 0x800835 <pxCurrentTCB>
    127a:	70 91 36 08 	lds	r23, 0x0836	; 0x800836 <pxCurrentTCB+0x1>
    127e:	64 5f       	subi	r22, 0xF4	; 244
    1280:	7f 4f       	sbci	r23, 0xFF	; 255
    1282:	a3 d8       	rcall	.-3770   	; 0x3ca <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1284:	80 91 35 08 	lds	r24, 0x0835	; 0x800835 <pxCurrentTCB>
    1288:	90 91 36 08 	lds	r25, 0x0836	; 0x800836 <pxCurrentTCB+0x1>
    128c:	02 96       	adiw	r24, 0x02	; 2
    128e:	d8 d8       	rcall	.-3664   	; 0x440 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    1290:	80 91 0a 08 	lds	r24, 0x080A	; 0x80080a <xTickCount>
    1294:	90 91 0b 08 	lds	r25, 0x080B	; 0x80080b <xTickCount+0x1>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    1298:	8c 0f       	add	r24, r28
    129a:	9d 1f       	adc	r25, r29
    129c:	a7 dc       	rcall	.-1714   	; 0xbec <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    129e:	df 91       	pop	r29
    12a0:	cf 91       	pop	r28
    12a2:	08 95       	ret

000012a4 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    12a4:	0f 93       	push	r16
    12a6:	1f 93       	push	r17
    12a8:	cf 93       	push	r28
    12aa:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    12ac:	dc 01       	movw	r26, r24
    12ae:	15 96       	adiw	r26, 0x05	; 5
    12b0:	ed 91       	ld	r30, X+
    12b2:	fc 91       	ld	r31, X
    12b4:	16 97       	sbiw	r26, 0x06	; 6
    12b6:	c6 81       	ldd	r28, Z+6	; 0x06
    12b8:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    12ba:	8e 01       	movw	r16, r28
    12bc:	04 5f       	subi	r16, 0xF4	; 244
    12be:	1f 4f       	sbci	r17, 0xFF	; 255
    12c0:	c8 01       	movw	r24, r16
    12c2:	be d8       	rcall	.-3716   	; 0x440 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    12c4:	80 91 06 08 	lds	r24, 0x0806	; 0x800806 <uxSchedulerSuspended>
    12c8:	81 11       	cpse	r24, r1
    12ca:	1a c0       	rjmp	.+52     	; 0x1300 <xTaskRemoveFromEventList+0x5c>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    12cc:	0a 50       	subi	r16, 0x0A	; 10
    12ce:	11 09       	sbc	r17, r1
    12d0:	c8 01       	movw	r24, r16
    12d2:	b6 d8       	rcall	.-3732   	; 0x440 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    12d4:	8e 89       	ldd	r24, Y+22	; 0x16
    12d6:	90 91 08 08 	lds	r25, 0x0808	; 0x800808 <uxTopReadyPriority>
    12da:	98 17       	cp	r25, r24
    12dc:	10 f4       	brcc	.+4      	; 0x12e2 <xTaskRemoveFromEventList+0x3e>
    12de:	80 93 08 08 	sts	0x0808, r24	; 0x800808 <uxTopReadyPriority>
    12e2:	90 e0       	ldi	r25, 0x00	; 0
    12e4:	9c 01       	movw	r18, r24
    12e6:	22 0f       	add	r18, r18
    12e8:	33 1f       	adc	r19, r19
    12ea:	22 0f       	add	r18, r18
    12ec:	33 1f       	adc	r19, r19
    12ee:	22 0f       	add	r18, r18
    12f0:	33 1f       	adc	r19, r19
    12f2:	82 0f       	add	r24, r18
    12f4:	93 1f       	adc	r25, r19
    12f6:	b8 01       	movw	r22, r16
    12f8:	84 5d       	subi	r24, 0xD4	; 212
    12fa:	97 4f       	sbci	r25, 0xF7	; 247
    12fc:	3f d8       	rcall	.-3970   	; 0x37c <vListInsertEnd>
    12fe:	04 c0       	rjmp	.+8      	; 0x1308 <xTaskRemoveFromEventList+0x64>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    1300:	b8 01       	movw	r22, r16
    1302:	8d e0       	ldi	r24, 0x0D	; 13
    1304:	98 e0       	ldi	r25, 0x08	; 8
    1306:	3a d8       	rcall	.-3980   	; 0x37c <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1308:	e0 91 35 08 	lds	r30, 0x0835	; 0x800835 <pxCurrentTCB>
    130c:	f0 91 36 08 	lds	r31, 0x0836	; 0x800836 <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    1310:	81 e0       	ldi	r24, 0x01	; 1
    1312:	2e 89       	ldd	r18, Y+22	; 0x16
    1314:	96 89       	ldd	r25, Z+22	; 0x16
    1316:	29 17       	cp	r18, r25
    1318:	08 f4       	brcc	.+2      	; 0x131c <xTaskRemoveFromEventList+0x78>
    131a:	80 e0       	ldi	r24, 0x00	; 0
}
    131c:	df 91       	pop	r29
    131e:	cf 91       	pop	r28
    1320:	1f 91       	pop	r17
    1322:	0f 91       	pop	r16
    1324:	08 95       	ret

00001326 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1326:	20 91 03 08 	lds	r18, 0x0803	; 0x800803 <xNumOfOverflows>
    132a:	fc 01       	movw	r30, r24
    132c:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    132e:	20 91 0a 08 	lds	r18, 0x080A	; 0x80080a <xTickCount>
    1332:	30 91 0b 08 	lds	r19, 0x080B	; 0x80080b <xTickCount+0x1>
    1336:	32 83       	std	Z+2, r19	; 0x02
    1338:	21 83       	std	Z+1, r18	; 0x01
    133a:	08 95       	ret

0000133c <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    133c:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    133e:	0f b6       	in	r0, 0x3f	; 63
    1340:	f8 94       	cli
    1342:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    1344:	80 91 03 08 	lds	r24, 0x0803	; 0x800803 <xNumOfOverflows>
    1348:	90 81       	ld	r25, Z
    134a:	98 17       	cp	r25, r24
    134c:	49 f0       	breq	.+18     	; 0x1360 <xTaskCheckForTimeOut+0x24>
    134e:	80 91 0a 08 	lds	r24, 0x080A	; 0x80080a <xTickCount>
    1352:	90 91 0b 08 	lds	r25, 0x080B	; 0x80080b <xTickCount+0x1>
    1356:	21 81       	ldd	r18, Z+1	; 0x01
    1358:	32 81       	ldd	r19, Z+2	; 0x02
    135a:	82 17       	cp	r24, r18
    135c:	93 07       	cpc	r25, r19
    135e:	f0 f4       	brcc	.+60     	; 0x139c <xTaskCheckForTimeOut+0x60>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    1360:	80 91 0a 08 	lds	r24, 0x080A	; 0x80080a <xTickCount>
    1364:	90 91 0b 08 	lds	r25, 0x080B	; 0x80080b <xTickCount+0x1>
    1368:	41 81       	ldd	r20, Z+1	; 0x01
    136a:	52 81       	ldd	r21, Z+2	; 0x02
    136c:	db 01       	movw	r26, r22
    136e:	2d 91       	ld	r18, X+
    1370:	3c 91       	ld	r19, X
    1372:	11 97       	sbiw	r26, 0x01	; 1
    1374:	84 1b       	sub	r24, r20
    1376:	95 0b       	sbc	r25, r21
    1378:	82 17       	cp	r24, r18
    137a:	93 07       	cpc	r25, r19
    137c:	88 f4       	brcc	.+34     	; 0x13a0 <xTaskCheckForTimeOut+0x64>
    137e:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    1380:	e0 91 0a 08 	lds	r30, 0x080A	; 0x80080a <xTickCount>
    1384:	f0 91 0b 08 	lds	r31, 0x080B	; 0x80080b <xTickCount+0x1>
    1388:	bf 01       	movw	r22, r30
    138a:	64 1b       	sub	r22, r20
    138c:	75 0b       	sbc	r23, r21
    138e:	26 1b       	sub	r18, r22
    1390:	37 0b       	sbc	r19, r23
    1392:	2d 93       	st	X+, r18
    1394:	3c 93       	st	X, r19
			vTaskSetTimeOutState( pxTimeOut );
    1396:	c7 df       	rcall	.-114    	; 0x1326 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    1398:	80 e0       	ldi	r24, 0x00	; 0
    139a:	03 c0       	rjmp	.+6      	; 0x13a2 <xTaskCheckForTimeOut+0x66>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    139c:	81 e0       	ldi	r24, 0x01	; 1
    139e:	01 c0       	rjmp	.+2      	; 0x13a2 <xTaskCheckForTimeOut+0x66>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    13a0:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    13a2:	0f 90       	pop	r0
    13a4:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    13a6:	08 95       	ret

000013a8 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    13a8:	81 e0       	ldi	r24, 0x01	; 1
    13aa:	80 93 04 08 	sts	0x0804, r24	; 0x800804 <xMissedYield>
    13ae:	08 95       	ret

000013b0 <memcpy>:
    13b0:	fb 01       	movw	r30, r22
    13b2:	dc 01       	movw	r26, r24
    13b4:	02 c0       	rjmp	.+4      	; 0x13ba <memcpy+0xa>
    13b6:	01 90       	ld	r0, Z+
    13b8:	0d 92       	st	X+, r0
    13ba:	41 50       	subi	r20, 0x01	; 1
    13bc:	50 40       	sbci	r21, 0x00	; 0
    13be:	d8 f7       	brcc	.-10     	; 0x13b6 <memcpy+0x6>
    13c0:	08 95       	ret

000013c2 <memset>:
    13c2:	dc 01       	movw	r26, r24
    13c4:	01 c0       	rjmp	.+2      	; 0x13c8 <memset+0x6>
    13c6:	6d 93       	st	X+, r22
    13c8:	41 50       	subi	r20, 0x01	; 1
    13ca:	50 40       	sbci	r21, 0x00	; 0
    13cc:	e0 f7       	brcc	.-8      	; 0x13c6 <memset+0x4>
    13ce:	08 95       	ret

000013d0 <strncpy>:
    13d0:	fb 01       	movw	r30, r22
    13d2:	dc 01       	movw	r26, r24
    13d4:	41 50       	subi	r20, 0x01	; 1
    13d6:	50 40       	sbci	r21, 0x00	; 0
    13d8:	48 f0       	brcs	.+18     	; 0x13ec <strncpy+0x1c>
    13da:	01 90       	ld	r0, Z+
    13dc:	0d 92       	st	X+, r0
    13de:	00 20       	and	r0, r0
    13e0:	c9 f7       	brne	.-14     	; 0x13d4 <strncpy+0x4>
    13e2:	01 c0       	rjmp	.+2      	; 0x13e6 <strncpy+0x16>
    13e4:	1d 92       	st	X+, r1
    13e6:	41 50       	subi	r20, 0x01	; 1
    13e8:	50 40       	sbci	r21, 0x00	; 0
    13ea:	e0 f7       	brcc	.-8      	; 0x13e4 <strncpy+0x14>
    13ec:	08 95       	ret

000013ee <_exit>:
    13ee:	f8 94       	cli

000013f0 <__stop_program>:
    13f0:	ff cf       	rjmp	.-2      	; 0x13f0 <__stop_program>
